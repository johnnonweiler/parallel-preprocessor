
<!DOCTYPE HTML>
<html lang="en-GB">
    
    <head>
    <meta charset="UTF-8">
    <!-- Redirect -->
    <!--<meta http-equiv="refresh" content="1;url=doxygen/html/../index.html">-->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
    
    <title>parallel-preprocessor</title>

    <nav class="navbar navbar-expand-sm bg-dark navbar-dark">
      <!-- Brand -->
      <a class="navbar-brand" href="../index.html">parallel-preprocessor</a>
    
      <!-- Links -->
      <ul class="navbar-nav">
        <!-- Dropdown -->
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
          Documentation
        </a>
        <div class="dropdown-menu">
          					<a class="dropdown-item" href="doxygen-docs.html">Doxygen Code Documentation</a>
					<a class="dropdown-item" href="model_documentation.html">Model Overview</a>
        </div>
      </li>
        <!-- Dropdown -->
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
            Code Checks
          </a>
          <div class="dropdown-menu">
            					<a class="dropdown-item" href="cppcheck.html">CPP Check</a>
					<a class="dropdown-item" href="code-coverage.html">Code Coverage</a>
					<a class="dropdown-item" href="flawfinder.html">Flawfinder</a>
					<a class="dropdown-item" href="simcpp.html">Sim C++</a>
					<a class="dropdown-item" href="clang_tidy.html">Clang Tidy</a>
          </div>
        </li>
      </ul>
    </nav> 
        
</head>
        
    <body>
    <div class="container">
    <div class="jumbotron">
        <h1>Sim C++</h1>
        <p>Sim C++ finds similarities within the code files.</p>
    </div>
    <p></p>
    </div>
    <div class="container">
    <table class="table table-striped">
    <thead>
      <tr>
        <th>File 1</th>
        <th>File 2</th>
      </tr>
    </thead>
    
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 285-368</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 890-973[400]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer PntInFace(const TopoDS
	gp_Pnt& theP,
	gp_Pnt2d& theP2D)
	{
	Standard_Boolean bIsDone, bHasFirstPo
	Standard_Integer iErr, aIx, aNbDomain
	Standard_Real aUMin, aUMax, aVMin, aV
	Standard_Real aVx, aUx, aV1, aV2, aU1
	Standard_Real aTotArcIntr, aTolTangfI
	gp_Dir2d aD2D (0., 1.);
	gp_Pnt2d aP2D;
	gp_Pnt aPx;
	Handle(Geom2d_Curve) aC2D;
	Handle(Geom2d_TrimmedCurve) aCT2D;
	Handle(Geom2d_Line) aL2D;
	Handle(Geom_Surface) aS;
	TopAbs_Orientation aOrE;
	TopoDS_Face aFF;
	TopExp_Explorer aExp;
	//
	aTolHatch2D=1.e-8;
	aTolHatch3D=1.e-8;
	aTotArcIntr=1.e-10;
	aTolTangfIntr=1.e-10;
	//
	Geom2dHatch_Intersector aIntr(aTotArc
	Geom2dHatch_Hatcher aHatcher(aIntr,
	aTolHatch2D, aTolHatch3D,
	Standard_True, Standard_False);
	//
	iErr=0;
	aEpsT=1.e-12;
	//
	aFF=aF;
	aFF.Orientation (TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	// 1
	aExp.Init (aFF, TopAbs_EDGE);
	for (; aExp.More() ; aExp.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	aOrE=aE.Orientation();
	//
	aC2D=BRep_Tool::CurveOnSurface (aE, a
	if (aC2D.IsNull() ) {
	iErr=1;
	return iErr;
	}
	if (fabs(aU1-aU2) < aEpsT) {
	iErr=2;
	return iErr;
	}
	//
	aCT2D=new Geom2d_TrimmedCurve(aC2D, a
	aHatcher.AddElement(aCT2D, aOrE);
	}// for (; aExp.More() ; aExp.Next())
	//
	// 2
	aUx=IntTools_Tools::IntermediatePoint
	aP2D.SetCoord(aUx, 0.);
	aL2D=new Geom2d_Line (aP2D, aD2D);
	Geom2dAdaptor_Curve aHCur(aL2D);
	//
	aIx=aHatcher.AddHatching(aHCur) ;
	//
	// 3.
	aHatcher.Trim();
	bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	iErr=3;
	return iErr;
	}
	//
	aHatcher.ComputeDomains(aIx);
	bIsDone=aHatcher.IsDone(aIx);
	if (!bIsDone) {
	iErr=4;
	return iErr;
	}
	//
	// 4.
	aNbDomains=aHatcher.NbDomains(aIx);</code></td>
          <td>	<code>Standard_Integer GEOMAlgo_AlgoTools::Pn
	gp_Pnt& theP,
	gp_Pnt2d& theP2D)
	{
	Standard_Boolean bIsDone, bHasFirstPo
	Standard_Integer iErr, aIx, aNbDomain
	Standard_Real aUMin, aUMax, aVMin, aV
	Standard_Real aVx, aUx, aV1, aV2, aU1
	Standard_Real aTotArcIntr, aTolTangfI
	gp_Dir2d aD2D (0., 1.);
	gp_Pnt2d aP2D;
	gp_Pnt aPx;
	Handle(Geom2d_Curve) aC2D;
	Handle(Geom2d_TrimmedCurve) aCT2D;
	Handle(Geom2d_Line) aL2D;
	Handle(Geom_Surface) aS;
	TopAbs_Orientation aOrE;
	TopoDS_Face aFF;
	TopExp_Explorer aExp;
	//
	aTolHatch2D=1.e-8;
	aTolHatch3D=1.e-8;
	aTotArcIntr=1.e-10;
	aTolTangfIntr=1.e-10;
	//
	Geom2dHatch_Intersector aIntr(aTotArc
	Geom2dHatch_Hatcher aHatcher(aIntr,
	aTolHatch2D, aTolHatch3D,
	Standard_True, Standard_False);
	//
	iErr=0;
	aEpsT=1.e-12;
	//
	aFF=aF;
	aFF.Orientation (TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	// 1
	aExp.Init (aFF, TopAbs_EDGE);
	for (; aExp.More() ; aExp.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	aOrE=aE.Orientation();
	//
	aC2D=BRep_Tool::CurveOnSurface (aE, a
	if (aC2D.IsNull() ) {
	iErr=1;
	return iErr;
	}
	if (fabs(aU1-aU2) < aEpsT) {
	iErr=2;
	return iErr;
	}
	//
	aCT2D=new Geom2d_TrimmedCurve(aC2D, a
	aHatcher.AddElement(aCT2D, aOrE);
	}// for (; aExp.More() ; aExp.Next())
	//
	// 2
	aUx=IntTools_Tools::IntermediatePoint
	aP2D.SetCoord(aUx, 0.);
	aL2D=new Geom2d_Line (aP2D, aD2D);
	Geom2dAdaptor_Curve aHCur(aL2D);
	//
	aIx=aHatcher.AddHatching(aHCur) ;
	//
	// 3.
	aHatcher.Trim();
	bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	iErr=3;
	return iErr;
	}
	//
	aHatcher.ComputeDomains(aIx);
	bIsDone=aHatcher.IsDone(aIx);
	if (!bIsDone) {
	iErr=4;
	return iErr;
	}
	//
	// 4.
	aVx=aVMin;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 890-973</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 285-368[400]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer GEOMAlgo_AlgoTools::Pn
	gp_Pnt& theP,
	gp_Pnt2d& theP2D)
	{
	Standard_Boolean bIsDone, bHasFirstPo
	Standard_Integer iErr, aIx, aNbDomain
	Standard_Real aUMin, aUMax, aVMin, aV
	Standard_Real aVx, aUx, aV1, aV2, aU1
	Standard_Real aTotArcIntr, aTolTangfI
	gp_Dir2d aD2D (0., 1.);
	gp_Pnt2d aP2D;
	gp_Pnt aPx;
	Handle(Geom2d_Curve) aC2D;
	Handle(Geom2d_TrimmedCurve) aCT2D;
	Handle(Geom2d_Line) aL2D;
	Handle(Geom_Surface) aS;
	TopAbs_Orientation aOrE;
	TopoDS_Face aFF;
	TopExp_Explorer aExp;
	//
	aTolHatch2D=1.e-8;
	aTolHatch3D=1.e-8;
	aTotArcIntr=1.e-10;
	aTolTangfIntr=1.e-10;
	//
	Geom2dHatch_Intersector aIntr(aTotArc
	Geom2dHatch_Hatcher aHatcher(aIntr,
	aTolHatch2D, aTolHatch3D,
	Standard_True, Standard_False);
	//
	iErr=0;
	aEpsT=1.e-12;
	//
	aFF=aF;
	aFF.Orientation (TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	// 1
	aExp.Init (aFF, TopAbs_EDGE);
	for (; aExp.More() ; aExp.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	aOrE=aE.Orientation();
	//
	aC2D=BRep_Tool::CurveOnSurface (aE, a
	if (aC2D.IsNull() ) {
	iErr=1;
	return iErr;
	}
	if (fabs(aU1-aU2) < aEpsT) {
	iErr=2;
	return iErr;
	}
	//
	aCT2D=new Geom2d_TrimmedCurve(aC2D, a
	aHatcher.AddElement(aCT2D, aOrE);
	}// for (; aExp.More() ; aExp.Next())
	//
	// 2
	aUx=IntTools_Tools::IntermediatePoint
	aP2D.SetCoord(aUx, 0.);
	aL2D=new Geom2d_Line (aP2D, aD2D);
	Geom2dAdaptor_Curve aHCur(aL2D);
	//
	aIx=aHatcher.AddHatching(aHCur) ;
	//
	// 3.
	aHatcher.Trim();
	bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	iErr=3;
	return iErr;
	}
	//
	aHatcher.ComputeDomains(aIx);
	bIsDone=aHatcher.IsDone(aIx);
	if (!bIsDone) {
	iErr=4;
	return iErr;
	}
	//
	// 4.
	aVx=aVMin;</code></td>
          <td>	<code>Standard_Integer PntInFace(const TopoDS
	gp_Pnt& theP,
	gp_Pnt2d& theP2D)
	{
	Standard_Boolean bIsDone, bHasFirstPo
	Standard_Integer iErr, aIx, aNbDomain
	Standard_Real aUMin, aUMax, aVMin, aV
	Standard_Real aVx, aUx, aV1, aV2, aU1
	Standard_Real aTotArcIntr, aTolTangfI
	gp_Dir2d aD2D (0., 1.);
	gp_Pnt2d aP2D;
	gp_Pnt aPx;
	Handle(Geom2d_Curve) aC2D;
	Handle(Geom2d_TrimmedCurve) aCT2D;
	Handle(Geom2d_Line) aL2D;
	Handle(Geom_Surface) aS;
	TopAbs_Orientation aOrE;
	TopoDS_Face aFF;
	TopExp_Explorer aExp;
	//
	aTolHatch2D=1.e-8;
	aTolHatch3D=1.e-8;
	aTotArcIntr=1.e-10;
	aTolTangfIntr=1.e-10;
	//
	Geom2dHatch_Intersector aIntr(aTotArc
	Geom2dHatch_Hatcher aHatcher(aIntr,
	aTolHatch2D, aTolHatch3D,
	Standard_True, Standard_False);
	//
	iErr=0;
	aEpsT=1.e-12;
	//
	aFF=aF;
	aFF.Orientation (TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	// 1
	aExp.Init (aFF, TopAbs_EDGE);
	for (; aExp.More() ; aExp.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	aOrE=aE.Orientation();
	//
	aC2D=BRep_Tool::CurveOnSurface (aE, a
	if (aC2D.IsNull() ) {
	iErr=1;
	return iErr;
	}
	if (fabs(aU1-aU2) < aEpsT) {
	iErr=2;
	return iErr;
	}
	//
	aCT2D=new Geom2d_TrimmedCurve(aC2D, a
	aHatcher.AddElement(aCT2D, aOrE);
	}// for (; aExp.More() ; aExp.Next())
	//
	// 2
	aUx=IntTools_Tools::IntermediatePoint
	aP2D.SetCoord(aUx, 0.);
	aL2D=new Geom2d_Line (aP2D, aD2D);
	Geom2dAdaptor_Curve aHCur(aL2D);
	//
	aIx=aHatcher.AddHatching(aHCur) ;
	//
	// 3.
	aHatcher.Trim();
	bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	iErr=3;
	return iErr;
	}
	//
	aHatcher.ComputeDomains(aIx);
	bIsDone=aHatcher.IsDone(aIx);
	if (!bIsDone) {
	iErr=4;
	return iErr;
	}
	//
	// 4.
	aNbDomains=aHatcher.NbDomains(aIx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 84-227</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 77-220[324]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_FinderShapeOn1::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;
	myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn1::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetSurface
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetSurfac
	{
	mySurface=aS;
	}
	//=====================================
	//function : Surface
	//purpose :
	//=====================================
	const Handle(Geom_Surface)& GEOMAlgo_Fi
	{
	return mySurface;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn1:
	{
	return myState;
	}
	//=====================================
	//function : SetNbPntsMin
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetNbPnts
	{
	myNbPntsMin=aNb;
	}
	//=====================================
	//function : NbPntsMin
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMin;
	}
	//=====================================
	//function : SetNbPntsMax
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetNbPnts
	{
	myNbPntsMax=aNb;
	}
	//=====================================
	//function : NbPntsMax
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMax;
	}
	//=====================================
	// function: MSS
	// purpose:
	//=====================================
	const GEOMAlgo_IndexedDataMapOfShapeSta
	{
	return myMSS;
	}
	//=====================================
	// function: Shapes
	// purpose:
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Fi
	{
	Standard_Integer i, aNb;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(
	if (aS.ShapeType()==myShapeType) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();
	//
	CheckData();
	if(myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();</code></td>
          <td>	<code>GEOMAlgo_FinderShapeOn2::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;
	myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn2::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetClsf
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetClsf(c
	{
	myClsf=aClsf;
	}
	//=====================================
	//function : Clsf
	//purpose :
	//=====================================
	const Handle(GEOMAlgo_Clsf)& GEOMAlgo_F
	{
	return myClsf;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn2:
	{
	return myState;
	}
	//=====================================
	//function : SetNbPntsMin
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMin=aNb;
	}
	//=====================================
	//function : NbPntsMin
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMin;
	}
	//=====================================
	//function : SetNbPntsMax
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMax=aNb;
	}
	//=====================================
	//function : NbPntsMax
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMax;
	}
	//=====================================
	// function: MSS
	// purpose:
	//=====================================
	const GEOMAlgo_IndexedDataMapOfShapeS
	{
	return myMSS;
	}
	//=====================================
	// function: Shapes
	// purpose:
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Fi
	{
	Standard_Integer i, aNb;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(
	if (aS.ShapeType()==myShapeType) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();
	//
	CheckData();
	if(myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 77-220</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 84-227[324]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_FinderShapeOn2::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;
	myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn2::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetClsf
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetClsf(c
	{
	myClsf=aClsf;
	}
	//=====================================
	//function : Clsf
	//purpose :
	//=====================================
	const Handle(GEOMAlgo_Clsf)& GEOMAlgo_F
	{
	return myClsf;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn2:
	{
	return myState;
	}
	//=====================================
	//function : SetNbPntsMin
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMin=aNb;
	}
	//=====================================
	//function : NbPntsMin
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMin;
	}
	//=====================================
	//function : SetNbPntsMax
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMax=aNb;
	}
	//=====================================
	//function : NbPntsMax
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMax;
	}
	//=====================================
	// function: MSS
	// purpose:
	//=====================================
	const GEOMAlgo_IndexedDataMapOfShapeS
	{
	return myMSS;
	}
	//=====================================
	// function: Shapes
	// purpose:
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Fi
	{
	Standard_Integer i, aNb;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(
	if (aS.ShapeType()==myShapeType) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();
	//
	CheckData();
	if(myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();</code></td>
          <td>	<code>GEOMAlgo_FinderShapeOn1::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;
	myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn1::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetSurface
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetSurfac
	{
	mySurface=aS;
	}
	//=====================================
	//function : Surface
	//purpose :
	//=====================================
	const Handle(Geom_Surface)& GEOMAlgo_Fi
	{
	return mySurface;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn1:
	{
	return myState;
	}
	//=====================================
	//function : SetNbPntsMin
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetNbPnts
	{
	myNbPntsMin=aNb;
	}
	//=====================================
	//function : NbPntsMin
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMin;
	}
	//=====================================
	//function : SetNbPntsMax
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::SetNbPnts
	{
	myNbPntsMax=aNb;
	}
	//=====================================
	//function : NbPntsMax
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMax;
	}
	//=====================================
	// function: MSS
	// purpose:
	//=====================================
	const GEOMAlgo_IndexedDataMapOfShapeSta
	{
	return myMSS;
	}
	//=====================================
	// function: Shapes
	// purpose:
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Fi
	{
	Standard_Integer i, aNb;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(
	if (aS.ShapeType()==myShapeType) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();
	//
	CheckData();
	if(myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 193-259</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 263-330[300]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aV=aMV(i);
	//
	if (aMVProcessed.Contains(aV)) {
	continue;
	}
	//
	Standard_Integer aNbIP, aIP, aNbIP1,
	TopTools_ListOfShape aLVSD;
	TColStd_MapOfInteger aMIP, aMIP1, aMI
	TColStd_MapIteratorOfMapOfInteger aIt
	//
	aMIP.Add(i);
	for(;;) {
	aNbIP=aMIP.Extent();
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	if (aMIPC.Contains(aIP)) {
	continue;
	}
	//
	const TopoDS_Shape& aVP=aMIS.FindFrom
	const GEOMAlgo_BndSphere& aBoxVP=aMSB
	//
	aSelector.Clear();
	aSelector.SetBox(aBoxVP);
	//
	aNbVSD=aBBTree.Select(aSelector);
	if (!aNbVSD) {
	continue; // it should not be so [at
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {
	aIP1=aIt.Value();
	if (aMIP.Contains(aIP1)) {
	continue;
	}
	aMIP1.Add(aIP1);
	} //for (; aIt.More(); aIt.Next()) {
	}//for(; aIt1.More(); aIt1.Next()) {
	//
	aNbIP1=aMIP1.Extent();
	if (!aNbIP1) {
	break;
	}
	//
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIPC.Add(aIP);
	}
	//
	aMIP.Clear();
	aIt1.Initialize(aMIP1);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIP.Add(aIP);
	}
	aMIP1.Clear();
	}// while(1)
	//
	// Fill myImages
	aNbIP=aMIPC.Extent();
	//
	if (!aNbIP) {// no SD vertices is fou
	</code></td>
          <td>	<code>const TopoDS_Vertex& aV=*((TopoDS_Ver
	//
	if (aMVProcessed.Contains(aV)) {
	continue;
	}
	//
	Standard_Integer aNbIP, aIP, aNbIP1,
	TopTools_ListOfShape aLVSD;
	TColStd_MapOfInteger aMIP, aMIP1, aMI
	TColStd_MapIteratorOfMapOfInteger aIt
	//
	aMIP.Add(i);
	for(;;) {
	aNbIP=aMIP.Extent();
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	if (aMIPC.Contains(aIP)) {
	continue;
	}
	//
	const TopoDS_Shape& aVP=aMIS.FindFrom
	const GEOMAlgo_BndSphere& aBoxVP=aMSB
	//
	aSelector.Clear();
	aSelector.SetBox(aBoxVP);
	//
	aNbVSD=aBBTree.Select(aSelector);
	if (!aNbVSD) {
	continue; // it must not be
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	//
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {
	aIP1=aIt.Value();
	if (aMIP.Contains(aIP1)) {
	continue;
	}
	aMIP1.Add(aIP1);
	} //for (; aIt.More(); aIt.Next()) {
	}//for(; aIt1.More(); aIt1.Next()) {
	//
	aNbIP1=aMIP1.Extent();
	if (!aNbIP1) {
	break;
	}
	//
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIPC.Add(aIP);
	}
	//
	aMIP.Clear();
	aIt1.Initialize(aMIP1);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIP.Add(aIP);
	}
	aMIP1.Clear();
	}// while(1)
	//
	// Fill myImages
	aNbIP=aMIPC.Extent();
	//
	if (!aNbIP) {// no SD vertices founde</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 263-330</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 193-259[300]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Vertex& aV=*((TopoDS_Ver
	//
	if (aMVProcessed.Contains(aV)) {
	continue;
	}
	//
	Standard_Integer aNbIP, aIP, aNbIP1,
	TopTools_ListOfShape aLVSD;
	TColStd_MapOfInteger aMIP, aMIP1, aMI
	TColStd_MapIteratorOfMapOfInteger aIt
	//
	aMIP.Add(i);
	for(;;) {
	aNbIP=aMIP.Extent();
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	if (aMIPC.Contains(aIP)) {
	continue;
	}
	//
	const TopoDS_Shape& aVP=aMIS.FindFrom
	const GEOMAlgo_BndSphere& aBoxVP=aMSB
	//
	aSelector.Clear();
	aSelector.SetBox(aBoxVP);
	//
	aNbVSD=aBBTree.Select(aSelector);
	if (!aNbVSD) {
	continue; // it must not be
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	//
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {
	aIP1=aIt.Value();
	if (aMIP.Contains(aIP1)) {
	continue;
	}
	aMIP1.Add(aIP1);
	} //for (; aIt.More(); aIt.Next()) {
	}//for(; aIt1.More(); aIt1.Next()) {
	//
	aNbIP1=aMIP1.Extent();
	if (!aNbIP1) {
	break;
	}
	//
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIPC.Add(aIP);
	}
	//
	aMIP.Clear();
	aIt1.Initialize(aMIP1);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIP.Add(aIP);
	}
	aMIP1.Clear();
	}// while(1)
	//
	// Fill myImages
	aNbIP=aMIPC.Extent();
	//
	if (!aNbIP) {// no SD vertices founde</code></td>
          <td>	<code>const TopoDS_Shape& aV=aMV(i);
	//
	if (aMVProcessed.Contains(aV)) {
	continue;
	}
	//
	Standard_Integer aNbIP, aIP, aNbIP1,
	TopTools_ListOfShape aLVSD;
	TColStd_MapOfInteger aMIP, aMIP1, aMI
	TColStd_MapIteratorOfMapOfInteger aIt
	//
	aMIP.Add(i);
	for(;;) {
	aNbIP=aMIP.Extent();
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	if (aMIPC.Contains(aIP)) {
	continue;
	}
	//
	const TopoDS_Shape& aVP=aMIS.FindFrom
	const GEOMAlgo_BndSphere& aBoxVP=aMSB
	//
	aSelector.Clear();
	aSelector.SetBox(aBoxVP);
	//
	aNbVSD=aBBTree.Select(aSelector);
	if (!aNbVSD) {
	continue; // it should not be so [at
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {
	aIP1=aIt.Value();
	if (aMIP.Contains(aIP1)) {
	continue;
	}
	aMIP1.Add(aIP1);
	} //for (; aIt.More(); aIt.Next()) {
	}//for(; aIt1.More(); aIt1.Next()) {
	//
	aNbIP1=aMIP1.Extent();
	if (!aNbIP1) {
	break;
	}
	//
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIPC.Add(aIP);
	}
	//
	aMIP.Clear();
	aIt1.Initialize(aMIP1);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	aMIP.Add(aIP);
	}
	aMIP1.Clear();
	}// while(1)
	//
	// Fill myImages
	aNbIP=aMIPC.Extent();
	//
	if (!aNbIP) {// no SD vertices is fou
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 467-543</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 519-596[292]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSt = GetPointState( aP );
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	}
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessSo
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState;
	Standard_Integer i, aNbS, j, aNbF;
	TopTools_IndexedMapOfShape aM, aMF;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Shape& aSd=aM(i);
	aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	bIsConformState=myMSS.Contains(aF);
	if (!bIsConformState) {
	break;// face has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aF);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // face has non-conformed s
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (bIsConformState) {
	myMSS.Add(aSd, aSt);
	}
	}
	}
	//
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	</code></td>
          <td>	<code>aSt=myClsf->State();
	//
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	myMSS.Add(aF, aSt);
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessSo
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState;
	Standard_Integer i, aNbS, j, aNbF;
	TopTools_IndexedMapOfShape aM, aMF;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Shape& aSd=aM(i);
	aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	bIsConformState=myMSS.Contains(aF);
	if (!bIsConformState) {
	break;// face has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aF);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // face has non-conformed s
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (bIsConformState) {
	myMSS.Add(aSd, aSt);
	}
	}
	}
	//
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 519-596</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 467-543[292]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSt=myClsf->State();
	//
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	myMSS.Add(aF, aSt);
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessSo
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState;
	Standard_Integer i, aNbS, j, aNbF;
	TopTools_IndexedMapOfShape aM, aMF;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Shape& aSd=aM(i);
	aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	bIsConformState=myMSS.Contains(aF);
	if (!bIsConformState) {
	break;// face has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aF);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // face has non-conformed s
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (bIsConformState) {
	myMSS.Add(aSd, aSt);
	}
	}
	}
	//
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{</code></td>
          <td>	<code>aSt = GetPointState( aP );
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	}
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessSo
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState;
	Standard_Integer i, aNbS, j, aNbF;
	TopTools_IndexedMapOfShape aM, aMF;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Shape& aSd=aM(i);
	aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	bIsConformState=myMSS.Contains(aF);
	if (!bIsConformState) {
	break;// face has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aF);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // face has non-conformed s
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (bIsConformState) {
	myMSS.Add(aSd, aSt);
	}
	}
	}
	//
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 595-654</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 264-323[257]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bHasNewSubShape;
	Standard_Integer i, aNbF, aNbSDF, iEr
	TopoDS_Shape aNewShape;
	TopTools_IndexedMapOfShape aMF;
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_PassKeyShape aPKF;
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	TopExp::MapShapes(myShape, aType, aMF
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	if (aType==TopAbs_FACE) {
	const TopoDS_Face& aF=TopoDS::Face(aS
	FacePassKey(aF, aPKF);
	}
	else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=TopoDS::Edge(aS
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	//
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}
	//
	const TopoDS_Shape& aS1=aLSDF.First()
	//
	bHasNewSubShape=Standard_True;</code></td>
          <td>	<code>myErrorStatus=0;
	//
	Standard_Integer i, aNbF, aNbSDF, iEr
	TopoDS_Shape aNewShape;
	TopTools_IndexedMapOfShape aMF;
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_PassKeyShape aPKF;
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	TopExp::MapShapes(myShape, aType, aMF
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	//aPKF.Clear();//qft
	if (aType==TopAbs_FACE) {
	const TopoDS_Face& aF=TopoDS::Face(aS
	FacePassKey(aF, aPKF);
	}
	else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=TopoDS::Edge(aS
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}
	//
	const TopoDS_Shape& aS1=aLSDF.First()
	aNewShape=aS1;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 264-323</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 595-654[257]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	Standard_Integer i, aNbF, aNbSDF, iEr
	TopoDS_Shape aNewShape;
	TopTools_IndexedMapOfShape aMF;
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_PassKeyShape aPKF;
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	TopExp::MapShapes(myShape, aType, aMF
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	//aPKF.Clear();//qft
	if (aType==TopAbs_FACE) {
	const TopoDS_Face& aF=TopoDS::Face(aS
	FacePassKey(aF, aPKF);
	}
	else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=TopoDS::Edge(aS
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}
	//
	const TopoDS_Shape& aS1=aLSDF.First()
	aNewShape=aS1;</code></td>
          <td>	<code>Standard_Boolean bHasNewSubShape;
	Standard_Integer i, aNbF, aNbSDF, iEr
	TopoDS_Shape aNewShape;
	TopTools_IndexedMapOfShape aMF;
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_PassKeyShape aPKF;
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	TopExp::MapShapes(myShape, aType, aMF
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	if (aType==TopAbs_FACE) {
	const TopoDS_Face& aF=TopoDS::Face(aS
	FacePassKey(aF, aPKF);
	}
	else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=TopoDS::Edge(aS
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	//
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}
	//
	const TopoDS_Shape& aS1=aLSDF.First()
	//
	bHasNewSubShape=Standard_True;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 791-842</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 541-594[243]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : BuildTriangulation
	//purpose :
	//=====================================
	Standard_Boolean
	GEOMAlgo_AlgoTools::BuildTriangulatio
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	return isTriangulation;
	}
	
	</code></td>
          <td>	<code>}
	//
	//=====================================
	//function : BuildTriangulation
	//purpose :
	//=====================================
	Standard_Boolean
	GEOMAlgo_FinderShapeOn::BuildTriangul
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	
	return isTriangulation;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 829-876</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 796-842[242]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean
	GEOMAlgo_FinderShapeOn2::BuildTriangu
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	
	return isTriangulation;
	}</code></td>
          <td>	<code>Standard_Boolean
	GEOMAlgo_AlgoTools::BuildTriangulatio
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	return isTriangulation;
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 547-594</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 829-876[242]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean
	GEOMAlgo_FinderShapeOn::BuildTriangul
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	
	return isTriangulation;
	}</code></td>
          <td>	<code>Standard_Boolean
	GEOMAlgo_FinderShapeOn2::BuildTriangu
	{
	// calculate deflection
	Standard_Real aDeviationCoefficient =
	
	Bnd_Box B;
	BRepBndLib::Add(theShape, B);
	Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm
	
	Standard_Real dx = aXmax - aXmin, dy
	Standard_Real aDeflection = Max(Max(d
	Standard_Real aHLRAngle = 0.349066;
	
	// build triangulation
	BRepMesh_IncrementalMesh Inc (theShap
	
	// check triangulation
	bool isTriangulation = true;
	
	TopExp_Explorer exp (theShape, TopAbs
	if (exp.More())
	{
	TopLoc_Location aTopLoc;
	Handle(Poly_Triangulation) aTRF;
	aTRF = BRep_Tool::Triangulation(TopoD
	if (aTRF.IsNull()) {
	isTriangulation = false;
	}
	}
	else // no faces, try edges
	{
	TopExp_Explorer expe (theShape, TopAb
	if (!expe.More()) {
	isTriangulation = false;
	}
	else {
	TopLoc_Location aLoc;
	Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	isTriangulation = false;
	}
	}
	}
	
	return isTriangulation;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.cpp: line 11-46</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 179-214[205]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> SparseMatrix<T>
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "r
	MM_typecode matcode;
	int ret_code = 0;
	int M, N, nz;
	int I, J;
	
	if (mm_read_banner(f, &matcode) != 0)
	{
	cout << "Error: can not read Matrix M
	}
	if (mm_is_complex(matcode) && mm_is_m
	{
	cout << "Market Market type: " << mm_
	}
	
	/* find out size of sparse matrix ...
	if ((ret_code = mm_read_mtx_crd_size(
	cout << "Error in reading Market Mark
	
	SparseMatrix Mat(M);
	
	double _val = 0.0;
	for (int i = 0; i < nz; i++)
	{
	fscanf(f, "%d %d %lg\n", &I, &J, &_va
	Mat.insertAt(I - 1, J - 1, T(_val));
	}
	
	if (f != stdin)
	fclose(f);
	
	return Mat;
	}</code></td>
          <td>	<code>static SparseMatrix readMatrixMarketF
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "r
	MM_typecode matcode;
	int ret_code = 0;
	int M, N, nz;
	int I, J;
	
	if (mm_read_banner(f, &matcode) != 0)
	{
	cout << "Error: can not read Matrix M
	}
	if (mm_is_complex(matcode) && mm_is_m
	{
	cout << "Market Market type: " << mm_
	}
	
	/* find out size of sparse matrix ...
	if ((ret_code = mm_read_mtx_crd_size(
	cout << "Error in reading Market Mark
	
	SparseMatrix Mat(M);
	
	double _val = 0.0;
	for (int i = 0; i < nz; i++)
	{
	fscanf(f, "%d %d %lg\n", &I, &J, &_va
	Mat.insertAt(I - 1, J - 1, T(_val));
	}
	
	if (f != stdin)
	fclose(f);
	
	return Mat;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 179-214</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.cpp: line 11-46[205]</strong></td>
        </tr>
        <tr>
          <td>	<code>static SparseMatrix readMatrixMarketF
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "r
	MM_typecode matcode;
	int ret_code = 0;
	int M, N, nz;
	int I, J;
	
	if (mm_read_banner(f, &matcode) != 0)
	{
	cout << "Error: can not read Matrix M
	}
	if (mm_is_complex(matcode) && mm_is_m
	{
	cout << "Market Market type: " << mm_
	}
	
	/* find out size of sparse matrix ...
	if ((ret_code = mm_read_mtx_crd_size(
	cout << "Error in reading Market Mark
	
	SparseMatrix Mat(M);
	
	double _val = 0.0;
	for (int i = 0; i < nz; i++)
	{
	fscanf(f, "%d %d %lg\n", &I, &J, &_va
	Mat.insertAt(I - 1, J - 1, T(_val));
	}
	
	if (f != stdin)
	fclose(f);
	
	return Mat;
	}</code></td>
          <td>	<code>template <typename T> SparseMatrix<T>
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "r
	MM_typecode matcode;
	int ret_code = 0;
	int M, N, nz;
	int I, J;
	
	if (mm_read_banner(f, &matcode) != 0)
	{
	cout << "Error: can not read Matrix M
	}
	if (mm_is_complex(matcode) && mm_is_m
	{
	cout << "Market Market type: " << mm_
	}
	
	/* find out size of sparse matrix ...
	if ((ret_code = mm_read_mtx_crd_size(
	cout << "Error in reading Market Mark
	
	SparseMatrix Mat(M);
	
	double _val = 0.0;
	for (int i = 0; i < nz; i++)
	{
	fscanf(f, "%d %d %lg\n", &I, &J, &_va
	Mat.insertAt(I - 1, J - 1, T(_val));
	}
	
	if (f != stdin)
	fclose(f);
	
	return Mat;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 611-641</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 558-588[188]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!BuildTriangulation(aF)) {
	myWarningStatus=20; // no triangulati
	return;
	}
	aTRF=BRep_Tool::Triangulation(aF, aLo
	}
	//
	const gp_Trsf& aTrsf=aLoc.Transformat
	const Poly_Array1OfTriangle& aTrs=aTR
	const TColgp_Array1OfPnt& aNodes=aTRF
	//
	// map link/nbtriangles
	j1=aTrs.Lower();
	j2=aTrs.Upper();
	for (j=j1; j<=j2; ++j) {
	const Poly_Triangle& aTr=aTrs(j);
	aTr.Get(n[0], n[1], n[2]);
	n[3]=n[0];
	for (k=0; k<3; ++k) {
	GEOMAlgo_PassKey aPK;
	//
	aPK.SetIds(n[k], n[k+1]);
	if (aMPKI.IsBound(aPK)) {
	Standard_Integer& iCntX=aMPKI.ChangeF
	++iCntX;
	}
	else {
	aMPKI.Bind(aPK, 1);
	}
	}
	}</code></td>
          <td>	<code>if (!GEOMAlgo_AlgoTools::BuildTriangu
	myWarningStatus=20; // no triangulati
	return;
	}
	aTRF=BRep_Tool::Triangulation(aF, aLo
	}
	//
	const gp_Trsf& aTrsf=aLoc.Transformat
	const Poly_Array1OfTriangle& aTrs=aTR
	const TColgp_Array1OfPnt& aNodes=aTRF
	//
	// map link/nbtriangles
	j1=aTrs.Lower();
	j2=aTrs.Upper();
	for (j=j1; j<=j2; ++j) {
	const Poly_Triangle& aTr=aTrs(j);
	aTr.Get(n[0], n[1], n[2]);
	n[3]=n[0];
	for (k=0; k<3; ++k) {
	GEOMAlgo_PassKey aPK;
	//
	aPK.SetIds(n[k], n[k+1]);
	if (aMPKI.IsBound(aPK)) {
	Standard_Integer& iCntX=aMPKI.ChangeF
	++iCntX;
	}
	else {
	aMPKI.Bind(aPK, 1);
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 558-588</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 611-641[188]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!GEOMAlgo_AlgoTools::BuildTriangu
	myWarningStatus=20; // no triangulati
	return;
	}
	aTRF=BRep_Tool::Triangulation(aF, aLo
	}
	//
	const gp_Trsf& aTrsf=aLoc.Transformat
	const Poly_Array1OfTriangle& aTrs=aTR
	const TColgp_Array1OfPnt& aNodes=aTRF
	//
	// map link/nbtriangles
	j1=aTrs.Lower();
	j2=aTrs.Upper();
	for (j=j1; j<=j2; ++j) {
	const Poly_Triangle& aTr=aTrs(j);
	aTr.Get(n[0], n[1], n[2]);
	n[3]=n[0];
	for (k=0; k<3; ++k) {
	GEOMAlgo_PassKey aPK;
	//
	aPK.SetIds(n[k], n[k+1]);
	if (aMPKI.IsBound(aPK)) {
	Standard_Integer& iCntX=aMPKI.ChangeF
	++iCntX;
	}
	else {
	aMPKI.Bind(aPK, 1);
	}
	}
	}</code></td>
          <td>	<code>if (!BuildTriangulation(aF)) {
	myWarningStatus=20; // no triangulati
	return;
	}
	aTRF=BRep_Tool::Triangulation(aF, aLo
	}
	//
	const gp_Trsf& aTrsf=aLoc.Transformat
	const Poly_Array1OfTriangle& aTrs=aTR
	const TColgp_Array1OfPnt& aNodes=aTRF
	//
	// map link/nbtriangles
	j1=aTrs.Lower();
	j2=aTrs.Upper();
	for (j=j1; j<=j2; ++j) {
	const Poly_Triangle& aTr=aTrs(j);
	aTr.Get(n[0], n[1], n[2]);
	n[3]=n[0];
	for (k=0; k<3; ++k) {
	GEOMAlgo_PassKey aPK;
	//
	aPK.SetIds(n[k], n[k+1]);
	if (aMPKI.IsBound(aPK)) {
	Standard_Integer& iCntX=aMPKI.ChangeF
	++iCntX;
	}
	else {
	aMPKI.Bind(aPK, 1);
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 266-313</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 217-263[180]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIP=aIt1.Key();
	const TopoDS_Shape& aVP=aMIS.FindFrom
	if (!j) {
	aVF=aVP;
	}
	aLVSD.Append(aVP);
	aMVProcessed.Add(aVP);
	}
	//}
	myImages.Bind(aVF, aLVSD);
	}// for (i=1; i<=aNbV; ++i) {
	//------------------------------
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	}
	}
	}
	}
	//=====================================
	//function : DetectFaces
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectFaces
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectEdges
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectShape
	{</code></td>
          <td>	<code>aIndex=aIt.Value();
	const TopoDS_Shape& aVx=aMIS.FindFrom
	if(!j) {
	aVF=aVx;
	}
	aLVSD.Append(aVx);
	aMVProcessed.Add(aVx);
	}
	myImages.Bind(aVF, aLVSD);
	}
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	//
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	}
	}
	}
	}
	//=====================================
	//function : DetectFaces
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectFac
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectEdg
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectSha
	{
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 217-263</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 266-313[180]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIndex=aIt.Value();
	const TopoDS_Shape& aVx=aMIS.FindFrom
	if(!j) {
	aVF=aVx;
	}
	aLVSD.Append(aVx);
	aMVProcessed.Add(aVx);
	}
	myImages.Bind(aVF, aLVSD);
	}
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	//
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	}
	}
	}
	}
	//=====================================
	//function : DetectFaces
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectFac
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectEdg
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectSha
	{
	</code></td>
          <td>	<code>aIP=aIt1.Key();
	const TopoDS_Shape& aVP=aMIS.FindFrom
	if (!j) {
	aVF=aVP;
	}
	aLVSD.Append(aVP);
	aMVProcessed.Add(aVP);
	}
	//}
	myImages.Bind(aVF, aLVSD);
	}// for (i=1; i<=aNbV; ++i) {
	//------------------------------
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	}
	}
	}
	}
	//=====================================
	//function : DetectFaces
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectFaces
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectEdges
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectShape
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 19-32</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 100-113[174]</strong></td>
        </tr>
        <tr>
          <td>	<code>def solid_interference_maker(doc):
	objs = [doc.addObject("Part::Box", "B
	
	# objs[0].ShapeColor = (0.67,0.00,1.0
	# move the second and beyond to a pla
	objs[1].Placement = App.Placement(
	App.Vector(10, 0, 0), App.Rotation(Ap
	)
	objs[2].Placement = App.Placement(
	App.Vector(0, 10, 0), App.Rotation(Ap
	)
	objs[3].Placement = App.Placement(
	App.Vector(10, 10, 0), App.Rotation(A
	)</code></td>
          <td>	<code>def build_geometry(self, doc):
	objs = [doc.addObject("Part::Box", "B
	
	# objs[0].ShapeColor = (0.67,0.00,1.0
	# move the second and beyond to a pla
	objs[1].Placement = App.Placement(
	App.Vector(10, 0, 0), App.Rotation(Ap
	)
	objs[2].Placement = App.Placement(
	App.Vector(0, 10, 0), App.Rotation(Ap
	)
	objs[3].Placement = App.Placement(
	App.Vector(10, 10, 0), App.Rotation(A
	)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 59-90</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 130-162[170]</strong></td>
        </tr>
        <tr>
          <td>	<code>return Standard_False;
	}
	
	// Compute confusion tolerance.
	Standard_Real aTolConf = Precision::C
	Standard_Integer i;
	
	for (i = 0; i < 2; ++i) {
	TopExp_Explorer anExp(i == 0 ? theWhe
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Vertex aVtx = TopoDS::Ve
	const Standard_Real aTolVtx = BRep_To
	
	if (aTolVtx > aTolConf) {
	aTolConf = aTolVtx;
	}
	}
	}
	
	// Compute mass tolerance.
	Bnd_Box aBoundingBox;
	Standard_Real aXmin, aYmin, aZmin, aX
	Standard_Real aMassTol;
	
	BRepBndLib::Add(theWhere, aBoundingBo
	BRepBndLib::Add(theWhat, aBoundingBox
	aBoundingBox.Get(aXmin, aYmin, aZmin,
	aMassTol = Max(aXmax - aXmin, aYmax -
	aMassTol = Max(aMassTol, aZmax - aZmi
	aMassTol *= aTolConf;
	</code></td>
          <td>	<code>// Error: An attempt to extract a sha
	return 2;
	}
	
	// Compute confusion tolerance.
	Standard_Real aTolConf = Precision::C
	Standard_Integer i;
	
	for (i = 0; i < 2; ++i) {
	TopExp_Explorer anExp(i == 0 ? theWhe
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Vertex aVtx = TopoDS::Ve
	const Standard_Real aTolVtx = BRep_To
	
	if (aTolVtx > aTolConf) {
	aTolConf = aTolVtx;
	}
	}
	}
	
	// Compute mass tolerance.
	Bnd_Box aBoundingBox;
	Standard_Real aXmin, aYmin, aZmin, aX
	Standard_Real aMassTol;
	
	BRepBndLib::Add(theWhere, aBoundingBo
	BRepBndLib::Add(theWhat, aBoundingBox
	aBoundingBox.Get(aXmin, aYmin, aZmin,
	aMassTol = Max(aXmax - aXmin, aYmax -
	aMassTol = Max(aMassTol, aZmax - aZmi
	aMassTol *= aTolConf;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 101-113</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 20-32[169]</strong></td>
        </tr>
        <tr>
          <td>	<code>objs = [doc.addObject("Part::Box", "B
	
	# objs[0].ShapeColor = (0.67,0.00,1.0
	# move the second and beyond to a pla
	objs[1].Placement = App.Placement(
	App.Vector(10, 0, 0), App.Rotation(Ap
	)
	objs[2].Placement = App.Placement(
	App.Vector(0, 10, 0), App.Rotation(Ap
	)
	objs[3].Placement = App.Placement(
	App.Vector(10, 10, 0), App.Rotation(A
	)</code></td>
          <td>	<code>objs = [doc.addObject("Part::Box", "B
	
	# objs[0].ShapeColor = (0.67,0.00,1.0
	# move the second and beyond to a pla
	objs[1].Placement = App.Placement(
	App.Vector(10, 0, 0), App.Rotation(Ap
	)
	objs[2].Placement = App.Placement(
	App.Vector(0, 10, 0), App.Rotation(Ap
	)
	objs[3].Placement = App.Placement(
	App.Vector(10, 10, 0), App.Rotation(A
	)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 216-240</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.cpp: line 48-72[161]</strong></td>
        </tr>
        <tr>
          <td>	<code>void writeMatrixMarketFile(const std:
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "w
	MM_typecode matcode;
	mm_initialize_typecode(&matcode);
	mm_set_matrix(&matcode);
	mm_set_coordinate(&matcode); // spars
	mm_set_symmetric(&matcode); // matrix
	mm_set_integer(&matcode); // value ty
	
	mm_write_banner(f, matcode);
	auto Nrows = int(this->rowCount());
	mm_write_mtx_crd_size(f, Nrows, Nrows
	
	/* NOTE: matrix market files use 1-ba
	of a vector has index 1, not 0. */
	for (int i = 0; i < Nrows; i++)
	{
	for (const auto& it : (*mat[i])) // c
	fprintf(f, "%d %d %s\n", int(i + 1),
	}
	fclose(f);
	}
	};</code></td>
          <td>	<code>template <typename T> void SparseMatr
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "w
	MM_typecode matcode;
	mm_initialize_typecode(&matcode);
	mm_set_matrix(&matcode);
	mm_set_coordinate(&matcode); // spars
	mm_set_symmetric(&matcode); // matrix
	mm_set_integer(&matcode); // value ty
	
	mm_write_banner(f, matcode);
	auto Nrows = int(this->rowCount());
	mm_write_mtx_crd_size(f, Nrows, Nrows
	
	/* NOTE: matrix market files use 1-ba
	of a vector has index 1, not 0. */
	for (int i = 0; i < Nrows; i++)
	{
	for (const auto& it : (*mat[i])) // c
	fprintf(f, "%d %d %s\n", int(i + 1),
	}
	fclose(f);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.cpp: line 48-72</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 216-240[161]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> void SparseMatr
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "w
	MM_typecode matcode;
	mm_initialize_typecode(&matcode);
	mm_set_matrix(&matcode);
	mm_set_coordinate(&matcode); // spars
	mm_set_symmetric(&matcode); // matrix
	mm_set_integer(&matcode); // value ty
	
	mm_write_banner(f, matcode);
	auto Nrows = int(this->rowCount());
	mm_write_mtx_crd_size(f, Nrows, Nrows
	
	/* NOTE: matrix market files use 1-ba
	of a vector has index 1, not 0. */
	for (int i = 0; i < Nrows; i++)
	{
	for (const auto& it : (*mat[i])) // c
	fprintf(f, "%d %d %s\n", int(i + 1),
	}
	fclose(f);
	}
	</code></td>
          <td>	<code>void writeMatrixMarketFile(const std:
	{
	using namespace std;
	FILE* f = fopen(file_name.c_str(), "w
	MM_typecode matcode;
	mm_initialize_typecode(&matcode);
	mm_set_matrix(&matcode);
	mm_set_coordinate(&matcode); // spars
	mm_set_symmetric(&matcode); // matrix
	mm_set_integer(&matcode); // value ty
	
	mm_write_banner(f, matcode);
	auto Nrows = int(this->rowCount());
	mm_write_mtx_crd_size(f, Nrows, Nrows
	
	/* NOTE: matrix market files use 1-ba
	of a vector has index 1, not 0. */
	for (int i = 0; i < Nrows; i++)
	{
	for (const auto& it : (*mat[i])) // c
	fprintf(f, "%d %d %s\n", int(i + 1),
	}
	fclose(f);
	}
	};</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 112-129</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 157-175[157]</strong></td>
        </tr>
        <tr>
          <td>	<code>double nbIn = 0.;
	for ( size_t i = 0; i < myPlanes.size
	{
	TopAbs_State aSt;
	GEOMAlgo_SurfaceTools::GetState(aP, m
	if ( aSt == TopAbs_IN )
	{
	nbIn += myConcaveSide[i] ? 0.5 : 1.0;
	}
	else if ( aSt == TopAbs_ON )
	{
	// check that aP is between quadrangl
	Handle(Geom_Plane) aSidePlane = Handl
	gp_Vec aSideNorm = aSidePlane->Axis()
	gp_Vec aSideVec = myQuadNormal ^ aSid
	gp_Vec c1p ( myPoints[i], aP );
	gp_Vec pc2 ( aP, myPoints[i+1] );
	if ( aSideVec * c1p >= 0. && aSideVec
	</code></td>
          <td>	<code>double nbIn = 0.;
	
	for (size_t i = 0; i < myPlanes.size(
	TopAbs_State aSt;
	
	GEOMAlgo_SurfaceTools::GetState(myPnt
	
	if (aSt == TopAbs_IN) {
	nbIn += myConcaveSide[i] ? 0.5 : 1.0;
	} else if (aSt == TopAbs_ON) {
	// check that aP is between quadrangl
	Handle(Geom_Plane) aSidePlane =
	Handle(Geom_Plane)::DownCast(myPlanes
	gp_Vec aSideNorm = aSidePlane->Axis()
	gp_Vec aSideVec = myQuadNormal ^ aSid
	gp_Vec c1p (myPoints[i], myPnt);
	gp_Vec pc2 (myPnt, myPoints[i+1]);
	
	if (aSideVec * c1p >= 0. && aSideVec</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 157-175</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 112-129[157]</strong></td>
        </tr>
        <tr>
          <td>	<code>double nbIn = 0.;
	
	for (size_t i = 0; i < myPlanes.size(
	TopAbs_State aSt;
	
	GEOMAlgo_SurfaceTools::GetState(myPnt
	
	if (aSt == TopAbs_IN) {
	nbIn += myConcaveSide[i] ? 0.5 : 1.0;
	} else if (aSt == TopAbs_ON) {
	// check that aP is between quadrangl
	Handle(Geom_Plane) aSidePlane =
	Handle(Geom_Plane)::DownCast(myPlanes
	gp_Vec aSideNorm = aSidePlane->Axis()
	gp_Vec aSideVec = myQuadNormal ^ aSid
	gp_Vec c1p (myPoints[i], myPnt);
	gp_Vec pc2 (myPnt, myPoints[i+1]);
	
	if (aSideVec * c1p >= 0. && aSideVec</code></td>
          <td>	<code>double nbIn = 0.;
	for ( size_t i = 0; i < myPlanes.size
	{
	TopAbs_State aSt;
	GEOMAlgo_SurfaceTools::GetState(aP, m
	if ( aSt == TopAbs_IN )
	{
	nbIn += myConcaveSide[i] ? 0.5 : 1.0;
	}
	else if ( aSt == TopAbs_ON )
	{
	// check that aP is between quadrangl
	Handle(Geom_Plane) aSidePlane = Handl
	gp_Vec aSideNorm = aSidePlane->Axis()
	gp_Vec aSideVec = myQuadNormal ^ aSid
	gp_Vec c1p ( myPoints[i], aP );
	gp_Vec pc2 ( aP, myPoints[i+1] );
	if ( aSideVec * c1p >= 0. && aSideVec
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 644-670</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 592-617[155]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt.Initialize(aMPKI);
	for (; aIt.More(); aIt.Next()) {
	iCnt=aIt.Value();
	if (iCnt==1) {
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	aNx=(Standard_Integer)aPK.Id(1);
	aMBN.Add(aNx);
	aNx=(Standard_Integer)aPK.Id(2);
	aMBN.Add(aNx);
	
	}
	}
	//
	// inner nodes=all_nodes - boundary_n
	j1=aNodes.Lower();
	j2=aNodes.Upper();
	for (j=j1; j<=j2; ++j) {
	if (!aMBN.Contains(j)) {
	aP=aNodes(j).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	//
	//modified by NIZNHY-PKV Mon Sep 24 0
	if (!aNb && myNbPntsMin) { // A</code></td>
          <td>	<code>aIt.Initialize(aMPKI);
	for (; aIt.More(); aIt.Next()) {
	iCnt=aIt.Value();
	if (iCnt==1) {
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	//
	aNx=(Standard_Integer)aPK.Id(1);
	aMBN.Add(aNx);
	aNx=(Standard_Integer)aPK.Id(2);
	aMBN.Add(aNx);
	}
	}
	//
	// inner nodes=all_nodes - boundary_n
	j1=aNodes.Lower();
	j2=aNodes.Upper();
	for (j=j1; j<=j2; ++j) {
	if (!aMBN.Contains(j)) {
	aP=aNodes(j).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	//
	if (!aNb && myNbPntsMin) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 428-466</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 470-509[151]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType2!=aType1) {
	continue;
	}
	}
	//
	bIsConformState=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aE=aExp.Current()
	bIsConformState=myMSS.Contains(aE);
	if (!bIsConformState) {
	break;// edge has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aE);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // edge has non-conformed s
	}
	//
	InnerPoints(aF, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();
	</code></td>
          <td>	<code>if(!bCanBeON) {
	continue;
	}
	}
	//
	//
	bIsConformState=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aE=aExp.Current()
	bIsConformState=myMSS.Contains(aE);
	if (!bIsConformState) {
	break;// edge has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aE);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // edge has non-conformed s
	}
	//
	InnerPoints(aF, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 678-726</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 826-874[151]</strong></td>
        </tr>
        <tr>
          <td>	<code>continue;
	}
	//------------------------------
	bFound=CheckCoincidence(aF1, aE2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aF1, aE2);
	}
	}
	}
	//=====================================
	//function : PerformFF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformFF()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aF2=aCS.Shape2();
	
	PerformFF(aF1, aF2);
	
	if (myErrorStatus) {
	return;
	}
	
	PerformFF(aF2, aF1);
	
	if (myErrorStatus) {
	return;
	}
	}
	}
	//=====================================
	//function : PerformFF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformFF(con
	const TopoDS_Shape &theF2)
	{
	Standard_Boolean bFound, bHasOnF, bHa
	Standard_Integer i, aNbS2;</code></td>
          <td>	<code>continue;
	}
	//------------------------------
	bFound=CheckCoincidence(aSo1, aF2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aSo1, aF2);
	}
	}
	}
	//=====================================
	//function : PerformZZ
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformZZ()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_SOLID, T
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aSo1=aCS.Shape1()
	const TopoDS_Shape& aSo2=aCS.Shape2()
	
	PerformZZ(aSo1, aSo2);
	
	if (myErrorStatus) {
	return;
	}
	
	PerformZZ(aSo2, aSo1);
	
	if (myErrorStatus) {
	return;
	}
	}// for (; myIterator.More(); myItera
	}
	//=====================================
	//function : PerformZZ
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformZZ(con
	const TopoDS_Shape &theSo2)
	{
	Standard_Boolean bFound, bHasOn, bHas
	Standard_Integer i, aNbS2, iCntOn, iC</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 470-509</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 428-466[151]</strong></td>
        </tr>
        <tr>
          <td>	<code>if(!bCanBeON) {
	continue;
	}
	}
	//
	//
	bIsConformState=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aE=aExp.Current()
	bIsConformState=myMSS.Contains(aE);
	if (!bIsConformState) {
	break;// edge has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aE);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // edge has non-conformed s
	}
	//
	InnerPoints(aF, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
          <td>	<code>if (aType2!=aType1) {
	continue;
	}
	}
	//
	bIsConformState=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aE=aExp.Current()
	bIsConformState=myMSS.Contains(aE);
	if (!bIsConformState) {
	break;// edge has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aE);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // edge has non-conformed s
	}
	//
	InnerPoints(aF, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 234-263</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 164-193[147]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(myShape, TopAbs_VER
	aNbV=aMV.Extent();
	if (!aNbV) {
	myErrorStatus=2; // no vertices in so
	return;
	}
	//
	for (i=1; i<=aNbV; ++i) {
	GEOMAlgo_BndSphere aBox;
	//
	const TopoDS_Vertex& aV=*((TopoDS_Ver
	aPV=BRep_Tool::Pnt(aV);
	aTolV=BRep_Tool::Tolerance(aV);
	//
	aBox.SetGap(myTol);
	aBox.SetCenter(aPV);
	aBox.SetRadius(aTolV);
	//
	aTreeFiller.Add(i, aBox);
	//
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aTreeFiller.Fill();
	//
	//------------------------------
	// Chains
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=*((TopoDS_Ver</code></td>
          <td>	<code>TopExp::MapShapes(myArgument, TopAbs_
	aNbV=aMV.Extent();
	if (!aNbV) {
	myErrorStatus=2; // no vertices in so
	return;
	}
	//
	for (i=1; i<=aNbV; ++i) {
	GEOMAlgo_BndSphere aBox;
	//
	const TopoDS_Vertex& aV=*((TopoDS_Ver
	aPV=BRep_Tool::Pnt(aV);
	aTolV=BRep_Tool::Tolerance(aV);
	//
	aBox.SetGap(myTolerance);
	aBox.SetCenter(aPV);
	aBox.SetRadius(aTolV);
	//
	aTreeFiller.Add(i, aBox);
	//
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aTreeFiller.Fill();
	//
	//-----------------------------------
	// Chains
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 463-509</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 679-725[146]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	bFound=CheckCoincidence(aE1, aV2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aE1, aV2);
	}
	}
	}
	//=====================================
	//function : PerformEE
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformEE()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_EDGE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aE1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();
	
	PerformEE(aE1, aE2);
	
	if (myErrorStatus) {
	return;
	}
	
	PerformEE(aE2, aE1);
	
	if (myErrorStatus) {
	return;
	}
	}
	}
	//=====================================
	//function : PerformEE
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformEE(con
	const TopoDS_Shape &theE2)
	{
	Standard_Boolean bHasOn, bHasIn, bFou</code></td>
          <td>	<code>}
	//------------------------------
	bFound=CheckCoincidence(aF1, aE2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aF1, aE2);
	}
	}
	}
	//=====================================
	//function : PerformFF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformFF()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aF2=aCS.Shape2();
	
	PerformFF(aF1, aF2);
	
	if (myErrorStatus) {
	return;
	}
	
	PerformFF(aF2, aF1);
	
	if (myErrorStatus) {
	return;
	}
	}
	}
	//=====================================
	//function : PerformFF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformFF(con
	const TopoDS_Shape &theF2)
	{
	Standard_Boolean bFound, bHasOnF, bHa</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 622-651</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 664-693[145]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_CIRC
	aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	if (!aNbV) {
	myErrorStatus=11; // circle edge with
	return;
	}
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);
	//
	if (aNbV==1) {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	aInfo.SetKindOfName(GEOMAlgo_KN_CIRCL
	}
	else {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetKindOfName(GEOMAlgo_KN_ARCCI
	//
	gp_Vec aVecX(aP, aP1);
	gp_Dir aDirX(aVecX);
	gp_Ax2 aAx2new(aP, aAx2.Direction(),
	aInfo.SetPosition(aAx2new);
	}
	}// else if (aCT==GeomAbs_Circle) {</code></td>
          <td>	<code>aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	aInfo.SetRadius2(aR2);
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	if (!aNbV) {
	myErrorStatus=11; // ellipse edge wit
	return;
	}
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);
	//
	if (aNbV==1) {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	aInfo.SetKindOfName(GEOMAlgo_KN_ELLIP
	}
	else {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetKindOfName(GEOMAlgo_KN_ARCEL
	//
	gp_Vec aVecX(aP, aP1);
	gp_Dir aDirX(aVecX);
	gp_Ax2 aAx2new(aP, aAx2.Direction(),
	aInfo.SetPosition(aAx2new);
	}
	}// else if (aCT==GeomAbs_Ellipse) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 135-188</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 189-242[144]</strong></td>
        </tr>
        <tr>
          <td>	<code>break;
	case BRepCheck_InvalidPointOnCurve:
	error_msg << ";Invalid point on curve
	break;
	case BRepCheck_InvalidPointOnCurveOnS
	error_msg << ";Invalid point on curve
	break;
	case BRepCheck_InvalidPointOnSurface:
	error_msg << ";Invalid point on surfa
	break;
	case BRepCheck_No3DCurve:
	error_msg << ";No 3D curve";
	break;
	case BRepCheck_Multiple3DCurve:
	error_msg << ";Multiple 3D curve";
	break;
	case BRepCheck_Invalid3DCurve:
	error_msg << ";Invalid 3D curve";
	break;
	case BRepCheck_NoCurveOnSurface:
	error_msg << ";No curve on surface";
	break;
	case BRepCheck_InvalidCurveOnSurface:
	error_msg << ";Invalid curve on surfa
	break;
	case BRepCheck_InvalidCurveOnClosedSu
	error_msg << ";Invalid curve on close
	break;
	case BRepCheck_InvalidSameRangeFlag:
	error_msg << ";Invalid same-range fla
	break;
	case BRepCheck_InvalidSameParameterFl
	error_msg << ";Invalid same-parameter
	break;
	case BRepCheck_InvalidDegeneratedFlag
	error_msg << ";Invalid degenerated fl
	break;
	case BRepCheck_FreeEdge:
	error_msg << ";Free edge";
	break;
	case BRepCheck_InvalidMultiConnexity:
	error_msg << ";Invalid multi-connexit
	break;
	case BRepCheck_InvalidRange:
	error_msg << ";Invalid range";
	break;
	case BRepCheck_EmptyWire:
	error_msg << ";Empty wire";
	break;
	case BRepCheck_RedundantEdge:
	error_msg << ";Redundant edge";
	break;
	case BRepCheck_SelfIntersectingWire:
	error_msg << ";Self-intersecting wire</code></td>
          <td>	<code>break;
	case BRepCheck_NoSurface:
	error_msg << ";No surface";
	break;
	case BRepCheck_InvalidWire:
	error_msg << ";Invalid wires";
	break;
	case BRepCheck_RedundantWire:
	error_msg << ";Redundant wires";
	break;
	case BRepCheck_IntersectingWires:
	error_msg << ";Intersecting wires";
	break;
	case BRepCheck_InvalidImbricationOfWi
	error_msg << ";Invalid imbrication of
	break;
	case BRepCheck_InvalidImbricationOfSh
	error_msg << ";BRepCheck_InvalidImbri
	break;
	case BRepCheck_EmptyShell:
	error_msg << ";Empty shell";
	break;
	case BRepCheck_RedundantFace:
	error_msg << ";Redundant face";
	break;
	case BRepCheck_UnorientableShape:
	error_msg << ";Unorientable shape";
	break;
	case BRepCheck_NotClosed:
	error_msg << ";Not closed";
	break;
	case BRepCheck_NotConnected:
	error_msg << ";Not connected";
	break;
	case BRepCheck_SubshapeNotInShape:
	error_msg << ";Subshape not in shape"
	break;
	case BRepCheck_BadOrientation:
	error_msg << ";Bad orientation";
	break;
	case BRepCheck_BadOrientationOfSubsha
	error_msg << ";Bad orientation of sub
	break;
	case BRepCheck_InvalidToleranceValue:
	error_msg << ";Invalid tolerance valu
	break;
	case BRepCheck_EnclosedRegion:
	error_msg << ";Enclosed region";
	break;
	case BRepCheck_InvalidPolygonOnTriang
	error_msg << ";Invalid polygon on tri
	break;
	case BRepCheck_CheckFail:
	error_msg << ";Check failed";</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 334-369</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 614-650[139]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE=*((TopoDS_Edge*
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}
	</code></td>
          <td>	<code>const TopoDS_Edge& aE=TopoDS::Edge(aS
	EdgePassKey(aE, aPKF);
	}
	//
	if (myErrorStatus) {
	return;
	}
	//
	if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}
	// check geometric coincidence
	if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}
	}
	//
	// Images/Origins
	//
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP
	aNbSDF=aLSDF.Extent();
	if (!aNbSDF) {
	myErrorStatus=4; // it must not be
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 128-209</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 298-379[138]</strong></td>
        </tr>
        <tr>
          <td>	<code>return 0;
	}
	//=====================================
	//function : SetKindOfShape
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfShape
	{
	myKindOfShape=aT;
	}
	//=====================================
	//function : KindOfShape
	//purpose :
	//=====================================
	GEOMAlgo_KindOfShape GEOMAlgo_ShapeInfo
	{
	return myKindOfShape;
	}
	//=====================================
	//function : SetKindOfName
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfName(
	{
	myKindOfName=aT;
	}
	//=====================================
	//function : KindOfName
	//purpose :
	//=====================================
	GEOMAlgo_KindOfName GEOMAlgo_ShapeInfo:
	{
	return myKindOfName;
	}
	//=====================================
	//function : SetKindOfBounds
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfBound
	{
	myKindOfBounds=aT;
	}
	//=====================================
	//function : KindOfBounds
	//purpose :
	//=====================================
	GEOMAlgo_KindOfBounds GEOMAlgo_ShapeInf
	{
	return myKindOfBounds;
	}
	//=====================================
	//function : SetKindOfClosed
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfClose
	{
	myKindOfClosed=aT;
	}
	//=====================================
	//function : KindOfClosed
	//purpose :
	//=====================================
	GEOMAlgo_KindOfClosed GEOMAlgo_ShapeInf
	{
	return myKindOfClosed;
	}
	//=====================================
	//function : SetKindOfDef
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfDef(c
	{
	myKindOfDef=aT;
	}
	//=====================================
	//function : KindOfDef
	//purpose :
	//=====================================
	GEOMAlgo_KindOfDef GEOMAlgo_ShapeInfo::
	{
	return myKindOfDef;
	}</code></td>
          <td>	<code>return myPnt2;
	}
	//=====================================
	//function : SetRadius1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius1(con
	{
	myRadius1=aR;
	}
	//=====================================
	//function : Radius1
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius1;
	}
	//=====================================
	//function : SetRadius2
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius2(con
	{
	myRadius2=aR;
	}
	//=====================================
	//function : Radius2
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius2;
	}
	//=====================================
	//function : SetLength
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetLength(cons
	{
	myLength=aL;
	}
	//=====================================
	//function : Length
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Lengt
	{
	return myLength;
	}
	//=====================================
	//function : SetWidth
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetWidth(const
	{
	myWidth=aW;
	}
	//=====================================
	//function : Width
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Width
	{
	return myWidth;
	}
	//=====================================
	//function : SetHeight
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetHeight(cons
	{
	myHeight=aH;
	}
	//=====================================
	//function : Height
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Heigh
	{
	return myHeight;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 974-1006</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 368-400[132]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbDomains=aHatcher.NbDomains(aIx);
	if (!aNbDomains) {
	iErr=5;
	return iErr;
	}
	//
	i=1;
	const HatchGen_Domain& aDomain=aHatch
	bHasFirstPoint=aDomain.HasFirstPoint(
	if (!bHasFirstPoint) {
	iErr=5;
	return iErr;
	}
	//
	aV1=aDomain.FirstPoint().Parameter();
	//
	bHasSecondPoint=aDomain.HasSecondPoin
	if (!bHasSecondPoint) {
	iErr=6;
	return iErr;
	}
	//
	aV2=aDomain.SecondPoint().Parameter()
	//
	aVx=IntTools_Tools::IntermediatePoint
	//
	aS->D0(aUx, aVx, aPx);
	//
	theP2D.SetCoord(aUx, aVx);
	theP=aPx;
	//
	return iErr;
	}</code></td>
          <td>	<code>aNbDomains=aHatcher.NbDomains(aIx);
	if (!aNbDomains) {
	iErr=5;
	return iErr;
	}
	//
	i=1;
	const HatchGen_Domain& aDomain=aHatch
	bHasFirstPoint=aDomain.HasFirstPoint(
	if (!bHasFirstPoint) {
	iErr=5;
	return iErr;
	}
	//
	aV1=aDomain.FirstPoint().Parameter();
	//
	bHasSecondPoint=aDomain.HasSecondPoin
	if (!bHasSecondPoint) {
	iErr=6;
	return iErr;
	}
	//
	aV2=aDomain.SecondPoint().Parameter()
	//
	aVx=IntTools_Tools::IntermediatePoint
	//
	aS->D0(aUx, aVx, aPx);
	//
	theP2D.SetCoord(aUx, aVx);
	theP=aPx;
	//
	return iErr;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BoxBndTree.cxx: line 33-92</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.cxx: line 30-89[132]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_BoxBndTreeSelector::GEOMAlgo
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_BoxBndTreeSelector::~GEOMAlg
	{
	}
	//=====================================
	//function : Reject
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BoxBndTreeS
	{
	Standard_Boolean bRet;
	//
	bRet=myBox.IsOut(aBox);
	return bRet;
	}
	//=====================================
	//function : Accept
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BoxBndTreeS
	{
	Standard_Boolean bRet=Standard_False;
	//
	if (myFence.Add(aIndex)) {
	myIndices.Append(aIndex);
	bRet=!bRet;
	}
	return bRet;
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_BoxBndTreeSelector::Set
	{
	myBox=aBox;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_BoxBndTreeSelector::Cle
	{
	myFence.Clear();
	myIndices.Clear();
	}
	//=====================================
	//function : Indices
	//purpose :
	//=====================================
	const TColStd_ListOfInteger& GEOMAlgo
	{
	return myIndices;
	}</code></td>
          <td>	<code>GEOMAlgo_BndSphereTreeSelector::GEOMA
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_BndSphereTreeSelector::~GEOM
	{
	}
	//=====================================
	//function : Reject
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BndSphereTr
	{
	Standard_Boolean bRet;
	//
	bRet=myBox.IsOut(aBox);
	return bRet;
	}
	//=====================================
	//function : Accept
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BndSphereTr
	{
	Standard_Boolean bRet=Standard_False;
	//
	if (myFence.Add(aIndex)) {
	myIndices.Append(aIndex);
	bRet=!bRet;
	}
	return bRet;
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::
	{
	myBox=aBox;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::
	{
	myFence.Clear();
	myIndices.Clear();
	}
	//=====================================
	//function : Indices
	//purpose :
	//=====================================
	const TColStd_ListOfInteger& GEOMAlgo
	{
	return myIndices;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.cxx: line 30-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BoxBndTree.cxx: line 33-92[132]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_BndSphereTreeSelector::GEOMA
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_BndSphereTreeSelector::~GEOM
	{
	}
	//=====================================
	//function : Reject
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BndSphereTr
	{
	Standard_Boolean bRet;
	//
	bRet=myBox.IsOut(aBox);
	return bRet;
	}
	//=====================================
	//function : Accept
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BndSphereTr
	{
	Standard_Boolean bRet=Standard_False;
	//
	if (myFence.Add(aIndex)) {
	myIndices.Append(aIndex);
	bRet=!bRet;
	}
	return bRet;
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::
	{
	myBox=aBox;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::
	{
	myFence.Clear();
	myIndices.Clear();
	}
	//=====================================
	//function : Indices
	//purpose :
	//=====================================
	const TColStd_ListOfInteger& GEOMAlgo
	{
	return myIndices;
	}</code></td>
          <td>	<code>GEOMAlgo_BoxBndTreeSelector::GEOMAlgo
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_BoxBndTreeSelector::~GEOMAlg
	{
	}
	//=====================================
	//function : Reject
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BoxBndTreeS
	{
	Standard_Boolean bRet;
	//
	bRet=myBox.IsOut(aBox);
	return bRet;
	}
	//=====================================
	//function : Accept
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BoxBndTreeS
	{
	Standard_Boolean bRet=Standard_False;
	//
	if (myFence.Add(aIndex)) {
	myIndices.Append(aIndex);
	bRet=!bRet;
	}
	return bRet;
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_BoxBndTreeSelector::Set
	{
	myBox=aBox;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_BoxBndTreeSelector::Cle
	{
	myFence.Clear();
	myIndices.Clear();
	}
	//=====================================
	//function : Indices
	//purpose :
	//=====================================
	const TColStd_ListOfInteger& GEOMAlgo
	{
	return myIndices;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 368-400</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 974-1006[130]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbDomains=aHatcher.NbDomains(aIx);
	if (!aNbDomains) {
	iErr=5;
	return iErr;
	}
	//
	i=1;
	const HatchGen_Domain& aDomain=aHatch
	bHasFirstPoint=aDomain.HasFirstPoint(
	if (!bHasFirstPoint) {
	iErr=5;
	return iErr;
	}
	//
	aV1=aDomain.FirstPoint().Parameter();
	//
	bHasSecondPoint=aDomain.HasSecondPoin
	if (!bHasSecondPoint) {
	iErr=6;
	return iErr;
	}
	//
	aV2=aDomain.SecondPoint().Parameter()
	//
	aVx=IntTools_Tools::IntermediatePoint
	//
	aS->D0(aUx, aVx, aPx);
	//
	theP2D.SetCoord(aUx, aVx);
	theP=aPx;
	//
	return iErr;
	}</code></td>
          <td>	<code>aNbDomains=aHatcher.NbDomains(aIx);
	if (!aNbDomains) {
	iErr=5;
	return iErr;
	}
	//
	i=1;
	const HatchGen_Domain& aDomain=aHatch
	bHasFirstPoint=aDomain.HasFirstPoint(
	if (!bHasFirstPoint) {
	iErr=5;
	return iErr;
	}
	//
	aV1=aDomain.FirstPoint().Parameter();
	//
	bHasSecondPoint=aDomain.HasSecondPoin
	if (!bHasSecondPoint) {
	iErr=6;
	return iErr;
	}
	//
	aV2=aDomain.SecondPoint().Parameter()
	//
	aVx=IntTools_Tools::IntermediatePoint
	//
	aS->D0(aUx, aVx, aPx);
	//
	theP2D.SetCoord(aUx, aVx);
	theP=aPx;
	//
	return iErr;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 413-448</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 511-546[129]</strong></td>
        </tr>
        <tr>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}
	//
	aSt=myClsf->State();
	//
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_EDGE) {
	if (bIsConformState) {
	myMSS.Add(aE, aSt);
	}
	}
	myMSS.Add(aE, aSt);
	}
	} // for (i=1; i<=aNb; ++i) next edge
	}
	//=====================================
	//function : ProcessFaces
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessFa
	{
	myErrorStatus=0;</code></td>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}
	//
	aSt=myClsf->State();
	//
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	}
	myMSS.Add(aF, aSt);
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessSo
	{
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 723-748</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 749-775[128]</strong></td>
        </tr>
        <tr>
          <td>	<code>return res;
	}
	
	TopoDS_Shape fuseShape(const VectorTy
	{
	assert(v.size() >= 2UL);
	
	TopoDS_Shape result;
	
	BRepAlgoAPI_Fuse bc{v[0], v[1]};
	bc.SetRunParallel(occInternalParallel
	// bc.SetFuzzyValue(); tolerance?
	bc.SetNonDestructive(Standard_True);
	if (not bc.IsDone())
	{
	LOG_F(ERROR, "BRepAlgoAPI_Fuse (boole
	}
	result = bc.Shape();
	for (size_t i = 2; i < v.size(); i++)
	{
	BRepAlgoAPI_Fuse bc{result, v[i]};
	bc.SetRunParallel(occInternalParallel
	// bc.SetFuzzyValue(); tolerance?
	bc.SetNonDestructive(Standard_True);
	result = bc.Shape();
	}
	</code></td>
          <td>	<code>return result;
	}
	
	/// if error happen, the return shape
	TopoDS_Shape commonShape(const Vector
	{
	assert(v.size() >= 2UL);
	
	TopoDS_Shape result;
	
	BRepAlgoAPI_Common bc{v[0], v[1]};
	bc.SetRunParallel(occInternalParallel
	// bc.SetFuzzyValue(); tolerance?
	bc.SetNonDestructive(Standard_True);
	if (not bc.IsDone())
	{
	LOG_F(ERROR, "BRepAlgoAPI_Common is n
	}
	result = bc.Shape();
	for (size_t i = 2; i < v.size(); i++)
	{
	BRepAlgoAPI_Common bc{result, v[i]};
	bc.SetRunParallel(occInternalParallel
	// bc.SetFuzzyValue(); tolerance?
	bc.SetNonDestructive(Standard_True);
	result = bc.Shape();
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 595-617</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 647-670[126]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (iCnt==1) {
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	//
	aNx=(Standard_Integer)aPK.Id(1);
	aMBN.Add(aNx);
	aNx=(Standard_Integer)aPK.Id(2);
	aMBN.Add(aNx);
	}
	}
	//
	// inner nodes=all_nodes - boundary_n
	j1=aNodes.Lower();
	j2=aNodes.Upper();
	for (j=j1; j<=j2; ++j) {
	if (!aMBN.Contains(j)) {
	aP=aNodes(j).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	//
	if (!aNb && myNbPntsMin) {
	</code></td>
          <td>	<code>if (iCnt==1) {
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	aNx=(Standard_Integer)aPK.Id(1);
	aMBN.Add(aNx);
	aNx=(Standard_Integer)aPK.Id(2);
	aMBN.Add(aNx);
	
	}
	}
	//
	// inner nodes=all_nodes - boundary_n
	j1=aNodes.Lower();
	j2=aNodes.Upper();
	for (j=j1; j<=j2; ++j) {
	if (!aMBN.Contains(j)) {
	aP=aNodes(j).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	//
	//modified by NIZNHY-PKV Mon Sep 24 0
	if (!aNb && myNbPntsMin) { // A</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 207-230</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 115-138[122]</strong></td>
        </tr>
        <tr>
          <td>	<code>const BOPDS_DS& aDS=myDSFiller->DS();
	BOPDS_DS* pDS=(BOPDS_DS*)&aDS;
	const TopTools_ListOfShape& aLS=pDS->
	//
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {
	myErrorStatus=13;
	return;
	}
	//
	iRank=-1;
	const TopoDS_Shape& aObj=aLS.First();
	if (aObj.ShapeType()==TopAbs_SHELL) {
	iRank=0;
	}
	const TopoDS_Shape& aTool=aLS.Last();
	if (aTool.ShapeType()==TopAbs_SHELL)
	iRank=1;
	}
	//
	if (iRank==-1) {
	myErrorStatus=14;
	return;
	}</code></td>
          <td>	<code>const BOPDS_DS& aDS=myDSFiller->DS();
	BOPDS_DS* pDS=(BOPDS_DS*)&aDS;
	//
	const TopTools_ListOfShape& aLS=pDS->
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {
	myErrorStatus=14;
	return;
	}
	//
	iRank=-1;
	const TopoDS_Shape& aObj=aLS.First();
	if (aObj.ShapeType()==TopAbs_WIRE) {
	iRank=0;
	}
	const TopoDS_Shape& aTool=aLS.Last();
	if (aTool.ShapeType()==TopAbs_WIRE) {
	iRank=1;
	}
	//
	if (iRank==-1) {
	myErrorStatus=15;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 619-644</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 785-810[122]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_MapOfShape& aMSOn=mySh
	aItMS.Initialize(aMSOn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aF1, aS2);
	}
	}
	//
	if (myShapesIn.IsBound(aE1)) {
	const TopTools_MapOfShape& aMSIn=mySh
	aItMS.Initialize(aMSIn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aF1, aS2);
	}
	}
	}//for (j=1; j<=aNbE; ++j) {
	}//for (i=1; i<=aNbF; ++i) {
	}
	//=====================================
	//function : PerformEF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformEF()
	{
	Standard_Boolean bFound, bHasOnF, bHa</code></td>
          <td>	<code>const TopTools_MapOfShape& aMSOn=mySh
	aItMS.Initialize(aMSOn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aSD1, aS2);
	}
	}
	//
	if (myShapesIn.IsBound(aF1)) {
	const TopTools_MapOfShape& aMSIn=mySh
	aItMS.Initialize(aMSIn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aSD1, aS2);
	}
	}
	}//for (j=1; j<=aNbF; ++j) {
	}//for (i=1; i<=aNbS; ++i) {
	}
	//=====================================
	//function : PerformZF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformZF()
	{
	Standard_Boolean bFound, bHasOnF;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 171-193</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 241-263[118]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbV; ++i) {
	GEOMAlgo_BndSphere aBox;
	//
	const TopoDS_Vertex& aV=*((TopoDS_Ver
	aPV=BRep_Tool::Pnt(aV);
	aTolV=BRep_Tool::Tolerance(aV);
	//
	aBox.SetGap(myTolerance);
	aBox.SetCenter(aPV);
	aBox.SetRadius(aTolV);
	//
	aTreeFiller.Add(i, aBox);
	//
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aTreeFiller.Fill();
	//
	//-----------------------------------
	// Chains
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
          <td>	<code>for (i=1; i<=aNbV; ++i) {
	GEOMAlgo_BndSphere aBox;
	//
	const TopoDS_Vertex& aV=*((TopoDS_Ver
	aPV=BRep_Tool::Pnt(aV);
	aTolV=BRep_Tool::Tolerance(aV);
	//
	aBox.SetGap(myTol);
	aBox.SetCenter(aPV);
	aBox.SetRadius(aTolV);
	//
	aTreeFiller.Add(i, aBox);
	//
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aTreeFiller.Fill();
	//
	//------------------------------
	// Chains
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=*((TopoDS_Ver</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 17-33</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 44-60[117]</strong></td>
        </tr>
        <tr>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	
	def load_shape(filename):
	# this function does not work properl
	_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #
	print(obj.Label)
	s = None
	if hasattr(obj, "Shape"):
	s = obj.Shape
	App.closeDocument(App.ActiveDocument.
	return s # it is possible to return s</code></td>
          <td>	<code>import Part
	
	
	def load_shape(filename):
	# this function does not work properl
	_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #
	print(obj.Label)
	s = None
	if hasattr(obj, "Shape"):
	s = obj.Shape
	App.closeDocument(App.ActiveDocument.
	return s # it is possible to return s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 789-818</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 685-713[117]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	const Standard_Integer aNbPntsMin,
	GEOMAlgo_ListOfPnt& aLP)
	{
	// try to fill it yourself
	Standard_Boolean bInf1, bInf2;
	Standard_Integer j, aNbT;
	Standard_Real dT, aT, aT1, aT2;
	gp_Pnt aP;
	Handle(Geom_Curve) aC3D;
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	if (aC3D.IsNull()) {
	return;
	}
	//
	bInf1=Precision::IsNegativeInfinite(a
	return;
	}
	//
	aNbT=myNbPntsMin+1;
	dT=(aT2-aT1)/aNbT;
	for (j=1; j<=aNbPntsMin; ++j) {</code></td>
          <td>	<code>}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	const Standard_Integer aNbPntsMin,
	GEOMAlgo_ListOfPnt& aLP)
	{
	Standard_Boolean bInf1, bInf2;
	Standard_Integer j, aNbT;
	Standard_Real dT, aT, aT1, aT2;
	gp_Pnt aP;
	Handle(Geom_Curve) aC3D;
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	if (aC3D.IsNull()) {
	return;
	}
	//
	bInf1=Precision::IsNegativeInfinite(a
	bInf2=Precision::IsPositiveInfinite(a
	}
	//
	aNbT=aNbPntsMin+1;
	dT=(aT2-aT1)/aNbT;
	for (j=1; j<aNbT; ++j) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 44-60</strong></td>
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 17-33[117]</strong></td>
        </tr>
        <tr>
          <td>	<code>import Part
	
	
	def load_shape(filename):
	# this function does not work properl
	_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #
	print(obj.Label)
	s = None
	if hasattr(obj, "Shape"):
	s = obj.Shape
	App.closeDocument(App.ActiveDocument.
	return s # it is possible to return s</code></td>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	
	def load_shape(filename):
	# this function does not work properl
	_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #
	print(obj.Label)
	s = None
	if hasattr(obj, "Shape"):
	s = obj.Shape
	App.closeDocument(App.ActiveDocument.
	return s # it is possible to return s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 336-354</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 391-409[114]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_PLAN
	aInfo.SetKindOfName(GEOMAlgo_KN_PLANE
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	//
	BRepTools::UVBounds(aF, aUMin, aUMax,
	bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(
	bInfV2=Precision::IsPositiveInfinite(
	//
	if (bInf) {
	aInfo.SetKindOfBounds(GEOMAlgo_KB_INF
	return;
	}
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI</code></td>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_CYLI
	aInfo.SetKindOfName(GEOMAlgo_KN_CYLIN
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);
	//
	BRepTools::UVBounds(aF, aUMin, aUMax,
	bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(
	bInfV2=Precision::IsPositiveInfinite(
	//
	if (bInf) {
	aInfo.SetKindOfBounds(GEOMAlgo_KB_INF
	return;
	}
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 255-262</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 106-114[112]</strong></td>
        </tr>
        <tr>
          <td>	<code># after inputFile is given, all other
	inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.spl
	case_name = inputFilename[: inputFile
	######################## module speci
	outputFile = case_name + "_processed.
	if args.outputFile:
	outputFile = args.outputFile
	</code></td>
          <td>	<code># after inputFile is given, all other d
	inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.split
	case_name = inputFilename[: inputFilena
	######################## module specifi
	
	outputFile = case_name + "_processed.br
	if args.outputFile:
	outputFile = args.outputFile</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 106-114</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 255-262[112]</strong></td>
        </tr>
        <tr>
          <td>	<code># after inputFile is given, all other d
	inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.split
	case_name = inputFilename[: inputFilena
	######################## module specifi
	
	outputFile = case_name + "_processed.br
	if args.outputFile:
	outputFile = args.outputFile</code></td>
          <td>	<code># after inputFile is given, all other
	inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.spl
	case_name = inputFilename[: inputFile
	######################## module speci
	outputFile = case_name + "_processed.
	if args.outputFile:
	outputFile = args.outputFile
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 191-229</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 202-240[110]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS=myMap(i);
	if (!aOther.myMap.Contains(aS)) {
	return bRet;
	}
	}
	return !bRet;
	}
	//=====================================
	//function : HashCode
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKeyShap
	{
	return ::HashCode(mySum, aUpper);
	}
	//=====================================
	//function : Dump
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::Dump(cons
	{
	}
	//=====================================
	// function: NormalizedId
	// purpose :
	//=====================================
	Standard_Integer NormalizedId(const Sta
	const Standard_Integer aDiv)
	{
	Standard_Integer aMax, aTresh, aIdRet
	//
	aIdRet=aId;
	aMax=::IntegerLast();
	aTresh=aMax/aDiv;
	if (aId>aTresh) {
	aIdRet=aId%aTresh;
	}
	return aIdRet;
	}</code></td>
          <td>	<code>aId=myMap(i);
	if (!aOther.myMap.Contains(aId)) {
	return bRet;
	}
	}
	return !bRet;
	}
	//=====================================
	//function : HashCode
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Ha
	{
	return ::HashCode(mySum, aUpper);
	}
	//=====================================
	//function : Dump
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::Dump(const Sta
	{
	}
	//=====================================
	// function: NormalizedId
	// purpose :
	//=====================================
	Standard_Integer NormalizedId(const Sta
	const Standard_Integer aDiv)
	{
	Standard_Integer aMax, aTresh, aIdRet
	//
	aIdRet=aId;
	aMax=::IntegerLast();
	aTresh=aMax/aDiv;
	if (aId>aTresh) {
	aIdRet=aId%aTresh;
	}
	return aIdRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 202-240</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 191-229[110]</strong></td>
        </tr>
        <tr>
          <td>	<code>aId=myMap(i);
	if (!aOther.myMap.Contains(aId)) {
	return bRet;
	}
	}
	return !bRet;
	}
	//=====================================
	//function : HashCode
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Ha
	{
	return ::HashCode(mySum, aUpper);
	}
	//=====================================
	//function : Dump
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::Dump(const Sta
	{
	}
	//=====================================
	// function: NormalizedId
	// purpose :
	//=====================================
	Standard_Integer NormalizedId(const Sta
	const Standard_Integer aDiv)
	{
	Standard_Integer aMax, aTresh, aIdRet
	//
	aIdRet=aId;
	aMax=::IntegerLast();
	aTresh=aMax/aDiv;
	if (aId>aTresh) {
	aIdRet=aId%aTresh;
	}
	return aIdRet;
	}</code></td>
          <td>	<code>const TopoDS_Shape& aS=myMap(i);
	if (!aOther.myMap.Contains(aS)) {
	return bRet;
	}
	}
	return !bRet;
	}
	//=====================================
	//function : HashCode
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKeyShap
	{
	return ::HashCode(mySum, aUpper);
	}
	//=====================================
	//function : Dump
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::Dump(cons
	{
	}
	//=====================================
	// function: NormalizedId
	// purpose :
	//=====================================
	Standard_Integer NormalizedId(const Sta
	const Standard_Integer aDiv)
	{
	Standard_Integer aMax, aTresh, aIdRet
	//
	aIdRet=aId;
	aMax=::IntegerLast();
	aTresh=aMax/aDiv;
	if (aId>aTresh) {
	aIdRet=aId%aTresh;
	}
	return aIdRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 271-293</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 296-318[109]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbS1; ++i) {
	const TopoDS_Shape& aSS1=aMS1(i);
	if (aMS2.Contains(aSS1)) {
	continue;
	}
	//
	if (!myOriginsDetected.IsBound(aSS1))
	myErrorStatus=30;
	return;
	}
	//
	const TopoDS_Shape& aSkey=myOriginsDe
	if (aDMSLS.IsBound(aSkey)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aSS1);
	}
	else {
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aSS1);
	aDMSLS.Bind(aSkey, aLS);
	}
	}</code></td>
          <td>	<code>for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aSS2=aMS2(i);
	if (aMS1.Contains(aSS2)) {
	continue;
	}
	//
	if (!myOriginsDetected.IsBound(aSS2))
	myErrorStatus=30;
	return;
	}
	//
	const TopoDS_Shape& aSkey=myOriginsDe
	if (aDMSLS.IsBound(aSkey)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aSS2);
	}
	else {
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aSS2);
	aDMSLS.Bind(aSkey, aLS);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 430-442</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 506-520[109]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(countSubShapes(glueFaces(comp
	
	auto tp = fs::temp_directory_path() /
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(unifyFaces(loa
	// this test confirm that shared face
	tp = fs::temp_directory_path() / "_tm
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(loadShape(tp.s
	}
	
	SECTION("test_merge_boxes_in_a_line")
	{
	
	</code></td>
          <td>	<code>REQUIRE(countSubShapes(glueFaces(comp
	// REQUIRE(countSubShapes(unifyFaces(
	
	
	auto tp = fs::temp_directory_path() /
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(unifyFaces(loa
	// this test confirm that shared face
	tp = fs::temp_directory_path() / "_tm
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(loadShape(tp.s
	}
	
	SECTION("test_shape_distance")
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 346-370</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 372-396[108]</strong></td>
        </tr>
        <tr>
          <td>	<code>return ss;
	}
	
	
	TopoDS_Compound createCompound(const
	std::shared_ptr<const MapType<ItemHas
	{
	TopoDS_Builder cBuilder;
	TopoDS_Compound merged;
	cBuilder.MakeCompound(merged);
	size_t i = 0;
	for (const auto& item : theSolids)
	{
	if (suppressed)
	{
	bool itemSuppressed = (*suppressed).a
	if (not itemSuppressed)
	cBuilder.Add(merged, item.second);
	}
	else
	{
	cBuilder.Add(merged, item.second);
	}
	i++;
	}</code></td>
          <td>	<code>return merged;
	}
	
	TopoDS_CompSolid createCompSolid(cons
	std::shared_ptr<const MapType<ItemHas
	{
	TopoDS_Builder cBuilder;
	// TopoDS_Shape* merged;
	TopoDS_CompSolid merged;
	cBuilder.MakeCompSolid(merged);
	size_t i = 0;
	for (const auto& item : theSolids)
	{
	if (suppressed)
	{
	bool itemSuppressed = (*suppressed).a
	if (not itemSuppressed)
	cBuilder.Add(merged, item.second);
	}
	else
	{
	cBuilder.Add(merged, item.second);
	}
	i++;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 645-666</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 810-829[103]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aIt;
	TopTools_MapOfShape aMSX;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();
	//
	// 1.
	bHasOnF=myShapesOn.IsBound(aF1);
	const TopTools_MapOfShape& aMSOnF=(bH
	bFound=aMSOnF.Contains(aE2);
	if (bFound) {
	continue;
	}
	//
	// 2.
	bHasInF=myShapesIn.IsBound(aF1);</code></td>
          <td>	<code>Standard_Boolean bFound, bHasOnF;
	TopTools_MapOfShape aMSX;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_SOLID, T
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aSo1=aCS.Shape1()
	const TopoDS_Shape& aF2=aCS.Shape2();
	//
	bHasOnF=myShapesOn.IsBound(aSo1);
	const TopTools_MapOfShape& aMSOnF=(bH
	bFound=aMSOnF.Contains(aF2);
	if (bFound) {
	continue;
	}
	//------------------------------
	bFound=CheckCoincidence(aSo1, aF2);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 116-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 208-230[102]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPDS_DS* pDS=(BOPDS_DS*)&aDS;
	//
	const TopTools_ListOfShape& aLS=pDS->
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {
	myErrorStatus=14;
	return;
	}
	//
	iRank=-1;
	const TopoDS_Shape& aObj=aLS.First();
	if (aObj.ShapeType()==TopAbs_WIRE) {
	iRank=0;
	}
	const TopoDS_Shape& aTool=aLS.Last();
	if (aTool.ShapeType()==TopAbs_WIRE) {
	iRank=1;
	}
	//
	if (iRank==-1) {
	myErrorStatus=15;
	return;
	}</code></td>
          <td>	<code>BOPDS_DS* pDS=(BOPDS_DS*)&aDS;
	const TopTools_ListOfShape& aLS=pDS->
	//
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {
	myErrorStatus=13;
	return;
	}
	//
	iRank=-1;
	const TopoDS_Shape& aObj=aLS.First();
	if (aObj.ShapeType()==TopAbs_SHELL) {
	iRank=0;
	}
	const TopoDS_Shape& aTool=aLS.Last();
	if (aTool.ShapeType()==TopAbs_SHELL)
	iRank=1;
	}
	//
	if (iRank==-1) {
	myErrorStatus=14;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 86-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 85-141[101]</strong></td>
        </tr>
        <tr>
          <td>	<code>myIsAnalytic=Standard_True;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn::~GEOMAlgo_Finde
	{
	}
	//=====================================
	//function : SetSurface
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::SetSurface
	{
	mySurface=aS;
	}
	//=====================================
	//function : Surface
	//purpose :
	//=====================================
	const Handle(Geom_Surface)& GEOMAlgo_Fi
	{
	return mySurface;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::SetShapeTy
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::SetState(c
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn::
	{
	return myState;
	}</code></td>
          <td>	<code>myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn2::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetClsf
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetClsf(c
	{
	myClsf=aClsf;
	}
	//=====================================
	//function : Clsf
	//purpose :
	//=====================================
	const Handle(GEOMAlgo_Clsf)& GEOMAlgo_F
	{
	return myClsf;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn2:
	{
	return myState;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 107-118</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 375-387[99]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSkey=aItDMSLS.Ke
	const TopTools_ListOfShape& aLSD=aItD
	myImagesDetected.Bind(aSkey, aLSD);
	}
	//
	aItDMSLS.Initialize(myImagesDetected)
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke
	const TopTools_ListOfShape& aLSD=aItD
	aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSx=aItLS.Value()
	</code></td>
          <td>	<code>const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	myImages.Bind(aV, aLVSD);
	}
	//
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 90-129</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 88-127[99]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	GEOMAlgo_State State() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	const TopTools_ListOfShape& Shapes()
	
	Standard_EXPORT
	const GEOMAlgo_IndexedDataMapOfShapeS
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	const Standard_Integer aNbPnts,
	GEOMAlgo_ListOfPnt& aLP) ;</code></td>
          <td>	<code>Standard_EXPORT
	Standard_Integer NbPntsMax() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	const TopTools_ListOfShape& Shapes()
	
	Standard_EXPORT
	const GEOMAlgo_IndexedDataMapOfShapeS
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	const Standard_Integer aNbPnts,
	GEOMAlgo_ListOfPnt& aLP) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 375-401</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 467-493[96]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSt = GetPointState( aP );
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_EDGE) {
	if (bIsConformState) {
	myMSS.Add(aE, aSt);
	}
	}
	myMSS.Add(aE, aSt);
	}
	} // for (i=1; i<=aNb; ++i) next edge
	}
	//=====================================
	//function : ProcessFaces
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessFa
	{
	myErrorStatus=0;</code></td>
          <td>	<code>aSt = GetPointState( aP );
	bIsToBreak=aSC.AppendState(aSt);
	if (bIsToBreak) {
	break;
	}
	}
	//
	aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_FACE) {
	if (bIsConformState) {
	myMSS.Add(aF, aSt);
	}
	}
	myMSS.Add(aF, aSt);
	}
	}// for (i=1; i<=aNb; ++i) next face
	}
	//=====================================
	//function : ProcessSolids
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessSo
	{
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 536-554</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 634-656[95]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aKN==GEOMAlgo_KN_CYLINDER) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	else if (aKN==GEOMAlgo_KN_CONE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	else if (aKN==GEOMAlgo_KN_TORUS) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	}
	
	
	
	</code></td>
          <td>	<code>else if (aKN==GEOMAlgo_KN_CYLINDER) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	//
	// CONE
	else if (aKN==GEOMAlgo_KN_CONE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	//
	// TORUS
	else if (aKN==GEOMAlgo_KN_TORUS) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 663-666</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 667-670[94]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (xp.Init(aShape, TopAbs_FACE, Top
	this->myOtherShapes[xp.Current().Hash
	for (xp.Init(aShape, TopAbs_WIRE, Top
	this->myOtherShapes[xp.Current().Hash</code></td>
          <td>	<code>for (xp.Init(aShape, TopAbs_EDGE, Top
	this->myOtherShapes[xp.Current().Hash
	for (xp.Init(aShape, TopAbs_VERTEX, T
	this->myOtherShapes[xp.Current().Hash</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 89-127</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 91-129[94]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer NbPntsMax() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	const TopTools_ListOfShape& Shapes()
	
	Standard_EXPORT
	const GEOMAlgo_IndexedDataMapOfShapeS
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	const Standard_Integer aNbPnts,
	GEOMAlgo_ListOfPnt& aLP) ;</code></td>
          <td>	<code>GEOMAlgo_State State() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	const TopTools_ListOfShape& Shapes()
	
	Standard_EXPORT
	const GEOMAlgo_IndexedDataMapOfShapeS
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	const Standard_Integer aNbPnts,
	GEOMAlgo_ListOfPnt& aLP) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 91-101</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 103-113[93]</strong></td>
        </tr>
        <tr>
          <td>	<code>try
	{
	BRepPrimAPI_MakeBox aBoxMaker(gp_Pnt(
	for (TopExp_Explorer i(aBoxMaker.Shap
	{
	aBuilder.Add(aCompound, i.Current());
	}
	}
	catch (Standard_Failure f)
	{
	}</code></td>
          <td>	<code>try
	{
	BRepPrimAPI_MakeBox aBoxMaker(gp_Pnt(
	for (TopExp_Explorer i(aBoxMaker.Shap
	{
	aBuilder.Add(aCompound, i.Current());
	}
	}
	catch (Standard_Failure f)
	{
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 694-713</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 799-818[93]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bInf1, bInf2;
	Standard_Integer j, aNbT;
	Standard_Real dT, aT, aT1, aT2;
	gp_Pnt aP;
	Handle(Geom_Curve) aC3D;
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	if (aC3D.IsNull()) {
	return;
	}
	//
	bInf1=Precision::IsNegativeInfinite(a
	bInf2=Precision::IsPositiveInfinite(a
	return;
	}
	//
	aNbT=aNbPntsMin+1;
	dT=(aT2-aT1)/aNbT;
	for (j=1; j<aNbT; ++j) {</code></td>
          <td>	<code>Standard_Boolean bInf1, bInf2;
	Standard_Integer j, aNbT;
	Standard_Real dT, aT, aT1, aT2;
	gp_Pnt aP;
	Handle(Geom_Curve) aC3D;
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	if (aC3D.IsNull()) {
	return;
	}
	//
	bInf1=Precision::IsNegativeInfinite(a
	bInf2=Precision::IsPositiveInfinite(a
	return;
	}
	//
	aNbT=myNbPntsMin+1;
	dT=(aT2-aT1)/aNbT;
	for (j=1; j<=aNbPntsMin; ++j) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 724-750</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 463-489[92]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_FinderShapeOn1::CheckData
	{
	myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed subsha
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn::CheckData(
	{
	myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed sub-sh
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 107-112</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 240-242[90]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Solid box1 = BRepPrimAPI_MakeB
	// face contact
	// TopoDS_Solid box2 = BRepPrimAPI_Ma
	// edge contact, share the z-axis edg
	TopoDS_Solid box2 = BRepPrimAPI_MakeB
	std::vector<TopoDS_Shape> shapes = {b</code></td>
          <td>	<code>TopoDS_Solid box2 = BRepPrimAPI_MakeB
	TopoDS_Solid box3 = BRepPrimAPI_MakeB
	std::vector<TopoDS_Shape> shapes = {b
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 70-82</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 97-110[90]</strong></td>
        </tr>
        <tr>
          <td>	<code>Vertex = TopAbs_VERTEX
	};
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeTyp
	{ShapeType::Shape, "Shape"},
	{ShapeType::Compound, "Compound"},
	{ShapeType::CompSolid, "CompSolid"},
	{ShapeType::Solid, "Solid"},
	{ShapeType::Shell, "Shell"},
	{ShapeType::Wire, "Wire"},
	{ShapeType::Face, "Face"},
	{ShapeType::Edge, "Edge"},
	{ShapeType::Vertex, "Vertex"},
	});
	</code></td>
          <td>	<code>TessellationError = 512 ///< failed t
	};
	// then CollisionInfo can be implicit
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeErr
	{ShapeErrorType::NoError, "NoError"},
	{ShapeErrorType::VolumeTooSmall, "Vol
	{ShapeErrorType::ItemInvisible, "Item
	{ShapeErrorType::BOPCheckFailed, "BOP
	{ShapeErrorType::Interference, "Inter
	{ShapeErrorType::Coincidence, "Coinci
	{ShapeErrorType::Enclosure, "Enclosur
	{ShapeErrorType::UnknownError, "Unkno
	{ShapeErrorType::TessellationError, "
	});</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 376-387</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 108-118[89]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLVSD=aIt
	myImages.Bind(aV, aLVSD);
	}
	//
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSD=aItD
	myImagesDetected.Bind(aSkey, aLSD);
	}
	//
	aItDMSLS.Initialize(myImagesDetected)
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke
	const TopTools_ListOfShape& aLSD=aItD
	aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSx=aItLS.Value()
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 190-215</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 879-904[89]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : MakeEdge
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::MakeEdge(const To
	TopoDS_Edge& aNewEdge)
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsDE;
	Standard_Real aT1, aT2;
	TopoDS_Vertex aV1, aV2, aVR1, aVR2;
	TopoDS_Edge aEx;
	//
	bIsDE=BRep_Tool::Degenerated(aE);
	//
	aEx=aE;
	aEx.Orientation(TopAbs_FORWARD);
	//
	TopExp::Vertices(aEx, aV1, aV2);
	//
	aT1=BRep_Tool::Parameter(aV1, aEx);
	aT2=BRep_Tool::Parameter(aV2, aEx);
	//
	aVR1=aV1;</code></td>
          <td>	<code>}
	//=====================================
	//function : MakeEdge
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeEdge(const Top
	TopoDS_Edge& aNewEdge)
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsDE;
	Standard_Real aT1, aT2;
	TopoDS_Vertex aV1, aV2, aVR1, aVR2;
	TopoDS_Edge aEx;
	//
	bIsDE=BRep_Tool::Degenerated(aE);
	//
	aEx=aE;
	aEx.Orientation(TopAbs_FORWARD);
	//
	TopExp::Vertices(aEx, aV1, aV2);
	//
	aT1=BRep_Tool::Parameter(aV1, aEx);
	aT2=BRep_Tool::Parameter(aV2, aEx);
	//
	aVR1=TopoDS::Vertex(myOrigins.Find(aV</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 731-746</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 746-760[88]</strong></td>
        </tr>
        <tr>
          <td>	<code>DumpDirection(myDirection);
	}
	else if (aKN==GEOMAlgo_KN_SEGMENT) {
	DumpLocation (myLocation);
	DumpDirection(myDirection);
	printf(" Length : %.3lf\n", myLength)
	myPnt1.Coord(aX, aY, aZ);
	printf(" Pnt1 : %.3lf %.3lf %.3lf\n",
	myPnt2.Coord(aX, aY, aZ);
	printf(" Pnt2 : %.3lf %.3lf %.3lf\n",
	
	}
	else if (aKN==GEOMAlgo_KN_CIRCLE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius</code></td>
          <td>	<code>printf(" Radius1 : %.3lf\n", myRadius
	}
	else if (aKN==GEOMAlgo_KN_ARCCIRCLE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	myPnt1.Coord(aX, aY, aZ);
	printf(" Pnt1 : %.3lf %.3lf %.3lf\n",
	myPnt2.Coord(aX, aY, aZ);
	printf(" Pnt2 : %.3lf %.3lf %.3lf\n",
	}
	else if (aKN==GEOMAlgo_KN_ELLIPSE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 248-273</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 833-858[87]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : MakeVertex
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::MakeVertex(const
	TopoDS_Vertex& aNewVertex)
	{
	Standard_Integer aNbV;
	Standard_Real aTolV, aD, aDmax;
	gp_XYZ aGC;
	gp_Pnt aP3D, aPGC;
	TopoDS_Vertex aVx;
	BRep_Builder aBB;
	TopTools_ListIteratorOfListOfShape aI
	//
	aNbV=aLV.Extent();
	if (!aNbV) {
	return;
	}
	//
	// center of gravity
	aGC.SetCoord(0.,0.,0.);
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=*((TopoDS_Vertex*)(&aIt.Value()))</code></td>
          <td>	<code>}
	//=====================================
	//function : MakeVertex
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeVertex(const T
	TopoDS_Vertex& aNewVertex)
	{
	Standard_Integer aNbV;
	Standard_Real aTolV, aD, aDmax;
	gp_XYZ aGC;
	gp_Pnt aP3D, aPGC;
	TopoDS_Vertex aVx;
	BRep_Builder aBB;
	TopTools_ListIteratorOfListOfShape aI
	//
	aNbV=aLV.Extent();
	if (!aNbV) {
	return;
	}
	//
	// center of gravity
	aGC.SetCoord(0.,0.,0.);
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=TopoDS::Vertex(aIt.Value());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 397-411</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 432-446[86]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRepTools::UVBounds(aF, aUMin, aUMax,
	bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(
	bInfV2=Precision::IsPositiveInfinite(
	//
	if (bInf) {
	aInfo.SetKindOfBounds(GEOMAlgo_KB_INF
	return;
	}
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	//
	dV=aVMax-aVMin;</code></td>
          <td>	<code>BRepTools::UVBounds(aF, aUMin, aUMax,
	bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(
	bInfV2=Precision::IsPositiveInfinite(
	//
	if (bInf) {
	aInfo.SetKindOfBounds(GEOMAlgo_KB_INF
	return;
	}
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	//
	aSemiAngle=fabs(aCone.SemiAngle());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 329-345</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 455-471[84]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean isGood = Standard_Fa
	
	TDF_LabelSequence aLabelSeq;
	theWhereFunction->GetDependency(aLabe
	Standard_Integer nbArg = aLabelSeq.Le
	
	for (Standard_Integer iarg = 1; iarg
	
	TDF_Label anArgumentRefLabel = aLabel
	
	Handle(GEOM_Object) anArgumentObject
	TopoDS_Shape anArgumentShape = anArgu
	
	TopTools_IndexedMapOfShape anArgument
	TopExp::MapShapes(anArgumentShape, an
	
	if (anArgumentIndices.Contains(theWha</code></td>
          <td>	<code>Standard_Boolean isFound = Standard_F
	
	TDF_LabelSequence aLabelSeq;
	theWhereFunction->GetDependency(aLabe
	Standard_Integer nbArg = aLabelSeq.Le
	
	for (Standard_Integer iarg = 1; iarg
	{
	TDF_Label anArgumentRefLabel = aLabel
	
	Handle(GEOM_Object) anArgumentObject
	TopoDS_Shape anArgumentShape = anArgu
	
	TopTools_IndexedMapOfShape anArgument
	TopExp::MapShapes(anArgumentShape, an
	
	if (( isFound = anArgumentIndices.Con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 288-336</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 50-99[84]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetPnt2(const
	{
	myPnt2=aP;
	}
	//=====================================
	//function : Pnt2
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Pnt2(
	{
	return myPnt2;
	}
	//=====================================
	//function : SetRadius1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius1(con
	{
	myRadius1=aR;
	}
	//=====================================
	//function : Radius1
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius1;
	}
	//=====================================
	//function : SetRadius2
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius2(con
	{
	myRadius2=aR;
	}
	//=====================================
	//function : Radius2
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius2;
	}
	//=====================================
	//function : SetLength
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetLength(cons
	</code></td>
          <td>	<code>void GEOMAlgo_GluerAlgo::SetArgument(co
	{
	myArgument=theShape;
	}
	//=====================================
	//function : Argument
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_GluerAlgo:
	{
	return myArgument;
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetTolerance(c
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GluerAlgo::Toler
	{
	return myTolerance;
	}
	
	//=====================================
	//function : SetCheckGeometry
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetCheckGeomet
	{
	myCheckGeometry=aFlag;
	}
	//=====================================
	//function : CheckGeometry
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_GluerAlgo::Ch
	{
	return myCheckGeometry;
	}
	//=====================================
	//function : SetContext
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetContext(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 81-131</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 112-162[83]</strong></td>
        </tr>
        <tr>
          <td>	<code>myTolCG=0.0001;
	myFound=Standard_False;
	myCheckGeometry=Standard_True;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlace::~GEOMAlgo_GetInPla
	{
	}
	//=====================================
	//function : SetTolMass
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::SetTolMass(co
	{
	myTolMass=theTol;
	}
	//=====================================
	//function : TolMass
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GetInPlace::TolM
	{
	return myTolMass;
	}
	//=====================================
	//function : SetTolCG
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::SetTolCG(cons
	{
	myTolCG=theTol;
	}
	//=====================================
	//function : TolCG
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GetInPlace::TolC
	{
	return myTolCG;
	}
	//=====================================
	//function : IsFound
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_GetInPlace::I
	{
	return myFound;
	}</code></td>
          <td>	<code>myCheckGeometry=Standard_True;
	myKeepNonSolids=Standard_False;
	myNbAlone=0;
	}
	//=====================================
	//function : ~GEOMAlgo_Gluer
	//purpose :
	//=====================================
	GEOMAlgo_Gluer::~GEOMAlgo_Gluer()
	{
	}
	//=====================================
	//function : SetCheckGeometry
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::SetCheckGeometry(c
	{
	myCheckGeometry=aFlag;
	}
	//=====================================
	//function : CheckGeometry
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::CheckG
	{
	return myCheckGeometry;
	}
	//=====================================
	//function : SetKeepNonSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::SetKeepNonSolids(c
	{
	myKeepNonSolids=aFlag;
	}
	//=====================================
	//function : KeepNonSolids
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::KeepNo
	{
	return myKeepNonSolids;
	}
	//=====================================
	//function : AloneShapes
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_Gluer::AloneS
	{
	return myNbAlone;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.hxx: line 25-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BoxBndTree.hxx: line 28-56[83]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef GEOMAlgo_BndSphereTree_HeaderFi
	#define GEOMAlgo_BndSphereTree_HeaderFi
	
	#include <NCollection_UBTree.hxx>
	#include <GEOMAlgo_BndSphere.hxx>
	#include <TColStd_MapOfInteger.hxx>
	#include <TColStd_ListOfInteger.hxx>
	
	typedef NCollection_UBTree <Standard_In
	
	class GEOMAlgo_BndSphereTreeSelector
	public:
	Standard_EXPORT GEOMAlgo_BndSphereTre
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual ~GEOMAlgo_Bnd
	
	Standard_EXPORT void Clear();
	Standard_EXPORT void SetBox(const GEO
	Standard_EXPORT const TColStd_ListOfI
	
	protected:
	GEOMAlgo_BndSphere myBox;
	TColStd_MapOfInteger myFence;
	TColStd_ListOfInteger myIndices;
	
	};
	
	#endif</code></td>
          <td>	<code>#ifndef GEOMAlgo_BoxBndTree_HeaderFile
	#define GEOMAlgo_BoxBndTree_HeaderFile
	
	#include <NCollection_UBTree.hxx>
	#include <Bnd_Box.hxx>
	#include <TColStd_MapOfInteger.hxx>
	#include <TColStd_ListOfInteger.hxx>
	
	typedef NCollection_UBTree <Standard_In
	
	class GEOMAlgo_BoxBndTreeSelector : p
	public:
	Standard_EXPORT GEOMAlgo_BoxBndTreeSe
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual ~GEOMAlgo_Box
	
	Standard_EXPORT void Clear();
	Standard_EXPORT void SetBox(const Bnd
	Standard_EXPORT const TColStd_ListOfI
	
	protected:
	Bnd_Box myBox;
	TColStd_MapOfInteger myFence;
	TColStd_ListOfInteger myIndices;
	
	};
	
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BoxBndTree.hxx: line 28-56</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.hxx: line 25-53[83]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef GEOMAlgo_BoxBndTree_HeaderFile
	#define GEOMAlgo_BoxBndTree_HeaderFile
	
	#include <NCollection_UBTree.hxx>
	#include <Bnd_Box.hxx>
	#include <TColStd_MapOfInteger.hxx>
	#include <TColStd_ListOfInteger.hxx>
	
	typedef NCollection_UBTree <Standard_In
	
	class GEOMAlgo_BoxBndTreeSelector : p
	public:
	Standard_EXPORT GEOMAlgo_BoxBndTreeSe
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual ~GEOMAlgo_Box
	
	Standard_EXPORT void Clear();
	Standard_EXPORT void SetBox(const Bnd
	Standard_EXPORT const TColStd_ListOfI
	
	protected:
	Bnd_Box myBox;
	TColStd_MapOfInteger myFence;
	TColStd_ListOfInteger myIndices;
	
	};
	
	#endif</code></td>
          <td>	<code>#ifndef GEOMAlgo_BndSphereTree_HeaderFi
	#define GEOMAlgo_BndSphereTree_HeaderFi
	
	#include <NCollection_UBTree.hxx>
	#include <GEOMAlgo_BndSphere.hxx>
	#include <TColStd_MapOfInteger.hxx>
	#include <TColStd_ListOfInteger.hxx>
	
	typedef NCollection_UBTree <Standard_In
	
	class GEOMAlgo_BndSphereTreeSelector
	public:
	Standard_EXPORT GEOMAlgo_BndSphereTre
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual Standard_Bool
	Standard_EXPORT virtual ~GEOMAlgo_Bnd
	
	Standard_EXPORT void Clear();
	Standard_EXPORT void SetBox(const GEO
	Standard_EXPORT const TColStd_ListOfI
	
	protected:
	GEOMAlgo_BndSphere myBox;
	TColStd_MapOfInteger myFence;
	TColStd_ListOfInteger myIndices;
	
	};
	
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 630-640</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 640-650[81]</strong></td>
        </tr>
        <tr>
          <td>	<code>});
	}
	
	bool CollisionDetector::isAllTypeExce
	const ItemIndexType exception)
	{
	const auto& row = myCollisionInfos[i]
	return std::all_of(row.cbegin(), row.
	const CollisionInfo& info = p.second;</code></td>
          <td>	<code>});
	}
	
	bool CollisionDetector::isNotTypeExce
	const ItemIndexType exception)
	{
	const auto& row = myCollisionInfos[i]
	return std::all_of(row.cbegin(), row.
	const CollisionInfo& info = p.second;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 425-433</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 244-251[81]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt.Initialize(aE1);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV1=aIt.Value();
	if (myShapesOn.IsBound(aV1)) {
	const TopTools_MapOfShape& aMSOn=mySh
	//aNbSOn=aMSOn.Extent();
	aItMS.Initialize(aMSOn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aV2=aItMS.Key();</code></td>
          <td>	<code>aIt.Initialize(aLSP);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();
	if (myImages.IsBound(aS)) {
	const TopTools_ListOfShape& aLSIm=myI
	aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 291-306</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 362-378  [81]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> const T attribu
	{
	if (myCharacteristics.contains(name))
	{
	json& a = myCharacteristics[name];
	if (a.contains("value"))
	{
	return a["value"].get<T>(); // parame
	}
	else
	{
	return a.get<T>();
	}
	}
	else
	{
	</code></td>
          <td>	<code>template <typename T> const T paramet
	{
	// unit conversion may be necessary l
	if (myConfig.contains(name))
	{
	json& a = myConfig[name];
	if (a.contains("value"))
	{
	return a["value"].get<T>(); /// param
	}
	else
	{
	return a.get<T>(); /// key-value pair
	}
	}
	else
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 22-24</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 17-19[80]</strong></td>
        </tr>
        <tr>
          <td>	<code># Suite 330, Boston, MA 02111-1307, USA
	# #
	#######################################</code></td>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 52-99</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 290-336[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>myArgument=theShape;
	}
	//=====================================
	//function : Argument
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_GluerAlgo:
	{
	return myArgument;
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetTolerance(c
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GluerAlgo::Toler
	{
	return myTolerance;
	}
	
	//=====================================
	//function : SetCheckGeometry
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetCheckGeomet
	{
	myCheckGeometry=aFlag;
	}
	//=====================================
	//function : CheckGeometry
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_GluerAlgo::Ch
	{
	return myCheckGeometry;
	}
	//=====================================
	//function : SetContext
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetContext(con</code></td>
          <td>	<code>myPnt2=aP;
	}
	//=====================================
	//function : Pnt2
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Pnt2(
	{
	return myPnt2;
	}
	//=====================================
	//function : SetRadius1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius1(con
	{
	myRadius1=aR;
	}
	//=====================================
	//function : Radius1
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius1;
	}
	//=====================================
	//function : SetRadius2
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius2(con
	{
	myRadius2=aR;
	}
	//=====================================
	//function : Radius2
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Radiu
	{
	return myRadius2;
	}
	//=====================================
	//function : SetLength
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetLength(cons
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 35-50</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 56-71[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_FinderShapeOnQuad::GEOMAlgo_Fi
	const gp_Pnt & theTopRightPoint,
	const gp_Pnt & theBottomLeftPoint,
	const gp_Pnt & theBottomRightPoint)
	{
	myPoints.resize(6);
	myPoints[0] = theTopLeftPoint ;
	myPoints[1] = theTopRightPoint ;
	myPoints[2] = theBottomRightPoint;
	myPoints[3] = theBottomLeftPoint ;
	myPoints[4] = myPoints[0];
	myPoints[5] = myPoints[1];
	
	// Find plane normal defined by corne
	// for each quadrangle side.
	myQuadNormal.SetCoord (0,0,0);</code></td>
          <td>	<code>void GEOMAlgo_ClsfQuad::SetCorners(cons
	const gp_Pnt &theTopRightPoint,
	const gp_Pnt &theBottomLeftPoint,
	const gp_Pnt &theBottomRightPoint)
	{
	myPoints.resize(6);
	myPoints[0] = theTopLeftPoint;
	myPoints[1] = theTopRightPoint;
	myPoints[2] = theBottomRightPoint;
	myPoints[3] = theBottomLeftPoint;
	myPoints[4] = myPoints[0];
	myPoints[5] = myPoints[1];
	
	// Find plane normal defined by corne
	// a plane for each quadrangle side.
	myQuadNormal.SetCoord (0., 0., 0.);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 38-64</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 109-135[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_DataMapOfShapePnt.hxx
	GEOMAlgo_Extractor.hxx
	GEOMAlgo_FinderShapeOn.hxx
	GEOMAlgo_FinderShapeOn1.hxx
	GEOMAlgo_FinderShapeOn2.hxx
	GEOMAlgo_FinderShapeOnQuad.hxx
	GEOMAlgo_GetInPlace.hxx
	GEOMAlgo_GetInPlaceAPI.hxx
	GEOMAlgo_GlueAnalyser.hxx
	GEOMAlgo_GlueDetector.hxx
	GEOMAlgo_Gluer.hxx
	GEOMAlgo_Gluer2.hxx
	GEOMAlgo_GluerAlgo.hxx
	GEOMAlgo_HAlgo.hxx
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	GEOMAlgo_IndexedDataMapOfShapeBox.hxx
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	GEOMAlgo_IndexedDataMapOfShapeShapeIn
	GEOMAlgo_IndexedDataMapOfShapeState.h
	GEOMAlgo_KindOfBounds.hxx
	GEOMAlgo_KindOfClosed.hxx
	GEOMAlgo_KindOfDef.hxx
	GEOMAlgo_KindOfName.hxx
	GEOMAlgo_KindOfShape.hxx
	GEOMAlgo_ListIteratorOfListOfCoupleOf</code></td>
          <td>	<code>#GEOMAlgo_GetInPlaceAPI.cxx
	GEOMAlgo_GlueAnalyser.cxx
	GEOMAlgo_GlueDetector.cxx
	GEOMAlgo_Gluer.cxx
	GEOMAlgo_Gluer2.cxx
	GEOMAlgo_Gluer2_1.cxx
	GEOMAlgo_Gluer2_2.cxx
	GEOMAlgo_Gluer2_3.cxx
	GEOMAlgo_GluerAlgo.cxx
	GEOMAlgo_HAlgo.cxx
	GEOMAlgo_PassKey.cxx
	GEOMAlgo_PassKeyMapHasher.cxx
	GEOMAlgo_PassKeyShape.cxx
	GEOMAlgo_PassKeyShapeMapHasher.cxx
	GEOMAlgo_RemoverWebs.cxx
	GEOMAlgo_ShapeAlgo.cxx
	GEOMAlgo_ShapeInfo.cxx
	GEOMAlgo_ShapeInfoFiller.cxx
	GEOMAlgo_ShapeInfoFiller_1.cxx
	GEOMAlgo_ShapeSolid.cxx
	GEOMAlgo_ShellSolid.cxx
	GEOMAlgo_SolidSolid.cxx
	GEOMAlgo_Splitter.cxx
	GEOMAlgo_StateCollector.cxx
	GEOMAlgo_SurfaceTools.cxx
	GEOMAlgo_VertexSolid.cxx
	GEOMAlgo_WireSolid.cxx</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 280-302</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 382-404[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSt = GetPointState( aP );
	bIsConformState=GEOMAlgo_SurfaceTools
	//
	if (myShapeType==TopAbs_VERTEX){
	if (bIsConformState) {
	myMSS.Add(aV, aSt);
	}
	}
	myMSS.Add(aV, aSt);
	}
	}
	}
	//=====================================
	//function : ProcessEdges
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessEd
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState, bIs
	Standard_Integer i, aNb, iCnt;</code></td>
          <td>	<code>aSt=aSC.State();
	//
	bIsConformState=GEOMAlgo_SurfaceTools
	if (myShapeType==TopAbs_EDGE) {
	if (bIsConformState) {
	myMSS.Add(aE, aSt);
	}
	}
	myMSS.Add(aE, aSt);
	}
	} // for (i=1; i<=aNb; ++i) next edge
	}
	//=====================================
	//function : ProcessFaces
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessFa
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState, bIs
	Standard_Integer i, aNbF, iCnt;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 242-242</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 22-24[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	
	</code></td>
          <td>	<code># Suite 330, Boston, MA 02111-1307, USA
	# #
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 395-405</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 406-416[78]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (mapShape.Add(anIt.Value())) {
	TopoDS_Shape curWhat = anIt.Value();
	isFoundAny = GetInPlaceByHistory(theW
	if (isFoundAny) isFound = Standard_Tr
	}
	}
	}
	else if (theWhat.ShapeType() == TopAb
	// try to replace a shell by its face
	TopExp_Explorer anExp (theWhat, TopAb
	for (; anExp.More(); anExp.Next()) {</code></td>
          <td>	<code>if (mapShape.Add(anExp.Current())) {
	TopoDS_Shape curWhat = anExp.Current(
	isFoundAny = GetInPlaceByHistory(theW
	if (isFoundAny) isFound = Standard_Tr
	}
	}
	}
	else if (theWhat.ShapeType() == TopAb
	// try to replace a wire by its edges
	TopExp_Explorer anExp (theWhat, TopAb
	for (; anExp.More(); anExp.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 154-157</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 166-169[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto ctype = CollisionDetector::calcC
	std::cout << "Result V, S, L = " << v
	<< perimeter(mkGFA->Shape()) << std::
	REQUIRE(floatEqual(area(mkGFA->Shape(</code></td>
          <td>	<code>ctype = CollisionDetector::calcCollis
	std::cout << "Result V, S, L = " << v
	<< perimeter(mkGFA->Shape()) << std::
	REQUIRE(floatEqual(perimeter(mkGFA->S</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 135-156</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 136-157[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS4)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);
	aLS.Append(aS3);
	aLS.Append(aS4);
	SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes
	{
	Standard_Integer i, aId, aIdN;
	TopTools_ListIteratorOfListOfShape aI
	//
	Clear();
	aIt.Initialize(aLS);
	for (; aIt.More(); aIt.Next()) {</code></td>
          <td>	<code>const Standard_Integer aId4)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);
	aLI.Append(aId4);
	SetIds(aLI);
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const T
	{
	Standard_Integer i, aId, aIdN;
	TColStd_ListIteratorOfListOfInteger a
	//
	Clear();
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 136-157</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 135-156[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Integer aId4)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);
	aLI.Append(aId4);
	SetIds(aLI);
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const T
	{
	Standard_Integer i, aId, aIdN;
	TColStd_ListIteratorOfListOfInteger a
	//
	Clear();
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {</code></td>
          <td>	<code>const TopoDS_Shape& aS4)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);
	aLS.Append(aS3);
	aLS.Append(aS4);
	SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes
	{
	Standard_Integer i, aId, aIdN;
	TopTools_ListIteratorOfListOfShape aI
	//
	Clear();
	aIt.Initialize(aLS);
	for (; aIt.More(); aIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 452-469</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 651-667[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	// 5. Torus
	else if (aST==GeomAbs_Torus) {
	gp_Torus aTorus;
	//
	aTorus=aGAS.Torus();
	aP0=aTorus.Location();
	aAx3=aTorus.Position();
	aR1=aTorus.MajorRadius();
	aR2=aTorus.MinorRadius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_TORU
	aInfo.SetKindOfName(GEOMAlgo_KN_TORUS
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
          <td>	<code>}// else if (aCT==GeomAbs_Circle) {
	//
	else if (aCT==GeomAbs_Ellipse) {
	gp_Elips aElips;
	//
	aElips=aGAC.Ellipse();
	aP=aElips.Location();
	aAx2=aElips.Position();
	aR1=aElips.MajorRadius();
	aR2=aElips.MinorRadius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_ELLI
	aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	aInfo.SetRadius2(aR2);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 360-378</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 476-493[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>bIsConformState=Standard_False;
	//
	aExp.Init(aE, TopAbs_VERTEX);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aV=aExp.Current()
	//
	bIsConformState=myMSS.Contains(aV);
	if (!bIsConformState) {
	break;// vertex has non-conformed sta
	}
	else {
	aSt=myMSS.FindFromKey(aV);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // vertex has non-conformed
	}</code></td>
          <td>	<code>bIsConformState=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aE=aExp.Current()
	bIsConformState=myMSS.Contains(aE);
	if (!bIsConformState) {
	break;// edge has non-conformed state
	}
	else {
	aSt=myMSS.FindFromKey(aE);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // edge has non-conformed s
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 383-402</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 470-489[77]</strong></td>
        </tr>
        <tr>
          <td>	<code>myIterator.AppendPair(aCS);
	}
	}
	}
	//=====================================
	//function : PerformVV
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformVV()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_VERTEX,
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aV1=aCS.Shape1();
	const TopoDS_Shape& aV2=aCS.Shape2();
	//
	FillShapesOn(aV1, aV2);</code></td>
          <td>	<code>FillShapesIn(aE1, aV2);
	}
	}
	}
	//=====================================
	//function : PerformEE
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformEE()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_EDGE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aE1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();
	
	PerformEE(aE1, aE2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ParallelAccessor.h: line 164-178</strong></td>
        <td style="text-align:center"><strong>src/PPP/AsynchronousDispatcher.h: line 88-102[76]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto it = myRemainedItems.cbegin();
	const auto& iend = myRemainedItems.ce
	for (ItemIndexType i = 0; i < myBatch
	{
	while (it != iend && isLocked(*it)) /
	{
	it++;
	}
	if (it != iend)
	{
	tmp.push_back(*it);
	lockItem(*it);
	it++;
	}
	}</code></td>
          <td>	<code>auto it = myRemainedItems.cbegin();
	const auto& iend = myRemainedItems.ce
	for (ItemIndexType i = 0; i < nProduc
	{
	while (it != iend && isLocked(*it))
	{
	it++;
	}
	if (it != iend)
	{
	myQueue.push(*it);
	lockItem(*it);
	it++;
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 70-103</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 133-166[76]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer NbSubShapes(const To
	
	Standard_EXPORT
	void SetKindOfShape(const GEOMAlgo_Ki
	
	Standard_EXPORT
	GEOMAlgo_KindOfShape KindOfShape() co
	
	Standard_EXPORT
	void SetKindOfName(const GEOMAlgo_Kin
	
	Standard_EXPORT
	GEOMAlgo_KindOfName KindOfName() cons
	
	Standard_EXPORT
	void SetKindOfBounds(const GEOMAlgo_K
	
	Standard_EXPORT
	GEOMAlgo_KindOfBounds KindOfBounds()
	
	Standard_EXPORT
	void SetKindOfClosed(const GEOMAlgo_K
	
	Standard_EXPORT
	GEOMAlgo_KindOfClosed KindOfClosed()
	
	Standard_EXPORT
	void SetKindOfDef(const GEOMAlgo_Kind
	
	Standard_EXPORT
	GEOMAlgo_KindOfDef KindOfDef() const;
	
	Standard_EXPORT
	void SetLocation(const gp_Pnt& aP) ;</code></td>
          <td>	<code>const gp_Pnt& Pnt2() const;
	
	Standard_EXPORT
	void SetRadius1(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius1() const;
	
	Standard_EXPORT
	void SetRadius2(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius2() const;
	
	Standard_EXPORT
	void SetLength(const Standard_Real aL
	
	Standard_EXPORT
	Standard_Real Length() const;
	
	Standard_EXPORT
	void SetWidth(const Standard_Real aW)
	
	Standard_EXPORT
	Standard_Real Width() const;
	
	Standard_EXPORT
	void SetHeight(const Standard_Real aH
	
	Standard_EXPORT
	Standard_Real Height() const;
	
	Standard_EXPORT
	void Dump() const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 404-410</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 454-460[76]</strong></td>
        </tr>
        <tr>
          <td>	<code>aXYZc.SetCoord(0.,0.,0.);
	TopExp::MapShapes(aF, TopAbs_VERTEX,
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);
	const gp_XYZ& aXYZ=aP.XYZ();
	aXYZc=aXYZc+aXYZ;</code></td>
          <td>	<code>aXYZc.SetCoord(0.,0.,0.);
	TopExp::MapShapes(aF, TopAbs_VERTEX,
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);
	const gp_XYZ& aXYZ=aP.XYZ();
	aXYZc=aXYZc+aXYZ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/AsynchronousDispatcher.h: line 88-102</strong></td>
        <td style="text-align:center"><strong>src/PPP/ParallelAccessor.h: line 164-178[76]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto it = myRemainedItems.cbegin();
	const auto& iend = myRemainedItems.ce
	for (ItemIndexType i = 0; i < nProduc
	{
	while (it != iend && isLocked(*it))
	{
	it++;
	}
	if (it != iend)
	{
	myQueue.push(*it);
	lockItem(*it);
	it++;
	}
	}</code></td>
          <td>	<code>auto it = myRemainedItems.cbegin();
	const auto& iend = myRemainedItems.ce
	for (ItemIndexType i = 0; i < myBatch
	{
	while (it != iend && isLocked(*it)) /
	{
	it++;
	}
	if (it != iend)
	{
	tmp.push_back(*it);
	lockItem(*it);
	it++;
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 356-373</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 378-395[76]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillDetails(aF, aPln);
	}// if (aCT==GeomAbs_Line) {
	//
	// 2. Sphere
	else if (aST==GeomAbs_Sphere) {
	gp_Sphere aSphere;
	//
	aSphere=aGAS.Sphere();
	aP0=aSphere.Location();
	aAx3=aSphere.Position();
	aR1=aSphere.Radius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_SPHE
	aInfo.SetKindOfName(GEOMAlgo_KN_SPHER
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
          <td>	<code>FillDetails(aF, aSphere);
	}// else if (aST==GeomAbs_Sphere) {
	//
	// 3. Cylinder
	else if (aST==GeomAbs_Cylinder) {
	gp_Cylinder aCyl;
	//
	aCyl=aGAS.Cylinder();
	aP0=aCyl.Location();
	aAx3=aCyl.Position();
	aR1=aCyl.Radius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_CYLI
	aInfo.SetKindOfName(GEOMAlgo_KN_CYLIN
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 336-379</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 114-157[75]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetLength(cons
	{
	myLength=aL;
	}
	//=====================================
	//function : Length
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Lengt
	{
	return myLength;
	}
	//=====================================
	//function : SetWidth
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetWidth(const
	{
	myWidth=aW;
	}
	//=====================================
	//function : Width
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Width
	{
	return myWidth;
	}
	//=====================================
	//function : SetHeight
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetHeight(cons
	{
	myHeight=aH;
	}
	//=====================================
	//function : Height
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfo::Heigh
	{
	return myHeight;
	}</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn2::SetShapeT
	{
	myShapeType=aType;
	}
	//=====================================
	//function : ShapeType
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_FinderShapeOn
	{
	return myShapeType;
	}
	//=====================================
	//function : SetState
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetState(
	{
	myState=aState;
	}
	//=====================================
	//function : State
	//purpose :
	//=====================================
	GEOMAlgo_State GEOMAlgo_FinderShapeOn2:
	{
	return myState;
	}
	//=====================================
	//function : SetNbPntsMin
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMin=aNb;
	}
	//=====================================
	//function : NbPntsMin
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMin;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 475-483</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 485-493[75]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (int i = 0; i < Nboxes; i += batc
	{
	std::vector<TopoDS_Shape> ss;
	for (int j = 0; j < batchSize; j++)
	ss.push_back(shapes[i + j]);
	auto res = generalFuse(ss, tolerance,
	for (int j = 0; j < batchSize; j++)
	shapes[i + j] = res[j];
	}</code></td>
          <td>	<code>for (int i = 1; i < Nboxes - batchSiz
	{
	std::vector<TopoDS_Shape> ss;
	for (int j = 0; j < batchSize; j++)
	ss.push_back(shapes[i + j]);
	auto res = generalFuse(ss, tolerance,
	for (int j = 0; j < batchSize; j++)
	shapes[i + j] = res[j];
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 4-4</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 22-24[75]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	
	</code></td>
          <td>	<code># Suite 330, Boston, MA 02111-1307, USA
	# #
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 93-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 53-99[75]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : Tools
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Sp
	{
	return myTools;
	}
	//=====================================
	//function : SetLimit
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::SetLimit(const
	{
	myLimit=aLimit;
	}
	//=====================================
	//function : Limit
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_Splitter::Lim
	{
	return myLimit;
	}
	//=====================================
	//function : SetLimitMode
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::SetLimitMode(co
	{
	myLimitMode=aMode;
	}
	//=====================================
	//function : LimitMode
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_Splitter::Lim
	{
	return myLimitMode;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::Clear()
	</code></td>
          <td>	<code>}
	//=====================================
	//function : Argument
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_GluerAlgo:
	{
	return myArgument;
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetTolerance(c
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GluerAlgo::Toler
	{
	return myTolerance;
	}
	
	//=====================================
	//function : SetCheckGeometry
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetCheckGeomet
	{
	myCheckGeometry=aFlag;
	}
	//=====================================
	//function : CheckGeometry
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_GluerAlgo::Ch
	{
	return myCheckGeometry;
	}
	//=====================================
	//function : SetContext
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetContext(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 325-346</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 281-302[75]</strong></td>
        </tr>
        <tr>
          <td>	<code>bIsConformState=GEOMAlgo_SurfaceTools
	//
	if (myShapeType==TopAbs_VERTEX){
	if (bIsConformState) {
	myMSS.Add(aV, aSt);
	}
	}
	myMSS.Add(aV, aSt);
	}
	}
	}
	//=====================================
	//function : ProcessEdges
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessEd
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState, bIs
	Standard_Integer i, aNb, iCnt, iErr;</code></td>
          <td>	<code>bIsConformState=GEOMAlgo_SurfaceTools
	//
	if (myShapeType==TopAbs_VERTEX){
	if (bIsConformState) {
	myMSS.Add(aV, aSt);
	}
	}
	myMSS.Add(aV, aSt);
	}
	}
	}
	//=====================================
	//function : ProcessEdges
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessEd
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsConformState, bIs
	Standard_Integer i, aNb, iCnt;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 277-300</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 472-496[74]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed sub-sh
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}
	}
	//=====================================
	//function : ProcessVertices
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessVe
	</code></td>
          <td>	<code>if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed sub-sh
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}
	}
	//
	//=====================================
	//function : CopySource
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::CopySource</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 472-496</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 277-300[74]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed sub-sh
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}
	}
	//
	//=====================================
	//function : CopySource
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::CopySource</code></td>
          <td>	<code>if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}
	//
	myShapeType==TopAbs_SOLID)) {
	myErrorStatus=12; // unallowed sub-sh
	return;
	}
	//
	myState==GEOMAlgo_ST_INOUT) {
	myErrorStatus=13; // unallowed state
	return;
	}
	}
	//=====================================
	//function : ProcessVertices
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::ProcessVe
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 581-589</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 654-662[74]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbCE=0;
	aNbSE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	aE=TopoDS::Edge(aExp.Current());
	if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	aKCE=aInfoE.KindOfClosed();</code></td>
          <td>	<code>aNbSE=0;
	aNbDE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	aE=TopoDS::Edge(aExp.Current());
	if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	aKCE=aInfoE.KindOfClosed();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 392-411</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 355-374[74]</strong></td>
        </tr>
        <tr>
          <td>	<code>if(!bCanBeON) {
	continue;
	}
	}
	//
	InnerPoints(aE, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
          <td>	<code>if (aType2==GeomAbs_Line) {
	continue;
	}
	}
	//
	InnerPoints(aE, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 355-374</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 392-411[74]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType2==GeomAbs_Line) {
	continue;
	}
	}
	//
	InnerPoints(aE, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
          <td>	<code>if(!bCanBeON) {
	continue;
	}
	}
	//
	InnerPoints(aE, aLP);
	if (myErrorStatus) {
	return;
	}
	//
	bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {
	if (iCnt > myNbPntsMax) {
	break;
	}
	}
	//
	const gp_Pnt& aP=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 324-345</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 364-385[73]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aV=aExp.Current()
	//
	bIsConformState=myMSS.Contains(aV);
	if (!bIsConformState) {
	break;// vertex has non-conformed sta
	}
	else {
	aSt=myMSS.FindFromKey(aV);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // vertex has non-conformed
	}
	//
	if (BRep_Tool::Degenerated(aE)) {
	myMSS.Add(aE, aSt);
	continue;
	}
	//
	if (myState==GEOMAlgo_ST_ON && aType1</code></td>
          <td>	<code>const TopoDS_Shape& aV=aExp.Current()
	//
	bIsConformState=myMSS.Contains(aV);
	if (!bIsConformState) {
	break;// vertex has non-conformed sta
	}
	else {
	aSt=myMSS.FindFromKey(aV);
	aSC.AppendState(aSt);
	}
	}
	//
	if (!bIsConformState) {
	continue; // vertex has non-conformed
	}
	//
	if (BRep_Tool::Degenerated(aE)) {
	myMSS.Add(aE, aSt);
	continue;
	}
	//
	if (myState==GEOMAlgo_ST_ON) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 222-260</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 227-265[73]</strong></td>
        </tr>
        <tr>
          <td>	<code>myClsf->SetTolerance(myTolerance);
	//
	// 1
	ProcessVertices();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_VERTEX) {
	return;
	}
	//
	// 2
	ProcessEdges();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_EDGE) {
	return;
	}
	//
	// 3
	ProcessFaces();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_FACE) {
	return;
	}
	//
	// 4
	ProcessSolids();
	//
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::CheckData
	{</code></td>
          <td>	<code>GEOMAlgo_ShapeAlgo::Perform();
	//
	// 1
	ProcessVertices();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_VERTEX) {
	return;
	}
	//
	// 2
	ProcessEdges();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_EDGE) {
	return;
	}
	//
	// 3
	ProcessFaces();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_FACE) {
	return;
	}
	//
	// 4
	ProcessSolids();
	//
	}
	//=====================================
	//function : ProcessVertices
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessVe
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 214-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 255-289[72]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetLocation(co
	{
	myLocation=aP;
	}
	//=====================================
	//function : Location
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Locat
	{
	return myLocation;
	}
	//=====================================
	//function : SetDirection
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetDirection(c
	{
	myDirection=aD;
	}
	//=====================================
	//function : Direction
	//purpose :
	//=====================================
	const gp_Dir& GEOMAlgo_ShapeInfo::Direc
	{
	return myDirection;
	}
	//=====================================
	//function : SetPosition
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPosition(co
	{
	</code></td>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetPosition(co
	{
	myPosition=aAx3;
	}
	//=====================================
	//function : Position
	//purpose :
	//=====================================
	const gp_Ax3& GEOMAlgo_ShapeInfo::Posit
	{
	return myPosition;
	}
	
	//=====================================
	//function : SetPnt1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPnt1(const
	{
	myPnt1=aP;
	}
	//=====================================
	//function : Pnt1
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Pnt1(
	{
	return myPnt1;
	}
	//=====================================
	//function : SetPnt2
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPnt2(const
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 189-215</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 216-242[72]</strong></td>
        </tr>
        <tr>
          <td>	<code>break;
	case BRepCheck_NoSurface:
	error_msg << ";No surface";
	break;
	case BRepCheck_InvalidWire:
	error_msg << ";Invalid wires";
	break;
	case BRepCheck_RedundantWire:
	error_msg << ";Redundant wires";
	break;
	case BRepCheck_IntersectingWires:
	error_msg << ";Intersecting wires";
	break;
	case BRepCheck_InvalidImbricationOfWi
	error_msg << ";Invalid imbrication of
	break;
	case BRepCheck_InvalidImbricationOfSh
	error_msg << ";BRepCheck_InvalidImbri
	break;
	case BRepCheck_EmptyShell:
	error_msg << ";Empty shell";
	break;
	case BRepCheck_RedundantFace:
	error_msg << ";Redundant face";
	break;
	case BRepCheck_UnorientableShape:
	error_msg << ";Unorientable shape";</code></td>
          <td>	<code>break;
	case BRepCheck_NotClosed:
	error_msg << ";Not closed";
	break;
	case BRepCheck_NotConnected:
	error_msg << ";Not connected";
	break;
	case BRepCheck_SubshapeNotInShape:
	error_msg << ";Subshape not in shape"
	break;
	case BRepCheck_BadOrientation:
	error_msg << ";Bad orientation";
	break;
	case BRepCheck_BadOrientationOfSubsha
	error_msg << ";Bad orientation of sub
	break;
	case BRepCheck_InvalidToleranceValue:
	error_msg << ";Invalid tolerance valu
	break;
	case BRepCheck_EnclosedRegion:
	error_msg << ";Enclosed region";
	break;
	case BRepCheck_InvalidPolygonOnTriang
	error_msg << ";Invalid polygon on tri
	break;
	case BRepCheck_CheckFail:
	error_msg << ";Check failed";</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 230-265</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 225-260[72]</strong></td>
        </tr>
        <tr>
          <td>	<code>ProcessVertices();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_VERTEX) {
	return;
	}
	//
	// 2
	ProcessEdges();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_EDGE) {
	return;
	}
	//
	// 3
	ProcessFaces();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_FACE) {
	return;
	}
	//
	// 4
	ProcessSolids();
	//
	}
	//=====================================
	//function : ProcessVertices
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::ProcessVe
	{</code></td>
          <td>	<code>ProcessVertices();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_VERTEX) {
	return;
	}
	//
	// 2
	ProcessEdges();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_EDGE) {
	return;
	}
	//
	// 3
	ProcessFaces();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_FACE) {
	return;
	}
	//
	// 4
	ProcessSolids();
	//
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::CheckData
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Clsf.cxx: line 42-82</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 66-106[72]</strong></td>
        </tr>
        <tr>
          <td>	<code>myTolerance=0.0001;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_Clsf::~GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_Clsf::SetTolerance(cons
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_Clsf::Toleranc
	{
	return myTolerance;
	}
	//=====================================
	//function : SetPnt
	//purpose :
	//=====================================
	void GEOMAlgo_Clsf::SetPnt(const gp_P
	{
	myPnt=aP;
	}
	//=====================================
	//function : Pnt
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_Clsf::Pnt()con
	{
	return myPnt;
	}</code></td>
          <td>	<code>myTolerance=0.0001;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeInfoFiller::~GEOMAlgo_Sha
	{
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetToler
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfoFiller:
	{
	return myTolerance;
	}
	//=====================================
	//function : SetShape
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetShape
	{
	myShape=aS;
	}
	//=====================================
	//function : Shape
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ShapeInfoF
	{
	return myShape;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 887-904</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 198-215[72]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	Standard_Boolean bIsDE;
	Standard_Real aT1, aT2;
	TopoDS_Vertex aV1, aV2, aVR1, aVR2;
	TopoDS_Edge aEx;
	//
	bIsDE=BRep_Tool::Degenerated(aE);
	//
	aEx=aE;
	aEx.Orientation(TopAbs_FORWARD);
	//
	TopExp::Vertices(aEx, aV1, aV2);
	//
	aT1=BRep_Tool::Parameter(aV1, aEx);
	aT2=BRep_Tool::Parameter(aV2, aEx);
	//
	aVR1=TopoDS::Vertex(myOrigins.Find(aV</code></td>
          <td>	<code>myErrorStatus=0;
	//
	Standard_Boolean bIsDE;
	Standard_Real aT1, aT2;
	TopoDS_Vertex aV1, aV2, aVR1, aVR2;
	TopoDS_Edge aEx;
	//
	bIsDE=BRep_Tool::Degenerated(aE);
	//
	aEx=aE;
	aEx.Orientation(TopAbs_FORWARD);
	//
	TopExp::Vertices(aEx, aV1, aV2);
	//
	aT1=BRep_Tool::Parameter(aV1, aEx);
	aT2=BRep_Tool::Parameter(aV2, aEx);
	//
	aVR1=aV1;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 178-186</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 191-199[71]</strong></td>
        </tr>
        <tr>
          <td>	<code>// cylinder (as they understand it)
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName();
	aInfo.SetKindOfName(aKNF);
	aInfo.SetLocation(aInfoF.Location());
	aInfo.SetPosition(aInfoF.Position());
	aInfo.SetRadius1(aInfoF.Radius1());
	aInfo.SetHeight(aInfoF.Height());</code></td>
          <td>	<code>// cone
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName();
	aInfo.SetKindOfName(aKNF);
	aInfo.SetLocation(aInfoF.Location());
	aInfo.SetPosition(aInfoF.Position());
	aInfo.SetRadius1(aInfoF.Radius1());
	aInfo.SetRadius2(aInfoF.Radius2());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 361-380</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 420-439[71]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aItS;
	TopoDS_Shape aEnew;
	TopTools_IndexedMapOfShape aME;
	TopTools_MapOfShape aMFence;
	TopTools_ListIteratorOfListOfShape aI
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	TopExp::MapShapes(myArgument, theType
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);
	//
	if (!aMFence.Add(aE)) {
	continue;
	}
	//
	bIsToWork=myOriginsToWork.IsBound(aE)</code></td>
          <td>	<code>TopoDS_Shape aWnew, aEnew;
	TopoDS_Iterator aItS;
	BRep_Builder aBB;
	TopTools_IndexedMapOfShape aMW;
	TopTools_MapOfShape aMFence;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	TopExp::MapShapes(myArgument, aType,
	//
	aNbW=aMW.Extent();
	for (i=1; i<=aNbW; ++i) {
	const TopoDS_Shape& aW=aMW(i);
	//
	if (!aMFence.Add(aW)) {
	continue;
	}
	//
	bHasImage=HasImage(aW);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 462-479</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 982-998[71]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bIsToReverse=
	GEOMAlgo_AlgoTools::IsSplitToReverse(
	if (bIsToReverse) {
	aER.Reverse();
	}
	}
	else {
	aER.Orientation(aE.Orientation());
	}
	//
	aBB.Add(newWire, aER);
	}
	// xf
	TopTools_ListOfShape aLW;
	//
	aLW.Append(aW);
	myImages.Bind(newWire, aLW);
	myOrigins.Bind(aW, newWire);</code></td>
          <td>	<code>bIsToReverse=GEOMAlgo_AlgoTools::IsSp
	if (bIsToReverse) {
	aER.Reverse();
	}
	}
	else {
	aER.Orientation(aE.Orientation());
	}
	//
	aBB.Add(newWire, aER);
	}
	// xf
	TopTools_ListOfShape aLW;
	//
	aLW.Append(aW);
	myImages.Bind(newWire, aLW);
	myOrigins.Bind(aW, newWire);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 325-342</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 682-699[71]</strong></td>
        </tr>
        <tr>
          <td>	<code>myImages.Bind(aNewShape, aLSDF);
	// origins
	aItS.Initialize(aLSDF);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aFSD=aItS.Value()
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aNewShape);
	}
	}
	}
	}
	//=====================================
	//function : DetectSolids
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectSol
	{
	myErrorStatus=0;</code></td>
          <td>	<code>myImages.Bind(aNewShape, aLSDF);
	// origins
	aItS.Initialize(aLSDF);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aFSD=aItS.Value()
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aNewShape);
	}
	}
	}
	}
	//=====================================
	//function : CheckResult
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::CheckResult()
	{
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 64-87</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 115-138[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ListIteratorOfListOfCoupleOf
	GEOMAlgo_ListIteratorOfListOfPnt.hxx
	GEOMAlgo_ListOfCoupleOfShapes.hxx
	GEOMAlgo_ListOfPnt.hxx
	GEOMAlgo_PassKey.hxx
	GEOMAlgo_PassKeyMapHasher.hxx
	GEOMAlgo_PassKeyShape.hxx
	GEOMAlgo_PassKeyShapeMapHasher.hxx
	GEOMAlgo_RemoverWebs.hxx
	GEOMAlgo_ShapeAlgo.hxx
	GEOMAlgo_ShapeInfo.hxx
	GEOMAlgo_ShapeInfoFiller.hxx
	GEOMAlgo_ShapeSolid.hxx
	GEOMAlgo_ShellSolid.hxx
	GEOMAlgo_SolidSolid.hxx
	GEOMAlgo_Splitter.hxx
	GEOMAlgo_State.hxx
	GEOMAlgo_StateCollector.hxx
	GEOMAlgo_SurfaceTools.hxx
	GEOMAlgo_VertexSolid.hxx
	GEOMAlgo_WireSolid.hxx
	)
	
	# --- sources ---</code></td>
          <td>	<code>GEOMAlgo_Gluer2_2.cxx
	GEOMAlgo_Gluer2_3.cxx
	GEOMAlgo_GluerAlgo.cxx
	GEOMAlgo_HAlgo.cxx
	GEOMAlgo_PassKey.cxx
	GEOMAlgo_PassKeyMapHasher.cxx
	GEOMAlgo_PassKeyShape.cxx
	GEOMAlgo_PassKeyShapeMapHasher.cxx
	GEOMAlgo_RemoverWebs.cxx
	GEOMAlgo_ShapeAlgo.cxx
	GEOMAlgo_ShapeInfo.cxx
	GEOMAlgo_ShapeInfoFiller.cxx
	GEOMAlgo_ShapeInfoFiller_1.cxx
	GEOMAlgo_ShapeSolid.cxx
	GEOMAlgo_ShellSolid.cxx
	GEOMAlgo_SolidSolid.cxx
	GEOMAlgo_Splitter.cxx
	GEOMAlgo_StateCollector.cxx
	GEOMAlgo_SurfaceTools.cxx
	GEOMAlgo_VertexSolid.cxx
	GEOMAlgo_WireSolid.cxx
	)
	
	# --- options ---</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 909-928</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 230-247[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (bIsDE) {
	Standard_Real aTol;
	BRep_Builder aBB;
	TopoDS_Edge E;
	//TopAbs_Orientation anOrE;
	//
	//anOrE=aE.Orientation();
	aTol=BRep_Tool::Tolerance(aE);
	//
	E=aEx;
	E.EmptyCopy();
	//
	aBB.Add (E, aVR1);
	aBB.Add (E, aVR2);
	aBB.Range(E, aT1, aT2);
	aBB.Degenerated(E, Standard_True);
	aBB.UpdateEdge(E, aTol);
	//
	aNewEdge=E;
	}</code></td>
          <td>	<code>else {
	Standard_Real aTol;
	BRep_Builder aBB;
	TopoDS_Edge E;
	//
	aTol=BRep_Tool::Tolerance(aE);
	//
	E=aEx;
	E.EmptyCopy();
	//
	aBB.Add (E, aVR1);
	aBB.Add (E, aVR2);
	aBB.Range(E, aT1, aT2);
	aBB.Degenerated(E, Standard_True);
	aBB.UpdateEdge(E, aTol);
	//
	aNewEdge=E;
	}
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 614-619</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 625-630[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>size_t CollisionDetector::countType(c
	{
	const auto& row = myCollisionInfos[i]
	return std::count_if(row.cbegin(), ro
	const CollisionInfo& info = p.second;
	return (info.type == collisionType);</code></td>
          <td>	<code>bool CollisionDetector::hasAtLeastTyp
	{
	const auto& row = myCollisionInfos[i]
	return std::any_of(row.cbegin(), row.
	const CollisionInfo& info = p.second;
	return (info.type >= collisionType);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 841-858</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 256-273[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbV;
	Standard_Real aTolV, aD, aDmax;
	gp_XYZ aGC;
	gp_Pnt aP3D, aPGC;
	TopoDS_Vertex aVx;
	BRep_Builder aBB;
	TopTools_ListIteratorOfListOfShape aI
	//
	aNbV=aLV.Extent();
	if (!aNbV) {
	return;
	}
	//
	// center of gravity
	aGC.SetCoord(0.,0.,0.);
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=TopoDS::Vertex(aIt.Value());</code></td>
          <td>	<code>Standard_Integer aNbV;
	Standard_Real aTolV, aD, aDmax;
	gp_XYZ aGC;
	gp_Pnt aP3D, aPGC;
	TopoDS_Vertex aVx;
	BRep_Builder aBB;
	TopTools_ListIteratorOfListOfShape aI
	//
	aNbV=aLV.Extent();
	if (!aNbV) {
	return;
	}
	//
	// center of gravity
	aGC.SetCoord(0.,0.,0.);
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=*((TopoDS_Vertex*)(&aIt.Value()))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 346-358</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 215-228[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBox2.Enlarge(myTolerance);
	//
	aSelector.Clear();
	aSelector.SetBox(aBox2);
	aNbSD=aBBTree.Select(aSelector);
	if (!aNbSD) {
	continue; // it should not be
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	aItLI.Initialize(aLI);
	for (; aItLI.More(); aItLI.Next()) {
	i=aItLI.Value();
	</code></td>
          <td>	<code>const GEOMAlgo_BndSphere& aBoxVP=aMSB
	//
	aSelector.Clear();
	aSelector.SetBox(aBoxVP);
	//
	aNbVSD=aBBTree.Select(aSelector);
	if (!aNbVSD) {
	continue; // it should not be so [at
	}
	//
	const TColStd_ListOfInteger& aLI=aSel
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {
	aIP1=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 230-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 909-928[70]</strong></td>
        </tr>
        <tr>
          <td>	<code>else {
	Standard_Real aTol;
	BRep_Builder aBB;
	TopoDS_Edge E;
	//
	aTol=BRep_Tool::Tolerance(aE);
	//
	E=aEx;
	E.EmptyCopy();
	//
	aBB.Add (E, aVR1);
	aBB.Add (E, aVR2);
	aBB.Range(E, aT1, aT2);
	aBB.Degenerated(E, Standard_True);
	aBB.UpdateEdge(E, aTol);
	//
	aNewEdge=E;
	}
	
	</code></td>
          <td>	<code>if (bIsDE) {
	Standard_Real aTol;
	BRep_Builder aBB;
	TopoDS_Edge E;
	//TopAbs_Orientation anOrE;
	//
	//anOrE=aE.Orientation();
	aTol=BRep_Tool::Tolerance(aE);
	//
	E=aEx;
	E.EmptyCopy();
	//
	aBB.Add (E, aVR1);
	aBB.Add (E, aVR2);
	aBB.Range(E, aT1, aT2);
	aBB.Degenerated(E, Standard_True);
	aBB.UpdateEdge(E, aTol);
	//
	aNewEdge=E;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 679-697</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 382-401[69]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//
	myImages.Bind(aNewShape, aLSDF);
	// origins
	aItS.Initialize(aLSDF);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aFSD=aItS.Value()
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aNewShape);
	}
	}
	}
	}
	//=====================================
	//function : CheckResult
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::CheckResult()
	</code></td>
          <td>	<code>}
	}
	//
	myImages.Bind(aS1, aLSDF);
	//
	// origins
	aItLS.Initialize(aLSDF);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aFSD=aItLS.Value(
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aS1);
	}
	}
	}// for (i=1; i<=aNbF; ++i)
	}
	//=====================================
	//function : FacePassKey
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::FacePassKey</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 869-886</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 284-301[69]</strong></td>
        </tr>
        <tr>
          <td>	<code>aVx=TopoDS::Vertex(aIt.Value());
	aP3D=BRep_Tool::Pnt(aVx);
	aTolV=BRep_Tool::Tolerance(aVx);
	aD=aPGC.Distance(aP3D)+aTolV;
	if (aD>aDmax) {
	aDmax=aD;
	}
	}
	//
	aBB.MakeVertex (aNewVertex, aPGC, aDm
	}
	//=====================================
	//function : MakeEdge
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeEdge(const Top
	TopoDS_Edge& aNewEdge)
	{</code></td>
          <td>	<code>aVx=*((TopoDS_Vertex*)(&aIt.Value()))
	aP3D=BRep_Tool::Pnt(aVx);
	aTolV=BRep_Tool::Tolerance(aVx);
	aD=aPGC.Distance(aP3D)+aTolV;
	if (aD>aDmax) {
	aDmax=aD;
	}
	}
	//
	aBB.MakeVertex (aNewVertex, aPGC, aDm
	}
	//=====================================
	//function : MapBRepShapes
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::MapBRepShapes(con
	TopTools_MapOfShape& aM)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 284-301</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 869-886[69]</strong></td>
        </tr>
        <tr>
          <td>	<code>aVx=*((TopoDS_Vertex*)(&aIt.Value()))
	aP3D=BRep_Tool::Pnt(aVx);
	aTolV=BRep_Tool::Tolerance(aVx);
	aD=aPGC.Distance(aP3D)+aTolV;
	if (aD>aDmax) {
	aDmax=aD;
	}
	}
	//
	aBB.MakeVertex (aNewVertex, aPGC, aDm
	}
	//=====================================
	//function : MapBRepShapes
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::MapBRepShapes(con
	TopTools_MapOfShape& aM)
	{</code></td>
          <td>	<code>aVx=TopoDS::Vertex(aIt.Value());
	aP3D=BRep_Tool::Pnt(aVx);
	aTolV=BRep_Tool::Tolerance(aVx);
	aD=aPGC.Distance(aP3D)+aTolV;
	if (aD>aDmax) {
	aDmax=aD;
	}
	}
	//
	aBB.MakeVertex (aNewVertex, aPGC, aDm
	}
	//=====================================
	//function : MakeEdge
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeEdge(const Top
	TopoDS_Edge& aNewEdge)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 382-401</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 679-697[69]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//
	myImages.Bind(aS1, aLSDF);
	//
	// origins
	aItLS.Initialize(aLSDF);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aFSD=aItLS.Value(
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aS1);
	}
	}
	}// for (i=1; i<=aNbF; ++i)
	}
	//=====================================
	//function : FacePassKey
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::FacePassKey</code></td>
          <td>	<code>}
	}
	//
	myImages.Bind(aNewShape, aLSDF);
	// origins
	aItS.Initialize(aLSDF);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aFSD=aItS.Value()
	if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aNewShape);
	}
	}
	}
	}
	//=====================================
	//function : CheckResult
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::CheckResult()
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 5-5</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 123-123[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################</code></td>
          <td>	<code>#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 79-90</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 57-65[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	
	// detect concave quadrangle sides
	myConcaveQuad = false;
	myConcaveSide.resize (4, false);
	
	for ( int i = 1; i <= 4; ++i ) {
	gp_Vec localQN =
	gp_Vec(myPoints[i], myPoints[i+1]) ^
	
	if (myQuadNormal * localQN < 0) {</code></td>
          <td>	<code>return;
	}
	
	// detect concave quadrangle sides
	myConcaveQuad = false;
	myConcaveSide.resize (4, false);
	for ( int i = 1; i <= 4; ++i ) {
	gp_Vec localQN = gp_Vec( myPoints[i],
	if ( myQuadNormal * localQN < 0 )
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 706-716</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 717-727[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aR[0]>aR[1]) {
	aRmin=aR[1];
	aRmax=aR[0];
	aPc=aPC[0];
	gp_Vec aVz(aPC[0], aPC[1]);
	gp_Vec aVx(aPC[0], aPX[0]);
	gp_Dir aDz(aVz);
	gp_Dir aDx(aVx);
	gp_Ax2 aAx2(aPc, aDz, aDx);
	aAx2new=aAx2;
	}</code></td>
          <td>	<code>else {
	aRmin=aR[0];
	aRmax=aR[1];
	aPc=aPC[1];
	gp_Vec aVz(aPC[1], aPC[0]);
	gp_Vec aVx(aPC[1], aPX[1]);
	gp_Dir aDz(aVz);
	gp_Dir aDx(aVx);
	gp_Ax2 aAx2(aPc, aDz, aDx);
	aAx2new=aAx2;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 49-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 280-294[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	BRep_Builder cBuilder;
	TopoDS_Shape shape;
	BRepTools::Read(shape, filename.c_str
	if (shape.IsNull())
	throw std::runtime_error("brep read d
	
	// explore solids and calc Id
	int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();
	</code></td>
          <td>	<code>}
	// read a Compound or CompSolid, retu
	
	BRep_Builder cBuilder;
	TopoDS_Shape shape;
	BRepTools::Read(shape, filename.c_str
	if (shape.IsNull())
	throw std::runtime_error("brep read d
	
	// explore solids and calc Id
	int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 280-294</strong></td>
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 49-62[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	// read a Compound or CompSolid, retu
	
	BRep_Builder cBuilder;
	TopoDS_Shape shape;
	BRepTools::Read(shape, filename.c_str
	if (shape.IsNull())
	throw std::runtime_error("brep read d
	
	// explore solids and calc Id
	int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();</code></td>
          <td>	<code>}
	
	BRep_Builder cBuilder;
	TopoDS_Shape shape;
	BRepTools::Read(shape, filename.c_str
	if (shape.IsNull())
	throw std::runtime_error("brep read d
	
	// explore solids and calc Id
	int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 57-65</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 79-90[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	
	// detect concave quadrangle sides
	myConcaveQuad = false;
	myConcaveSide.resize (4, false);
	for ( int i = 1; i <= 4; ++i ) {
	gp_Vec localQN = gp_Vec( myPoints[i],
	if ( myQuadNormal * localQN < 0 )
	
	
	</code></td>
          <td>	<code>return;
	}
	
	// detect concave quadrangle sides
	myConcaveQuad = false;
	myConcaveSide.resize (4, false);
	
	for ( int i = 1; i <= 4; ++i ) {
	gp_Vec localQN =
	gp_Vec(myPoints[i], myPoints[i+1]) ^
	
	if (myQuadNormal * localQN < 0) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_HAlgo.cxx: line 38-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Algo.cxx: line 37-78[68]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus(1),
	myWarningStatus(0)
	{}
	//=====================================
	// function: ~
	// purpose:
	//=====================================
	GEOMAlgo_HAlgo::~GEOMAlgo_HAlgo()
	{
	}
	//=====================================
	// function: CheckData
	// purpose:
	//=====================================
	void GEOMAlgo_HAlgo::CheckData()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: CheckResult
	// purpose:
	//=====================================
	void GEOMAlgo_HAlgo::CheckResult()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: ErrorStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_HAlgo::Erro
	{
	return myErrorStatus;
	}
	//=====================================
	// function: WarningStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_HAlgo::Warn
	{
	return myWarningStatus;
	}</code></td>
          <td>	<code>myWarningStatus(0),
	myComputeInternalShapes(Standard_True
	{}
	//=====================================
	// function: ~
	// purpose:
	//=====================================
	GEOMAlgo_Algo::~GEOMAlgo_Algo()
	{
	}
	//=====================================
	// function: CheckData
	// purpose:
	//=====================================
	void GEOMAlgo_Algo::CheckData()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: CheckResult
	// purpose:
	//=====================================
	void GEOMAlgo_Algo::CheckResult()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: ErrorStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_Algo::ErrorSt
	{
	return myErrorStatus;
	}
	//=====================================
	// function: WarningStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_Algo::Warning
	{
	return myWarningStatus;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 27-30</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 61-63 [67]</strong></td>
        </tr>
        <tr>
          <td>	<code>sys.exit()
	
	
	#######################################</code></td>
          <td>	<code>endif()
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.hxx: line 42-70</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 141-206[66]</strong></td>
        </tr>
        <tr>
          <td>	<code>class GEOMAlgo_GluerAlgo {
	public:
	
	Standard_EXPORT
	GEOMAlgo_GluerAlgo();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_GluerAlgo();
	
	Standard_EXPORT
	virtual void SetArgument(const TopoDS
	
	Standard_EXPORT
	const TopoDS_Shape& Argument() const;
	
	Standard_EXPORT
	void SetTolerance(const Standard_Real
	
	Standard_EXPORT
	Standard_Real Tolerance() const;
	
	Standard_EXPORT
	void SetCheckGeometry(const Standard_
	
	Standard_EXPORT
	Standard_Boolean CheckGeometry() cons
	
	Standard_EXPORT
	virtual void Perform() ;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>public GEOMAlgo_Algo
	{
	public:
	/**
	* Constructor.
	*/
	Standard_EXPORT
	GEOMAlgo_GetInPlace();
	/**
	* Destructor.
	*/
	Standard_EXPORT
	virtual ~GEOMAlgo_GetInPlace();
	/**
	* Modifier. Sets the shape where the
	* @param theShape
	* The shape where the search is inten
	*/
	Standard_EXPORT
	virtual void SetShapeWhere(const Topo
	
	/**
	* Selector. Returns the shape where t
	* @return
	* The shape where the search is inten
	*/
	Standard_EXPORT
	const TopoDS_Shape& ShapeWhere() cons
	
	/**
	* Modifier. Sets the tolerance of mas
	* @param theTol
	* The value tolerance of mass.
	*/
	Standard_EXPORT
	void SetTolMass(const Standard_Real t
	
	/**
	* Selector. Returns the value toleran
	* @return
	* The value tolerance of mass.
	*/
	Standard_EXPORT
	Standard_Real TolMass() const;
	
	/**
	* Modifier. Sets the tolerance of cen
	* @param theTol
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	void SetTolCG(const Standard_Real the
	
	/**
	* Selector. Returns the tolerance of
	* @return
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	Standard_Real TolCG() const;
	
	/**
	* Perform the algorithm.
	*/
	Standard_EXPORT
	virtual void Perform() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 59-63</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 35-38     [66]</strong></td>
        </tr>
        <tr>
          <td>	<code># endif()
	
	endif()
	
	#######################################</code></td>
          <td>	<code>endif()
	endif()
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 35-38</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 59-63 [66]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif()
	endif()
	
	#######################################
	</code></td>
          <td>	<code># endif()
	
	endif()
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 287-302</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 183-196[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>aState=BOPTools_AlgoTools::ComputeSta
	}
	//----------
	if (aState==TopAbs_ON) {
	myLSON.Append(aF);
	}
	else if (aState==TopAbs_OUT) {
	myLSOUT.Append(aF);
	}
	else if (aState==TopAbs_IN) {
	myLSIN.Append(aF);
	}
	//----------
	}//for (i=iBeg; i<=iEnd; ++i) {
	
	}// try</code></td>
          <td>	<code>aState=BOPTools_AlgoTools::ComputeStat
	}
	//----------
	if (aState==TopAbs_ON) {
	myLSON.Append(aE);
	}
	else if (aState==TopAbs_OUT) {
	myLSOUT.Append(aE);
	}
	else if (aState==TopAbs_IN) {
	myLSIN.Append(aE);
	}
	}
	}
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 27-30</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 118-119   [65]</strong></td>
        </tr>
        <tr>
          <td>	<code>import FreeCAD as App
	import Part
	
	#######################################</code></td>
          <td>	<code># python wrap currently only Geom modul
	#######################################
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 183-196</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 287-302[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>aState=BOPTools_AlgoTools::ComputeStat
	}
	//----------
	if (aState==TopAbs_ON) {
	myLSON.Append(aE);
	}
	else if (aState==TopAbs_OUT) {
	myLSOUT.Append(aE);
	}
	else if (aState==TopAbs_IN) {
	myLSIN.Append(aE);
	}
	}
	}
	
	</code></td>
          <td>	<code>aState=BOPTools_AlgoTools::ComputeSta
	}
	//----------
	if (aState==TopAbs_ON) {
	myLSON.Append(aF);
	}
	else if (aState==TopAbs_OUT) {
	myLSOUT.Append(aF);
	}
	else if (aState==TopAbs_IN) {
	myLSIN.Append(aF);
	}
	//----------
	}//for (i=iBeg; i<=iEnd; ++i) {
	
	}// try</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.cxx: line 69-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 103-138[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeAlgo::SetShape(const
	{
	myShape=aS;
	}
	//=====================================
	//function : Shape
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ShapeAlgo:
	{
	return myShape;
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeAlgo::SetTolerance(c
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeAlgo::Toler
	{
	return myTolerance;
	}
	//=====================================
	//function : Result
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ShapeAlgo:
	{
	return myResult;
	}</code></td>
          <td>	<code>(const TopTools_DataMapOfShapeListOfS
	{
	myShapesToGlue=aM;
	}
	//=====================================
	//function : ShapesToGlue
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myShapesToGlue;
	}
	//=====================================
	//function : SetKeepNonSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::SetKeepNonSolids(
	{
	myKeepNonSolids=aFlag;
	}
	//=====================================
	//function : KeepNonSolids
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer2::KeepN
	{
	return myKeepNonSolids;
	}
	//=====================================
	//function : ShapesDetected
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myImagesDetected;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 305-314</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 269-278[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNb, iErr;
	gp_Pnt aP;
	TopTools_IndexedMapOfShape aM;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_VER
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);</code></td>
          <td>	<code>Standard_Integer i, aNb;
	gp_Pnt aP;
	TopTools_IndexedMapOfShape aM;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_VER
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 546-557</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 644-655[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNbE;
	TopTools_MapOfShape aMSX;
	TopTools_IndexedMapOfShape aME;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aV2=aCS.Shape2();</code></td>
          <td>	<code>Standard_Boolean bFound, bHasOnF, bHa
	TopoDS_Iterator aIt;
	TopTools_MapOfShape aMSX;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 625-630</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 634-640[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>bool CollisionDetector::hasAtLeastTyp
	{
	const auto& row = myCollisionInfos[i]
	return std::any_of(row.cbegin(), row.
	const CollisionInfo& info = p.second;
	return (info.type >= collisionType);</code></td>
          <td>	<code>bool CollisionDetector::isAllTypeExce
	const ItemIndexType exception)
	{
	const auto& row = myCollisionInfos[i]
	return std::all_of(row.cbegin(), row.
	const CollisionInfo& info = p.second;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 118-119</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 27-30[65]</strong></td>
        </tr>
        <tr>
          <td>	<code># python wrap currently only Geom modul
	#######################################
	
	</code></td>
          <td>	<code>import FreeCAD as App
	import Part
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 628-637</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 643-652[65]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	int countDeletedShape(const std::shar
	{
	int mfc = 0;
	const auto& inputs = mkGFA->Arguments
	for (const auto& s : inputs)
	{
	for (TopExp_Explorer anExp(s, stype);
	{</code></td>
          <td>	<code>}
	
	int countModifiedShape(const std::sha
	{
	int mfc = 0;
	const auto& inputs = mkGFA->Arguments
	for (const auto& s : inputs)
	{
	for (TopExp_Explorer anExp(s, stype);
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1100-1119</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1119-1137[64]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillImgComplex(aS, IsWhere);
	}
	}
	
	//=====================================
	//function : FillShapesIn
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillShapesIn(
	const TopoDS_Shape& aS2)
	{
	if (myShapesIn.IsBound(aS1)) {
	TopTools_MapOfShape& aMS=myShapesIn.C
	aMS.Add(aS2);
	}
	else {
	TopTools_MapOfShape aMS;
	//
	aMS.Add(aS2);
	myShapesIn.Bind(aS1, aMS);</code></td>
          <td>	<code>myShapesIn.Bind(aS1, aMS);
	}
	}
	//=====================================
	//function : FillShapesOn
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillShapesOn(
	const TopoDS_Shape& aS2)
	{
	if (myShapesOn.IsBound(aS1)) {
	TopTools_MapOfShape& aMS=myShapesOn.C
	aMS.Add(aS2);
	}
	else {
	TopTools_MapOfShape aMS;
	//
	aMS.Add(aS2);
	myShapesOn.Bind(aS1, aMS);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 532-538</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 582-588[64]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbDE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	aE=TopoDS::Edge(aExp.Current());
	if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKSE=aInfoE.KindOfShape();</code></td>
          <td>	<code>aNbSE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	aE=TopoDS::Edge(aExp.Current());
	if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 122-129</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 142-151[64]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt.Initialize(myLSOUT);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aF=aIt.Value();
	aMFS.Add(aF, TopAbs_OUT);
	}
	aIt.Initialize(myLSON);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aF=aIt.Value();
	
	</code></td>
          <td>	<code>aItLE.Initialize(aLEr);
	for (; aItLE.More(); aItLE.Next()) {
	const TopoDS_Shape& aEr=aItLE.Value()
	aBB.Remove(aWr, aEr);
	}
	//
	// refill contents of Wr
	aItE.Initialize(aW);
	for (; aItE.More(); aItE.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 389-398</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 465-475[64]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::vector<std::shared_ptr<BRepAlgoA
	// fusers.resize(Nbatch);
	for (int i = 0; i < Nbatch; i++)
	{
	fusers.push_back(std::make_shared<BRe
	fusers[i]->SetRunParallel(false);
	// fusers[i]->SetNonDestructive(true)
	}
	
	for (int i = 0; i < Nbatch; i++)
	</code></td>
          <td>	<code>std::vector<std::shared_ptr<BRepAlgoA
	// fusers.resize(Nbatch);
	for (int i = 0; i < Nbatch; i++)
	{
	fusers.push_back(std::make_shared<BRe
	fusers[i]->SetRunParallel(false);
	// fusers[i]->SetNonDestructive(true)
	}
	
	// batch size = 2 only, to simulate G
	for (int i = 0; i < Nboxes; i += batc</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 50-78</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 62-90[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_WireSolid::GEOMAlgo_WireSolid(
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_WireSolid::~GEOMAlgo_WireSolid
	{
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_WireSolid::Perform()
	{
	myErrorStatus=0;
	//
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
          <td>	<code>GEOMAlgo_VertexSolid::GEOMAlgo_VertexSo
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_VertexSolid::~GEOMAlgo_VertexS
	{
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_VertexSolid::Perform()
	{
	myErrorStatus=0;
	//
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 115-117</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 61-63 [62]</strong></td>
        </tr>
        <tr>
          <td>	<code>#endif()
	
	#######################################</code></td>
          <td>	<code>endif()
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 346-358</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 451-463[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNb, iCnt, iErr;
	TopAbs_State aSt;
	TopTools_IndexedMapOfShape aM;
	TopExp_Explorer aExp;
	GEOMAlgo_ListIteratorOfListOfPnt aIt;
	//
	TopExp::MapShapes(myShape, TopAbs_EDG
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	GEOMAlgo_ListOfPnt aLP;
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Edge& aE=TopoDS::Edge(aM</code></td>
          <td>	<code>Standard_Integer i, aNbF, iCnt, iErr;
	TopAbs_State aSt;
	TopTools_IndexedMapOfShape aM;
	TopExp_Explorer aExp;
	GEOMAlgo_ListIteratorOfListOfPnt aIt;
	//
	TopExp::MapShapes(myShape, TopAbs_FAC
	aNbF=aM.Extent();
	for (i=1; i<=aNbF; ++i) {
	GEOMAlgo_StateCollector aSC;
	GEOMAlgo_ListOfPnt aLP;
	//
	const TopoDS_Face& aF=TopoDS::Face(aM</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 57-67</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 86-95[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>objs.append(box)
	
	doc.recompute()
	return objs
	
	def validate_geometry(self, shape):
	print("len(shape.Faces)", len(shape.F
	print("len(shape.Solids) = ", len(sha
	
	assert len(shape.Solids) == 4
	assert shape.ShapeType == "CompSolid"</code></td>
          <td>	<code>)
	doc.recompute()
	return objs
	
	def validate_geometry(self, shape):
	print("len(shape.Faces)", len(shape.F
	print("len(shape.Solids) = ", len(sha
	
	assert len(shape.Solids) == 5
	assert shape.ShapeType == "CompSolid"
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 126-127</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 28-30[62]</strong></td>
        </tr>
        <tr>
          <td>	<code># unit test module
	#######################################
	</code></td>
          <td>	<code>import Part
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 62-90</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 50-78[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_VertexSolid::GEOMAlgo_VertexSo
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_VertexSolid::~GEOMAlgo_VertexS
	{
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_VertexSolid::Perform()
	{
	myErrorStatus=0;
	//
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
          <td>	<code>GEOMAlgo_WireSolid::GEOMAlgo_WireSolid(
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_WireSolid::~GEOMAlgo_WireSolid
	{
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_WireSolid::Perform()
	{
	myErrorStatus=0;
	//
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 323-334</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 337-348[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>myIterator.Clear();
	//
	MapBRepShapes(myArgument, aMS1);
	aNbS1=aMS1.Extent();
	for (i=1; i<=aNbS1; ++i) {
	Bnd_Box aBox1;
	//
	const TopoDS_Shape& aS1=aMS1(i);
	BRepBndLib::Add(aS1, aBox1);
	aBox1.Enlarge(myTolerance);
	//
	aTreeFiller.Add(i, aBox1);</code></td>
          <td>	<code>aTreeFiller.Fill();
	//
	MapBRepShapes(myShapeWhere, aMS2);
	aNbS2=aMS2.Extent();
	for (j=1; j<=aNbS2; ++j) {
	Bnd_Box aBox2;
	//
	const TopoDS_Shape& aS2=aMS2(j);
	BRepBndLib::Add(aS2, aBox2);
	aBox2.Enlarge(myTolerance);
	//
	aSelector.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 150-154</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 168-172[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>d["name"] = p.find("String").attrib["
	elif p.attrib["name"] == "Visibility"
	d["visible"] = p.find("Bool").attrib[
	elif p.attrib["name"] == "Shape":
	d["filename"] = p.find("Part").attrib</code></td>
          <td>	<code>d["label"] = p.find("String").attrib[
	elif p.attrib["name"] == "Visibility"
	d["visible"] = p.find("Bool").attrib[
	elif p.attrib["name"] == "Group":
	d["members"] = [</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 99-102</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 35-38     [62]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif()
	endif()
	
	#######################################</code></td>
          <td>	<code>endif()
	endif()
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 244-263</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 274-293[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>switch (iErr)
	{
	case 11:
	Standard_Failure::Raise("GEOMAlgo_Glu
	break;
	case 13:
	case 14:
	Standard_Failure::Raise("PerformImage
	break;
	default:
	{
	// description of all errors see in G
	TCollection_AsciiString aMsg("Error i
	aMsg += TCollection_AsciiString(iErr)
	Standard_Failure::Raise(aMsg.ToCStrin
	break;
	}
	}
	return aRes;
	}</code></td>
          <td>	<code>switch (iErr)
	{
	case 11:
	Standard_Failure::Raise("GEOMAlgo_Glu
	break;
	case 13:
	case 14:
	Standard_Failure::Raise("PerformImage
	break;
	default:
	{
	// description of all errors see in G
	TCollection_AsciiString aMsg("Error i
	aMsg += TCollection_AsciiString(iErr)
	Standard_Failure::Raise(aMsg.ToCStrin
	break;
	}
	}
	return aRes;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 117-126</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 126-134[62]</strong></td>
        </tr>
        <tr>
          <td>	<code>ShapeErrorType itemError(const ItemIn
	{
	if (myShapeErrors->find((*myShapeIDs)
	return (*myShapeErrors)[(*myShapeIDs)
	else
	return ShapeErrorType::NoError;
	}
	
	/// test before use the value of the
	inline const std::optional<Quantity_C</code></td>
          <td>	<code>inline const std::optional<Quantity_C
	{
	if (myColorMap->find((*myShapeIDs)[in
	return (*myColorMap)[(*myShapeIDs)[in
	else
	return std::nullopt;
	}
	///
	inline const std::optional<Material>
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 380-383</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 17-19[61]</strong></td>
        </tr>
        <tr>
          <td>	<code>config_file_content["processors"] = pro
	
	#######################################
	## to test multiple data sharing one pi</code></td>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 110-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 120-148[61]</strong></td>
        </tr>
        <tr>
          <td>	<code>myStickedShapes.Clear();
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_GluerAlgo::Perform();
	//
	DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	CheckDetected();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}
	//
	DetectFaces();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>mySolidsAlone.Clear();
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();
	//
	InnerTolerance();
	if (myErrorStatus) {
	return;
	}
	//
	DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}
	//
	DetectFaces();
	if (myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 95-98</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 59-63 [61]</strong></td>
        </tr>
        <tr>
          <td>	<code>add_subdirectory(GeomTests)
	endif()
	
	#######################################
	</code></td>
          <td>	<code># endif()
	
	endif()
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 145-147</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 120-123[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>print("action on the geometry is ", a
	
	#######################################
	</code></td>
          <td>	<code># print(args.thread_count)
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 631-646</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 756-767[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	// CYLINDER
	else if (aKN==GEOMAlgo_KN_CYLINDER) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	//
	// CONE
	else if (aKN==GEOMAlgo_KN_CONE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius</code></td>
          <td>	<code>}
	else if (aKN==GEOMAlgo_KN_ELLIPSE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	}
	else if (aKN==GEOMAlgo_KN_ARCELLIPSE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 56-58</strong></td>
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 58-60[60]</strong></td>
        </tr>
        <tr>
          <td>	<code><< std::endl;
	half_float::half hf(static_cast<float
	std::cout << static_cast<float>(hf) <</code></td>
          <td>	<code>std::cout << static_cast<float>(hf) <
	half_float::half hf2(static_cast<floa
	std::cout << static_cast<float>(hf2)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 9-14</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 27-30[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>from tempfile import gettempdir
	import json
	
	import unittest
	
	#######################################</code></td>
          <td>	<code>import FreeCAD as App
	import Part
	
	#######################################
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 606-617</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 631-646[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (aKN==GEOMAlgo_KN_DISKELLIPSE
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	}
	else if (aKN==GEOMAlgo_KN_RECTANGLE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Length : %.3lf\n", myLength)
	printf(" Width : %.3lf\n", myWidth);
	
	
	
	</code></td>
          <td>	<code>}
	//
	// CYLINDER
	else if (aKN==GEOMAlgo_KN_CYLINDER) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Height : %.3lf\n", myHeight)
	}
	//
	// CONE
	else if (aKN==GEOMAlgo_KN_CONE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 65-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 133-157[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Handle(GEOMAlgo_Clsf)& Clsf() c
	
	Standard_EXPORT
	void SetShapeType(const TopAbs_ShapeE
	
	Standard_EXPORT
	TopAbs_ShapeEnum ShapeType() const;
	
	Standard_EXPORT
	void SetState(const GEOMAlgo_State aS
	
	Standard_EXPORT
	GEOMAlgo_State State() const;
	
	Standard_EXPORT
	void SetNbPntsMin(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer NbPntsMin() const;
	
	Standard_EXPORT
	void SetNbPntsMax(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer NbPntsMax() const;</code></td>
          <td>	<code>const gp_Pnt& Pnt2() const;
	
	Standard_EXPORT
	void SetRadius1(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius1() const;
	
	Standard_EXPORT
	void SetRadius2(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius2() const;
	
	Standard_EXPORT
	void SetLength(const Standard_Real aL
	
	Standard_EXPORT
	Standard_Real Length() const;
	
	Standard_EXPORT
	void SetWidth(const Standard_Real aW)
	
	Standard_EXPORT
	Standard_Real Width() const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 858-869</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 273-284[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>aVx=TopoDS::Vertex(aIt.Value());
	aP3D=BRep_Tool::Pnt(aVx);
	aGC+=aP3D.XYZ();
	}
	aGC/=(Standard_Real)aNbV;
	aPGC.SetXYZ(aGC);
	//
	// tolerance value
	aDmax=-1.;
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=TopoDS::Vertex(aIt.Value());</code></td>
          <td>	<code>aVx=*((TopoDS_Vertex*)(&aIt.Value()))
	aP3D=BRep_Tool::Pnt(aVx);
	aGC+=aP3D.XYZ();
	}
	aGC/=(Standard_Real)aNbV;
	aPGC.SetXYZ(aGC);
	//
	// tolerance value
	aDmax=-1.;
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=*((TopoDS_Vertex*)(&aIt.Value()))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 127-162</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 96-131[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Gluer::SetCheckGeometry(c
	{
	myCheckGeometry=aFlag;
	}
	//=====================================
	//function : CheckGeometry
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::CheckG
	{
	return myCheckGeometry;
	}
	//=====================================
	//function : SetKeepNonSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::SetKeepNonSolids(c
	{
	myKeepNonSolids=aFlag;
	}
	//=====================================
	//function : KeepNonSolids
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::KeepNo
	{
	return myKeepNonSolids;
	}
	//=====================================
	//function : AloneShapes
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_Gluer::AloneS
	{
	return myNbAlone;
	}</code></td>
          <td>	<code>void GEOMAlgo_GetInPlace::SetTolMass(co
	{
	myTolMass=theTol;
	}
	//=====================================
	//function : TolMass
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GetInPlace::TolM
	{
	return myTolMass;
	}
	//=====================================
	//function : SetTolCG
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::SetTolCG(cons
	{
	myTolCG=theTol;
	}
	//=====================================
	//function : TolCG
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_GetInPlace::TolC
	{
	return myTolCG;
	}
	//=====================================
	//function : IsFound
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_GetInPlace::I
	{
	return myFound;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 446-456</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 548-557[60]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bFound;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	// 2. Fill Shapes In
	myIterator.Initialize(TopAbs_EDGE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aE1=aCS.Shape1();
	const TopoDS_Shape& aV2=aCS.Shape2();</code></td>
          <td>	<code>TopTools_IndexedMapOfShape aME;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_FACE, To
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aV2=aCS.Shape2();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 46-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 56-89[59]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_SolidSolid::GEOMAlgo_SolidSoli
	:
	GEOMAlgo_ShellSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_SolidSolid::~GEOMAlgo_SolidSol
	{
	}
	//=====================================
	// function: SetShape2
	// purpose:
	//=====================================
	void GEOMAlgo_SolidSolid::SetShape2(con
	{
	myS2=aS2;
	}
	//=====================================
	// function: Shape2
	// purpose:
	//=====================================
	const TopoDS_Shape& GEOMAlgo_SolidSolid
	{
	return myS2;
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_SolidSolid::Perform()
	{</code></td>
          <td>	<code>GEOMAlgo_ClsfBox::GEOMAlgo_ClsfBox()
	:
	GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ClsfBox::~GEOMAlgo_ClsfBox()
	{
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfBox::SetBox(const T
	{
	myBox=aBox;
	}
	//=====================================
	//function : Box
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ClsfBox:
	{
	return myBox;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfBox::CheckData()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 312-326</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 328-337  [59]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/** Dependency management meta data r
	some processor must run after depende
	if some missing properties found in p
	this API cooperate with the `produced
	todo: register meta information in de
	*/
	std::vector<std::string> requiredProp
	{
	std::vector<std::string> myDependenci
	if (myCharacteristics.contains("requi
	{
	myDependencies = myCharacteristics["r
	}</code></td>
          <td>	<code>}
	
	/// a vector of names for properties
	std::vector<std::string> producedProp
	{
	std::vector<std::string> myProducts;
	if (myCharacteristics.contains("produ
	{
	myProducts = myCharacteristics["produ
	}
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 164-177</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 190-204[59]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbVV=aVVs.Length();
	for (j=0; j<aNbVV; ++j) {
	BOPDS_InterfVV& aVV=aVVs(j);
	if (aVV.Contains(i)) {
	myLSON.Append(aV);
	iFound=1;
	break;
	}
	}
	if (iFound) {
	continue;
	}
	// 2
	aNbVE=aVEs.Length();
	</code></td>
          <td>	<code>aNbVF=aVFs.Length();
	for (j=0; j<aNbVF; ++j) {
	BOPDS_InterfVF& aVF=aVFs(j);
	if (aVF.Contains(i)) {
	myLSON.Append(aV);
	iFound=1;
	break;
	}
	}
	if (iFound) {
	continue;
	}
	//
	// 4
	aP3D=BRep_Tool::Pnt(aV);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 24-30</strong></td>
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 34-40[59]</strong></td>
        </tr>
        <tr>
          <td>	<code>TEST(UtilitiesTest, HasFileExtension)
	{
	auto file_name = std::string("./tmp/h
	ASSERT_TRUE(Utilities::hasFileExt(fil
	ASSERT_TRUE(Utilities::hasFileExt(fil
	ASSERT_TRUE(Utilities::hasFileExt(fil
	ASSERT_FALSE(Utilities::hasFileExt(fi</code></td>
          <td>	<code>TEST_CASE("UtilitiesTest", "HasFileExte
	{
	auto file_name = std::string("./tmp/h
	REQUIRE(Utilities::hasFileExt(file_na
	REQUIRE(Utilities::hasFileExt(file_na
	REQUIRE(Utilities::hasFileExt(file_na
	REQUIRE(Utilities::hasFileExt(file_na</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 235-243</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 455-468[59]</strong></td>
        </tr>
        <tr>
          <td>	<code>aXYZc.SetCoord(0.,0.,0.);
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aVi=TopoDS::Vert
	aPi=BRep_Tool::Pnt(aVi);
	const gp_XYZ& aXYZ=aPi.XYZ();
	aXYZc=aXYZc+aXYZ;
	}
	//
	aXYZc.Divide(aNbV);
	
	
	
	
	</code></td>
          <td>	<code>TopExp::MapShapes(aF, TopAbs_VERTEX,
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);
	const gp_XYZ& aXYZ=aP.XYZ();
	aXYZc=aXYZc+aXYZ;
	}
	//
	// Location : aPc in center of rectan
	// Position : 0z is plane normal
	// 0x is along the first edge (quadra
	// along length (rectangle)
	//
	aXYZc.Divide(4.);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 381-399</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 175-193[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : IsUPeriodic
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_AlgoTools::Is
	{
	Standard_Boolean bRet;
	GeomAbs_SurfaceType aType;
	GeomAdaptor_Surface aGAS;
	//
	aGAS.Load(aS);
	aType=aGAS.GetType();
	//
	return bRet;
	}</code></td>
          <td>	<code>}
	//=====================================
	//function : IsAnalytic
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_SurfaceTools:
	(const Handle(Geom_Surface)& aSurf)
	{
	Standard_Boolean bRet;
	GeomAbs_SurfaceType aType;
	GeomAdaptor_Surface aGAS;
	//
	aGAS.Load(aSurf);
	aType==GeomAbs_Sphere);
	return bRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 101-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 157-161[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (Utilities::hasFileExt(file_name,
	Utilities::hasFileExt(file_name, "igs
	{
	this->readXCAFDoc(file_name);
	this->loadXCAFDoc();</code></td>
          <td>	<code>if (Utilities::hasFileExt(file_name,
	Utilities::hasFileExt(file_name, "igs
	{
	this->readXCAFDoc(file_name);
	this->loadXCAFDoc(metadata);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 29-64</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.hxx: line 28-62[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyShape_HeaderFi
	#define _GEOMAlgo_PassKeyShape_HeaderFi
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <TopTools_IndexedMapOfShape.hx
	#include <Standard_Boolean.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopTools_ListOfShape.hxx>
	
	
	//=====================================
	//class : GEOMAlgo_PassKeyShape
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyShape {
	public:
	Standard_EXPORT
	GEOMAlgo_PassKeyShape();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_PassKeyShape();
	
	Standard_EXPORT
	GEOMAlgo_PassKeyShape(const GEOMAlgo_
	
	Standard_EXPORT
	GEOMAlgo_PassKeyShape& Assign(const G
	
	GEOMAlgo_PassKeyShape& operator =(con
	return Assign(Other);
	}
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS</code></td>
          <td>	<code>#ifndef _GEOMAlgo_PassKey_HeaderFile
	#define _GEOMAlgo_PassKey_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <TColStd_ListOfInteger.hxx>
	#include <TColStd_IndexedMapOfInteger.h
	
	//=====================================
	//class : GEOMAlgo_PassKey
	//purpose :
	//=====================================
	class GEOMAlgo_PassKey {
	public:
	Standard_EXPORT
	GEOMAlgo_PassKey();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_PassKey();
	
	Standard_EXPORT
	GEOMAlgo_PassKey(const GEOMAlgo_PassK
	
	Standard_EXPORT
	GEOMAlgo_PassKey& Assign(const GEOMAl
	
	GEOMAlgo_PassKey& operator =(const GE
	return Assign(Other);
	}
	
	Standard_EXPORT
	void Clear() ;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.hxx: line 28-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 29-64[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_PassKey_HeaderFile
	#define _GEOMAlgo_PassKey_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <TColStd_ListOfInteger.hxx>
	#include <TColStd_IndexedMapOfInteger.h
	
	//=====================================
	//class : GEOMAlgo_PassKey
	//purpose :
	//=====================================
	class GEOMAlgo_PassKey {
	public:
	Standard_EXPORT
	GEOMAlgo_PassKey();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_PassKey();
	
	Standard_EXPORT
	GEOMAlgo_PassKey(const GEOMAlgo_PassK
	
	Standard_EXPORT
	GEOMAlgo_PassKey& Assign(const GEOMAl
	
	GEOMAlgo_PassKey& operator =(const GE
	return Assign(Other);
	}
	
	Standard_EXPORT
	void Clear() ;
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyShape_HeaderFi
	#define _GEOMAlgo_PassKeyShape_HeaderFi
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <TopTools_IndexedMapOfShape.hx
	#include <Standard_Boolean.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopTools_ListOfShape.hxx>
	
	
	//=====================================
	//class : GEOMAlgo_PassKeyShape
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyShape {
	public:
	Standard_EXPORT
	GEOMAlgo_PassKeyShape();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_PassKeyShape();
	
	Standard_EXPORT
	GEOMAlgo_PassKeyShape(const GEOMAlgo_
	
	Standard_EXPORT
	GEOMAlgo_PassKeyShape& Assign(const G
	
	GEOMAlgo_PassKeyShape& operator =(con
	return Assign(Other);
	}
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 452-464</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 485-497[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbC=NbSubShapes(TopAbs_COMPSOLID);
	aNbP=NbSubShapes(TopAbs_COMPOUND);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();
	//
	printf(" *COMPOUND\n");
	printf(" number of vertices : %d\n",
	printf(" number of edges : %d\n", aNb
	printf(" number of faces : %d\n", aNb
	printf(" number of solids : %d\n", aN
	printf(" number of compsolids : %d\n"</code></td>
          <td>	<code>aNbF=NbSubShapes(TopAbs_FACE);
	aNbS=NbSubShapes(TopAbs_SOLID);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();
	//
	printf(" *COMPSOLID\n");
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	printf(" number of faces : %d\n", aNb
	printf(" number of solids : %d\n", aN
	DumpKindOfShape (aKS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 175-193</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 381-399[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : IsAnalytic
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_SurfaceTools:
	(const Handle(Geom_Surface)& aSurf)
	{
	Standard_Boolean bRet;
	GeomAbs_SurfaceType aType;
	GeomAdaptor_Surface aGAS;
	//
	aGAS.Load(aSurf);
	aType==GeomAbs_Sphere);
	return bRet;
	}</code></td>
          <td>	<code>}
	//=====================================
	//function : IsUPeriodic
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_AlgoTools::Is
	{
	Standard_Boolean bRet;
	GeomAbs_SurfaceType aType;
	GeomAdaptor_Surface aGAS;
	//
	aGAS.Load(aS);
	aType=aGAS.GetType();
	//
	return bRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 591-605</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 722-736[58]</strong></td>
        </tr>
        <tr>
          <td>	<code>DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);
	DumpKindOfDef(aKD);
	//
	// PLANE
	if (aKN==GEOMAlgo_KN_PLANE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	}
	else if (aKN==GEOMAlgo_KN_DISKCIRCLE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius</code></td>
          <td>	<code>printf(" number of vertices: %d\n", a
	DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);
	//
	// LINE
	if (aKN==GEOMAlgo_KN_LINE) {
	DumpLocation (myLocation);
	DumpDirection(myDirection);
	}
	else if (aKN==GEOMAlgo_KN_SEGMENT) {
	DumpLocation (myLocation);
	DumpDirection(myDirection);
	printf(" Length : %.3lf\n", myLength)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/AppPy.cpp: line 26-32</strong></td>
        <td style="text-align:center"><strong>src/python/AppPy.cpp: line 50-56   [57]</strong></td>
        </tr>
        <tr>
          <td>	<code>.def("config", &pc::config, "get conf
	.def("process", [](pc& self) { // C++
	py::scoped_ostream_redirect stream(st
	py::module::import("sys").attr("stdou
	);
	self.process();
	}); // semicolon at the end of the ch</code></td>
          <td>	<code>.def("config", &mt::config, "get conf
	.def("process", [](mt& self) { // C++
	py::scoped_ostream_redirect stream(st
	py::module::import("sys").attr("stdou
	);
	self.process();
	}); // semicolon at the end of the ch</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 94-104</strong></td>
        <td style="text-align:center"><strong>src/PPP/WorkflowController.h: line 10-20[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>Coincidence = 64, ///< identical shap
	Enclosure = 128, ///< a smaller shape
	UnknownError = 256, ///< equal to Col
	TessellationError = 512 ///< failed t
	};
	// then CollisionInfo can be implicit
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeErr
	{ShapeErrorType::NoError, "NoError"},
	{ShapeErrorType::VolumeTooSmall, "Vol
	{ShapeErrorType::ItemInvisible, "Item
	{ShapeErrorType::BOPCheckFailed, "BOP</code></td>
          <td>	<code>Unknown = 0, ///< default value, unko
	Pipeline = 1, ///< single data source
	Tree = 2, ///< single data source, mu
	Graph = 3 ///< Directed acyclic graph
	};
	
	NLOHMANN_JSON_SERIALIZE_ENUM(Topology
	{TopologyType::Unknown, "Unknown"},
	{TopologyType::Pipeline, "Pipeline"},
	{TopologyType::Tree, "True"},
	{TopologyType::Graph, "Graph"},</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 64-69</strong></td>
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 22-27[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #</code></td>
          <td>	<code>_, fname = os.path.split(filename)
	document_name = fname.split(".")[0]
	App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 177-190</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 190-204[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbVE=aVEs.Length();
	for (j=0; j<aNbVE; ++j) {
	BOPDS_InterfVE& aVE=aVEs(j);
	if (aVE.Contains(i)) {
	myLSON.Append(aV);
	iFound=1;
	break;
	}
	}
	if (iFound) {
	continue;
	}
	// 3
	aNbVF=aVFs.Length();
	</code></td>
          <td>	<code>aNbVF=aVFs.Length();
	for (j=0; j<aNbVF; ++j) {
	BOPDS_InterfVF& aVF=aVFs(j);
	if (aVF.Contains(i)) {
	myLSON.Append(aV);
	iFound=1;
	break;
	}
	}
	if (iFound) {
	continue;
	}
	//
	// 4
	aP3D=BRep_Tool::Pnt(aV);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 33-39</strong></td>
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 51-57[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>if(MSVC)
	target_compile_options(MyGeom PRIVATE
	else()
	# OCCT has lots of error msg for -Wco
	target_compile_options(MyGeom PRIVATE
	# remove this flag for the moment `-W
	endif()</code></td>
          <td>	<code>if(MSVC)
	target_compile_options(MyGeomMain PRI
	else()
	# OCCT has lots of error msg for -Wco
	target_compile_options(MyGeomMain PRI
	# remove this flag for the moment `-W
	endif()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.hxx: line 28-66</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.hxx: line 25-59[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ClsfBox_HeaderFile
	#define _GEOMAlgo_ClsfBox_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	
	#include <TopoDS_Shape.hxx>
	#include <GeomAdaptor_Surface.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	#include <Standard_Boolean.hxx>
	#include <Geom_Curve.hxx>
	#include <Geom_Surface.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfBox
	
	//=====================================
	//function : GEOMAlgo_ClsfBox
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfBox : public GEOMAlg
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfBox();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfBox();
	
	Standard_EXPORT
	void SetBox(const TopoDS_Shape& aS) ;
	
	Standard_EXPORT
	const TopoDS_Shape& Box() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ClsfSolid_HeaderFile
	#define _GEOMAlgo_ClsfSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	#include <TopoDS_Shape.hxx>
	#include <Standard_Address.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfSol
	
	//=====================================
	//class : GEOMAlgo_ClsfSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)
	
	Standard_EXPORT
	const TopoDS_Shape& Shape() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 19-20</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 173-176[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	def makeBoxCubes(doc, N=3):
	
	</code></td>
          <td>	<code>#######################################
	
	
	def generate_config_file(config_file_co</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.hxx: line 25-59</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.hxx: line 28-66[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ClsfSolid_HeaderFile
	#define _GEOMAlgo_ClsfSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	#include <TopoDS_Shape.hxx>
	#include <Standard_Address.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfSol
	
	//=====================================
	//class : GEOMAlgo_ClsfSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)
	
	Standard_EXPORT
	const TopoDS_Shape& Shape() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;
	
	
	
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ClsfBox_HeaderFile
	#define _GEOMAlgo_ClsfBox_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	
	#include <TopoDS_Shape.hxx>
	#include <GeomAdaptor_Surface.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	#include <Standard_Boolean.hxx>
	#include <Geom_Curve.hxx>
	#include <Geom_Surface.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfBox
	
	//=====================================
	//function : GEOMAlgo_ClsfBox
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfBox : public GEOMAlg
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfBox();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfBox();
	
	Standard_EXPORT
	void SetBox(const TopoDS_Shape& aS) ;
	
	Standard_EXPORT
	const TopoDS_Shape& Box() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 564-576</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 638-651[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Pnt aPC[3], aPc;
	TopoDS_Edge aE;
	TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfName aKNE;
	GEOMAlgo_KindOfClosed aKCE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {
	</code></td>
          <td>	<code>TopoDS_Iterator aIt;
	TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfShape aKSE;
	GEOMAlgo_KindOfName aKNE;
	GEOMAlgo_KindOfClosed aKCE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/WorkflowController.h: line 10-20</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 67-76[57]</strong></td>
        </tr>
        <tr>
          <td>	<code>Unknown = 0, ///< default value, unko
	Pipeline = 1, ///< single data source
	Tree = 2, ///< single data source, mu
	Graph = 3 ///< Directed acyclic graph
	};
	
	NLOHMANN_JSON_SERIALIZE_ENUM(Topology
	{TopologyType::Unknown, "Unknown"},
	{TopologyType::Pipeline, "Pipeline"},
	{TopologyType::Tree, "True"},
	{TopologyType::Graph, "Graph"},</code></td>
          <td>	<code>Wire = TopAbs_WIRE,
	Face = TopAbs_FACE,
	Edge = TopAbs_EDGE,
	Vertex = TopAbs_VERTEX
	};
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeTyp
	{ShapeType::Shape, "Shape"},
	{ShapeType::Compound, "Compound"},
	{ShapeType::CompSolid, "CompSolid"},
	{ShapeType::Solid, "Solid"},
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 355-361</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 242-249[56]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLS=pSS->
	aIt.Initialize(aLS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSImage=aIt.Value
	if (myImages.IsBound(aSImage)) {
	const TopoDS_Shape& aSx=myImages.Find
	myMSS.Add(aSx, aSts[i]);
	</code></td>
          <td>	<code>TopExp::MapShapes(aC, aMx);
	// 2. Add them to aC
	aIt.Initialize(aLSP);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();
	if (myImages.IsBound(aS)) {
	const TopTools_ListOfShape& aLSIm=myI
	aItIm.Initialize(aLSIm);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 375-389</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 447-462[56]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	//
	FillDetails(aF, aSphere);
	}// else if (aST==GeomAbs_Sphere) {
	//
	else if (aST==GeomAbs_Cylinder) {
	gp_Cylinder aCyl;
	//
	aCyl=aGAS.Cylinder();
	aP0=aCyl.Location();
	aAx3=aCyl.Position();
	aR1=aCyl.Radius();
	</code></td>
          <td>	<code>dV=(aVMax-aVMin)*cos(aSemiAngle);
	
	aInfo.SetHeight(dV);
	//
	FillDetails(aF, aCone);
	}
	// 5. Torus
	else if (aST==GeomAbs_Torus) {
	gp_Torus aTorus;
	//
	aTorus=aGAS.Torus();
	aP0=aTorus.Location();
	aAx3=aTorus.Position();
	aR1=aTorus.MajorRadius();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 157-173</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 130-146[56]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean HasImage(const TopoD
	
	Standard_EXPORT
	void MakeBRepShapes(const TopoDS_Shap
	TopoDS_Shape& theSnew) ;
	
	Standard_EXPORT
	void MakeEdge(const TopoDS_Edge& theE
	TopoDS_Edge& theEnew) ;
	
	Standard_EXPORT
	void MakeFace(const TopoDS_Face& theF
	TopoDS_Face& theFnew) ;
	
	Standard_EXPORT
	void TreatPair(const GEOMAlgo_CoupleO
	GEOMAlgo_ListOfCoupleOfShapes& theLCS</code></td>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void FacePassKey(const TopoDS_Face& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void MakeVertex(const TopTools_ListOf
	TopoDS_Vertex& aNewV) ;
	
	Standard_EXPORT
	void MakeEdge(const TopoDS_Edge& aEdg
	TopoDS_Edge& aNewEdge) ;
	
	Standard_EXPORT
	void MakeFace(const TopoDS_Face& aFac
	TopoDS_Face& aNewEdge) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 163-167</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 228-238[55]</strong></td>
        </tr>
        <tr>
          <td>	<code>CollisionInfo() = default;
	};
	inline void to_json(json& j, const Co
	{
	j = json{{"firstIndex", p.first}, {"s
	
	
	
	
	
	</code></td>
          <td>	<code>GeometryProperty() = default;
	// GeometryProperty(GeometryProperty&
	};
	
	/// enable automatic data conversion
	/// https://github.com/nlohmann/json#
	/// from_json() may not safe, use wit
	inline void to_json(json& j, const Ge
	{
	j = json{{"volume", p.volume}, {"area
	{"perimeter", p.perimeter}, {"toleran</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 240-247</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 208-217[55]</strong></td>
        </tr>
        <tr>
          <td>	<code>{"edgeCount", p.edgeCount}, {"centerO
	}
	
	inline void from_json(const json& j,
	{
	j.at("volume").get_to(p.volume);
	j.at("area").get_to(p.area);
	j.at("perimeter").get_to(p.perimeter)
	
	</code></td>
          <td>	<code>}
	}
	
	/// TODO: not working, can not create
	inline void from_json(const json& j,
	{
	j.at("name").get_to(p.name);
	j.at("type").get_to(p.type);
	// j.at("data").get_to(p.data);
	j.at("flag").get_to(p.flag); // enum</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 21-38</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 87-104[55]</strong></td>
        </tr>
        <tr>
          <td>	<code># --- headers ---
	
	SET(GEOMAlgo_HEADERS
	GEOMAlgo_Algo.hxx
	GEOMAlgo_AlgoTools.hxx
	GEOMAlgo_BndSphere.hxx
	GEOMAlgo_BndSphereTree.hxx
	GEOMAlgo_BoxBndTree.hxx
	GEOMAlgo_Clsf.hxx
	GEOMAlgo_ClsfBox.hxx
	GEOMAlgo_ClsfQuad.hxx
	GEOMAlgo_ClsfSolid.hxx
	GEOMAlgo_ClsfSurf.hxx
	GEOMAlgo_CoupleOfShapes.hxx
	GEOMAlgo_DataMapIteratorOfDataMapOfPa
	GEOMAlgo_DataMapOfPassKeyInteger.hxx
	GEOMAlgo_DataMapOfShapeMapOfShape.hxx
	GEOMAlgo_DataMapOfShapePnt.hxx</code></td>
          <td>	<code># --- sources ---
	
	SET(GEOMAlgo_SOURCES
	GEOMAlgo_Algo.cxx
	GEOMAlgo_AlgoTools.cxx
	GEOMAlgo_AlgoTools_1.cxx
	GEOMAlgo_BndSphere.cxx
	GEOMAlgo_BndSphereTree.cxx
	GEOMAlgo_BoxBndTree.cxx
	GEOMAlgo_BuilderShape.cxx
	GEOMAlgo_Clsf.cxx
	GEOMAlgo_ClsfBox.cxx
	GEOMAlgo_ClsfQuad.cxx
	GEOMAlgo_ClsfSolid.cxx
	GEOMAlgo_ClsfSurf.cxx
	GEOMAlgo_CoupleOfShapes.cxx
	GEOMAlgo_FinderShapeOn2.cxx
	GEOMAlgo_Extractor.cxx</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 207-231</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 244-268[55]</strong></td>
        </tr>
        <tr>
          <td>	<code>Intersect();
	if (myErrorStatus) {
	return;
	}
	//
	PerformVV();
	if (myErrorStatus) {
	return;
	}
	//
	FillEdgesOn(myArgument);
	FillEdgesOn(myShapeWhere);
	if (myErrorStatus) {
	return;
	}
	//
	PerformVE();
	if (myErrorStatus) {
	return;
	}
	//
	PerformEE();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>PerformEF();
	if (myErrorStatus) {
	return;
	}
	//
	PerformFF();
	if (myErrorStatus) {
	return;
	}
	//
	FillSolidsOn(myArgument);
	FillSolidsOn(myShapeWhere);
	if (myErrorStatus) {
	return;
	}
	//
	PerformZF();
	if (myErrorStatus) {
	return;
	}
	//
	PerformZZ();
	if (myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 208-217</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 240-247[55]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	
	/// TODO: not working, can not create
	inline void from_json(const json& j,
	{
	j.at("name").get_to(p.name);
	j.at("type").get_to(p.type);
	// j.at("data").get_to(p.data);
	j.at("flag").get_to(p.flag); // enum</code></td>
          <td>	<code>{"edgeCount", p.edgeCount}, {"centerO
	}
	
	inline void from_json(const json& j,
	{
	j.at("volume").get_to(p.volume);
	j.at("area").get_to(p.area);
	j.at("perimeter").get_to(p.perimeter)
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 435-443</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 368-376[55]</strong></td>
        </tr>
        <tr>
          <td>	<code>myResult=aCmp;
	//
	// check alone solids
	TopExp::MapShapes(myShape, TopAbs_SOL
	//
	aNbX=aMx.Extent();
	for (i=1; i<=aNbX; ++i) {
	const TopoDS_Shape& aSx=aMx(i);
	if (!aMS.Contains(aSx)) {</code></td>
          <td>	<code>myWarningStatus=0;
	//
	TopExp::MapShapes(myArgument, theType
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);
	//
	if (!aMFence.Add(aE)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 199-204</strong></td>
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 228-233[54]</strong></td>
        </tr>
        <tr>
          <td>	<code>#if PPP_BUILD_TYPE
	std::shared_ptr<Processor> reader = c
	#else
	std::shared_ptr<Reader> reader = std:
	#endif
	reader->setConfig(myConfig["readers"]</code></td>
          <td>	<code>#if PPP_BUILD_TYPE
	std::shared_ptr<Processor> writer = c
	#else
	std::shared_ptr<Writer> writer = std:
	#endif
	writer->setConfig(myConfig["writers"]</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 726-734</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 874-882[54]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNbS2;
	TopTools_MapOfShape aMSX;
	TopTools_IndexedMapOfShape aMS2;
	//
	bHasOnF=myShapesOn.IsBound(theF1);
	const TopTools_MapOfShape& aMSOnF=(bH
	//
	bHasInF=myShapesIn.IsBound(theF1);
	const TopTools_MapOfShape& aMSInF=(bH</code></td>
          <td>	<code>Standard_Integer i, aNbS2, iCntOn, iC
	TopTools_MapOfShape aMSX;
	TopTools_IndexedMapOfShape aMS2;
	//
	bHasOn=myShapesOn.IsBound(theSo1);
	const TopTools_MapOfShape& aMSOn=(bHa
	//
	bHasIn=myShapesIn.IsBound(theSo1);
	const TopTools_MapOfShape& aMSIn=(bHa</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 622-633</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 691-702[53]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myMapModified.IsBound(aSubShape))
	// This is a modified sub-shape.
	TopTools_ListOfShape aModifSubShapes;
	
	getModified(aSubShape, aModifSubShape
	
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient
	
	if (isToCreate) {</code></td>
          <td>	<code>if (myMapModified.IsBound(aSubShape))
	TopTools_ListOfShape aModifList;
	
	getModified(aSubShape, aModifList);
	
	// Copy shapes to the list of other s
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient
	
	if (aNewShape.ShapeType() == aSubShap</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 126-132</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 134-140[53]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline const std::optional<Quantity_C
	{
	if (myColorMap->find((*myShapeIDs)[in
	return (*myColorMap)[(*myShapeIDs)[in
	else
	return std::nullopt;
	}</code></td>
          <td>	<code>inline const std::optional<Material>
	{
	if (myMaterialMap->find((*myShapeIDs)
	return (*myMaterialMap)[(*myShapeIDs)
	else
	return std::nullopt;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 67-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 93-104[53]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	// loop on quadrangle sides
	myPlanes.reserve( 4 );
	for ( int i = 0; i < 4; ++i )
	{
	// point1 -> point2 vector
	gp_Vec aSideVec( myPoints[ i ], myPoi
	//std::cout<<" Y Vec : "<<aSideVec.X(
	
	// plane normal
	gp_Vec aSideNorm = aSideVec ^ myQuadN
	if ( aSideNorm.SquareMagnitude() <= D</code></td>
          <td>	<code>}
	
	// loop on quadrangle sides
	myPlanes.reserve( 4 );
	
	for ( int i = 0; i < 4; ++i ) {
	// point1 -> point2 vector
	gp_Vec aSideVec( myPoints[ i ], myPoi
	
	// plane normal
	gp_Vec aSideNorm = aSideVec ^ myQuadN
	if (aSideNorm.SquareMagnitude() <= DB
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 93-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 67-79[53]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	// loop on quadrangle sides
	myPlanes.reserve( 4 );
	
	for ( int i = 0; i < 4; ++i ) {
	// point1 -> point2 vector
	gp_Vec aSideVec( myPoints[ i ], myPoi
	
	// plane normal
	gp_Vec aSideNorm = aSideVec ^ myQuadN
	if (aSideNorm.SquareMagnitude() <= DB
	</code></td>
          <td>	<code>}
	
	// loop on quadrangle sides
	myPlanes.reserve( 4 );
	for ( int i = 0; i < 4; ++i )
	{
	// point1 -> point2 vector
	gp_Vec aSideVec( myPoints[ i ], myPoi
	//std::cout<<" Y Vec : "<<aSideVec.X(
	
	// plane normal
	gp_Vec aSideNorm = aSideVec ^ myQuadN
	if ( aSideNorm.SquareMagnitude() <= D</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.hxx: line 58-74</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.hxx: line 60-76[53]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Handle(Geom_Surface)& Surface()
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
          <td>	<code>const TopoDS_Shape& Box() const;
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 61-71</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 40-50[52]</strong></td>
        </tr>
        <tr>
          <td>	<code>myPoints.resize(6);
	myPoints[0] = theTopLeftPoint;
	myPoints[1] = theTopRightPoint;
	myPoints[2] = theBottomRightPoint;
	myPoints[3] = theBottomLeftPoint;
	myPoints[4] = myPoints[0];
	myPoints[5] = myPoints[1];
	
	// Find plane normal defined by corne
	// a plane for each quadrangle side.
	myQuadNormal.SetCoord (0., 0., 0.);</code></td>
          <td>	<code>myPoints.resize(6);
	myPoints[0] = theTopLeftPoint ;
	myPoints[1] = theTopRightPoint ;
	myPoints[2] = theBottomRightPoint;
	myPoints[3] = theBottomLeftPoint ;
	myPoints[4] = myPoints[0];
	myPoints[5] = myPoints[1];
	
	// Find plane normal defined by corne
	// for each quadrangle side.
	myQuadNormal.SetCoord (0,0,0);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 513-518</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 570-574[52]</strong></td>
        </tr>
        <tr>
          <td>	<code>bHasOn=myShapesOn.IsBound(theE1);
	bHasIn=myShapesIn.IsBound(theE1);
	const TopTools_MapOfShape& aMSOn=(bHa
	const TopTools_MapOfShape& aMSIn=(bHa
	bFound=Standard_True;</code></td>
          <td>	<code>bHasOn=myShapesOn.IsBound(aE1);
	bHasIn=myShapesIn.IsBound(aE1);
	const TopTools_MapOfShape& aMSOn=(bHa
	const TopTools_MapOfShape& aMSIn=(bHa
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 458-466</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 414-422[52]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbF=aM.Extent();
	for (i=1; i<=aNbF; ++i) {
	GEOMAlgo_StateCollector aSC;
	GEOMAlgo_ListOfPnt aLP;
	//
	const TopoDS_Face& aF=TopoDS::Face(aM
	//
	if (myState==GEOMAlgo_ST_ON) {
	Handle(Geom_Surface) aS;</code></td>
          <td>	<code>aNbF=aM.Extent();
	for (i=1; i<=aNbF; ++i) {
	GEOMAlgo_StateCollector aSC;
	GEOMAlgo_ListOfPnt aLP;
	//
	const TopoDS_Face& aF=TopoDS::Face(aM
	//
	if (myState==GEOMAlgo_ST_ON) {
	Handle(Geom_Surface) aS;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 402-413</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 410-420[52]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK)
	{
	Standard_Integer i, aNbE;
	TopoDS_Shape aER;
	TopTools_ListOfShape aLE;
	TopTools_IndexedMapOfShape aME;
	//
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);</code></td>
          <td>	<code>void GEOMAlgo_GetInPlace::FillEdgesOn(c
	{
	Standard_Integer i, aNbE;
	TopoDS_Iterator aIt;
	TopTools_IndexedMapOfShape aME;
	TopTools_MapIteratorOfMapOfShape aItM
	//
	TopExp::MapShapes(theShape, TopAbs_ED
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 410-420</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 402-413[52]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_GetInPlace::FillEdgesOn(c
	{
	Standard_Integer i, aNbE;
	TopoDS_Iterator aIt;
	TopTools_IndexedMapOfShape aME;
	TopTools_MapIteratorOfMapOfShape aItM
	//
	TopExp::MapShapes(theShape, TopAbs_ED
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge
	</code></td>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK)
	{
	Standard_Integer i, aNbE;
	TopoDS_Shape aER;
	TopTools_ListOfShape aLE;
	TopTools_IndexedMapOfShape aME;
	//
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 47-49</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 393-395[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>)
	
	########################### Geom specif</code></td>
          <td>	<code>config_file_name = generate_config_file
	
	########################### module spec</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 714-717</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 717-720[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>sout << " ======= input geometry summ
	sout << " length of solids: " << mySo
	sout << " length of shells: " << mySh
	sout << " length of compounds: " << m</code></td>
          <td>	<code>sout << " length of compounds: " << m
	sout << " length of name map: " << my
	sout << " length of color map: " << m
	sout << " length of material map: " <</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 359-371</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 282-293[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS1=aMS1(i);
	//
	if (aDMSLS.IsBound(aS1)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aS2);
	}
	else {
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS2);
	aDMSLS.Bind(aS1, aLS);
	}
	}</code></td>
          <td>	<code>const TopoDS_Shape& aSkey=myOriginsDe
	if (aDMSLS.IsBound(aSkey)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aSS1);
	}
	else {
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aSS1);
	aDMSLS.Bind(aSkey, aLS);
	}
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 122-125</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 277-280[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif(PPP_USE_PYTHON)
	
	
	#######################################</code></td>
          <td>	<code>App.closeDocument(document_name)
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 79-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 198-225[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeInfoFiller::SetToler
	{
	myTolerance=aT;
	}
	//=====================================
	//function : Tolerance
	//purpose :
	//=====================================
	Standard_Real GEOMAlgo_ShapeInfoFiller:
	{
	return myTolerance;
	}
	//=====================================
	//function : SetShape
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetShape
	{
	myShape=aS;
	}
	//=====================================
	//function : Shape
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ShapeInfoF
	{
	return myShape;
	}</code></td>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetKindOfDef(c
	{
	myKindOfDef=aT;
	}
	//=====================================
	//function : KindOfDef
	//purpose :
	//=====================================
	GEOMAlgo_KindOfDef GEOMAlgo_ShapeInfo::
	{
	return myKindOfDef;
	}
	//=====================================
	//function : SetLocation
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetLocation(co
	{
	myLocation=aP;
	}
	//=====================================
	//function : Location
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Locat
	{
	return myLocation;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 793-797</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 161-165[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShapesIn.IsBound(aF1)) {
	const TopTools_MapOfShape& aMSIn=mySh
	aItMS.Initialize(aMSIn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();</code></td>
          <td>	<code>if (myImages.IsBound(aS)) {
	const TopTools_ListOfShape& aLSIm=myI
	aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 277-280</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 122-125   [51]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.closeDocument(document_name)
	
	
	#######################################</code></td>
          <td>	<code>endif(PPP_USE_PYTHON)
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 117-137</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 107-127[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>void MakeShapes(const TopAbs_ShapeEnu
	
	Standard_EXPORT
	void MakeShells() ;
	
	Standard_EXPORT
	void MakeSolids() ;
	
	Standard_EXPORT
	void InnerTolerance() ;
	
	Standard_EXPORT
	void EdgePassKey(const TopoDS_Edge& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void FacePassKey(const TopoDS_Face& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void MakeVertex(const TopTools_ListOf</code></td>
          <td>	<code>void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a
	GEOMAlgo_ListOfPnt& aLP) ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Edge& a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 810-819</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 832-842[51]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomAbs_BSplineCurve
	};
	//
	bRet=Standard_False;
	aNb=sizeof(aTypes)/sizeof(aTypes[0]);
	for (i=0; i<aNb && !bRet; ++i) {
	bRet=(aCT==aTypes[i]);
	}
	return bRet;
	}
	</code></td>
          <td>	<code>GeomAbs_Torus
	};
	//
	bRet=Standard_False;
	aNb=sizeof(aTypes)/sizeof(aTypes[0]);
	for (i=0; i<aNb && !bRet; ++i) {
	bRet=(aST==aTypes[i]);
	}
	//
	return bRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 151-159</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 188-196[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_State aSt;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(</code></td>
          <td>	<code>Standard_Integer i, aNb;
	TopTools_ListOfShape* pL;
	//
	pL=(TopTools_ListOfShape*) &myLS;
	pL->Clear();
	//
	aNb=myMSS.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=myMSS.FindKey(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1028-1033</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1055-1061[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myImages.IsBound(aSubS)) {
	const TopTools_ListOfShape& aLSi = my
	TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSubSi = aItLS.Va
	</code></td>
          <td>	<code>if (myImages.IsBound(aSWhere)) {
	// Remove inclusive shapes from aMapR
	const TopTools_ListOfShape& aLWhat =
	TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSWhat = aItLS.Va</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 67-83</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.hxx: line 58-74[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Pnt &theBottomRightPoint) const;
	
	Standard_EXPORT
	virtual void Perform();
	
	Standard_EXPORT
	virtual void CheckData();
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
          <td>	<code>const Handle(Geom_Surface)& Surface()
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/setup.py: line 75-76</strong></td>
        <td style="text-align:center"><strong>src/python/setup.py: line 94-95    [50]</strong></td>
        </tr>
        <tr>
          <td>	<code>ext_output_path = os.path.dirname(os.
	ppp_extensions = glob.glob(ext_output</code></td>
          <td>	<code>lib_output_path = os.path.dirname(os.
	ppp_libraries = glob.glob(lib_output_</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 190-216</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 264-288[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>return bOk;
	}
	//=====================================
	//
	//=====================================
	//function : PntInEdge
	//purpose :
	//=====================================
	Standard_Integer PntInEdge(const TopoDS
	gp_Pnt& aP)
	
	{
	Standard_Integer iErr;
	Standard_Real aT;
	//
	iErr=PntInEdge(aE, aP, aT);
	//
	return iErr;
	}
	//=====================================
	//function : PntInEdge
	//purpose :
	//=====================================
	Standard_Integer PntInEdge(const TopoDS
	gp_Pnt& aP,
	Standard_Real& aT)
	{</code></td>
          <td>	<code>return iErr;
	}
	//=====================================
	//function : PntInFace
	//purpose :
	//=====================================
	Standard_Integer PntInFace(const TopoDS
	gp_Pnt& aP)
	{
	Standard_Integer iErr;
	//
	gp_Pnt2d aP2Dx;
	//
	iErr=PntInFace(aF, aP, aP2Dx);
	//
	return iErr;
	}
	//=====================================
	//function : PntInFace
	//purpose :
	//=====================================
	Standard_Integer PntInFace(const TopoDS
	gp_Pnt& theP,
	gp_Pnt2d& theP2D)
	{
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 195-200</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 372-377[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfName(aKNF);
	aInfo.SetLocation(aInfoF.Location());
	aInfo.SetPosition(aInfoF.Position());
	aInfo.SetRadius1(aInfoF.Radius1());
	aInfo.SetRadius2(aInfoF.Radius2());
	aInfo.SetHeight(aInfoF.Height());</code></td>
          <td>	<code>aInfo.SetKindOfName(aKN);
	aInfo.SetRadius1(aInfoE.Radius1());
	aInfo.SetRadius2(aInfoE.Radius2());
	aInfo.SetLocation(aInfoE.Location());
	aInfo.SetPosition(aInfoE.Position());
	aInfo.SetKindOfDef(GEOMAlgo_KD_SPECIF</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 171-195</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 196-220[50]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	//
	FillVertices();
	if (myErrorStatus) {
	return;
	}
	//
	FillEdges();
	if (myErrorStatus) {
	return;
	}
	//
	FillWires();
	if (myErrorStatus) {
	return;
	}
	//
	FillFaces();
	if (myErrorStatus) {
	return;
	}
	//
	FillShells();
	if (myErrorStatus) {</code></td>
          <td>	<code>return;
	}
	//
	FillSolids();
	if (myErrorStatus) {
	return;
	}
	//
	FillCompSolids();
	if (myErrorStatus) {
	return;
	}
	//
	FillCompounds();
	if (myErrorStatus) {
	return;
	}
	//
	BuildResult();
	if (myErrorStatus) {
	return;
	}
	//
	PrepareHistory();
	if (myErrorStatus) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 108-108</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 1-1[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>##################### install #########</code></td>
          <td>	<code>################################# help</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 57-63</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 176-184[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>void saveAssemblyToStepFile(const Top
	{
	Handle(XCAFApp_Application) hApp = XC
	Handle(TDocStd_Document) aDoc;
	hApp->NewDocument(TCollection_Extende
	
	Handle(XCAFDoc_ShapeTool) shapeTool =
	
	</code></td>
          <td>	<code>Handle(TDocStd_Document) createDocume
	{
	
	Handle(XCAFApp_Application) hApp = XC
	
	Handle(TDocStd_Document) newDoc; // t
	/// NOTE: "MDTV-CAF" is deprecated, r
	hApp->NewDocument(TCollection_Extende
	Handle(XCAFDoc_ShapeTool) shapeTool =</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 445-451</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 603-609[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>aWnew.Orientation(aW.Orientation());
	//
	aItS.Initialize(aW);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aE=aItS.Value();
	if (myOrigins.IsBound(aE)) {
	aEnew=myOrigins.Find(aE);</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();
	if (myOrigins.IsBound(aCX)) {
	aCXnew=myOrigins.Find(aCX);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 275-284</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 860-869[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGC+=aP3D.XYZ();
	}
	aGC/=(Standard_Real)aNbV;
	aPGC.SetXYZ(aGC);
	//
	// tolerance value
	aDmax=-1.;
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=*((TopoDS_Vertex*)(&aIt.Value()))</code></td>
          <td>	<code>aGC+=aP3D.XYZ();
	}
	aGC/=(Standard_Real)aNbV;
	aPGC.SetXYZ(aGC);
	//
	// tolerance value
	aDmax=-1.;
	aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=TopoDS::Vertex(aIt.Value());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 603-608</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 640-645[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();
	if (myOrigins.IsBound(aCX)) {</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::PointOnShape(aE1,
	//
	aIt.Initialize(aLE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aE2=aIt.Value();
	if (aE2.IsSame(aE1)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 242-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 603-608[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(aC, aMx);
	// 2. Add them to aC
	aIt.Initialize(aLSP);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();
	if (myImages.IsBound(aS)) {</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();
	if (myOrigins.IsBound(aCX)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeProcessedResult.py: line 137-140</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 40-43     [49]</strong></td>
        </tr>
        <tr>
          <td>	<code>print(f"{log_filename} does not exist
	
	
	#######################################</code></td>
          <td>	<code>add_subdirectory("PPP")
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 135-160</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 120-145[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}
	//
	DetectFaces();
	if (myErrorStatus) {
	return;
	}
	//
	DetectSolids();
	if (myErrorStatus) {
	return;
	}
	}
	//=====================================
	//function : DetectVertices
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectVer
	{</code></td>
          <td>	<code>DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	CheckDetected();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}
	//
	DetectFaces();
	if (myErrorStatus) {
	return;
	}
	}
	//=====================================
	//function : DetectVertices
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectVerti
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShapeMapHasher.cxx: line 34-47</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyMapHasher.cxx: line 34-47[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer GEOMAlgo_PassKeyShap
	const Standard_Integer Upper)
	{
	return aPK.HashCode(Upper);
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyShap
	const GEOMAlgo_PassKeyShape& aPK2)
	{
	return aPK1.IsEqual(aPK2);
	}</code></td>
          <td>	<code>Standard_Integer GEOMAlgo_PassKeyMapH
	const Standard_Integer Upper)
	{
	return aPK.HashCode(Upper);
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyMapH
	const GEOMAlgo_PassKey& aPK2)
	{
	return aPK1.IsEqual(aPK2);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 720-726</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 559-566[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>aMFS.Clear();
	TopExp::MapShapes(aSolid, TopAbs_FACE
	//
	bFound=Standard_False;
	aNbFS=aMFS.Extent();
	for (j=1; j<=aNbFS; ++j) {
	const TopoDS_Shape& aFS=aMFS(j);
	</code></td>
          <td>	<code>aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 40-43</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeProcessedResult.py: line 137-140[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>add_subdirectory("PPP")
	
	
	#######################################</code></td>
          <td>	<code>print(f"{log_filename} does not exist
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 176-184</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 57-63  [49]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(TDocStd_Document) createDocume
	{
	
	Handle(XCAFApp_Application) hApp = XC
	
	Handle(TDocStd_Document) newDoc; // t
	/// NOTE: "MDTV-CAF" is deprecated, r
	hApp->NewDocument(TCollection_Extende
	Handle(XCAFDoc_ShapeTool) shapeTool =</code></td>
          <td>	<code>void saveAssemblyToStepFile(const Top
	{
	Handle(XCAFApp_Application) hApp = XC
	Handle(TDocStd_Document) aDoc;
	hApp->NewDocument(TCollection_Extende
	
	Handle(XCAFDoc_ShapeTool) shapeTool =
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 51-52</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 237-239[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>return json{{"type", p.type}, {"name"
	{"range", p.range}, {"unit", p.unit},
	</code></td>
          <td>	<code>j = json{{"volume", p.volume}, {"area
	{"perimeter", p.perimeter}, {"toleran
	{"solidCount", p.solidCount}, {"faceC</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 170-173</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 124-126[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>print("failed to create symbolic link
	
	
	#######################################</code></td>
          <td>	<code>s = check_similarity(bbox, bbox1)
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyMapHasher.cxx: line 34-47</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShapeMapHasher.cxx: line 34-47[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer GEOMAlgo_PassKeyMapH
	const Standard_Integer Upper)
	{
	return aPK.HashCode(Upper);
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyMapH
	const GEOMAlgo_PassKey& aPK2)
	{
	return aPK1.IsEqual(aPK2);
	}</code></td>
          <td>	<code>Standard_Integer GEOMAlgo_PassKeyShap
	const Standard_Integer Upper)
	{
	return aPK.HashCode(Upper);
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyShap
	const GEOMAlgo_PassKeyShape& aPK2)
	{
	return aPK1.IsEqual(aPK2);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 780-785</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 724-728[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF1=aMF(j);
	//
	if (myShapesOn.IsBound(aF1)) {
	const TopTools_MapOfShape& aMSOn=mySh</code></td>
          <td>	<code>aNbFS=aMFS.Extent();
	for (j=1; j<=aNbFS; ++j) {
	const TopoDS_Shape& aFS=aMFS(j);
	if (aMFR.Contains(aFS)) {
	const TopTools_ListOfShape& aLSx=aMFR
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 326-336</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 480-490[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	aItDMSLS.Initialize(myImagesToWork);
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke
	aType=aSkey.ShapeType();
	if (aType!=TopAbs_VERTEX) {</code></td>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopoDS_Iterator aItC;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();
	aType=aCx.ShapeType();
	if (aType==TopAbs_COMPOUND) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 523-531</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 608-616[49]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myOrigins.IsBound(aCX)) {
	aCXnew=myOrigins.Find(aCX);
	aCXnew.Orientation(aCX.Orientation())
	aBB.Add(aCnew, aCXnew);
	}
	else {
	aBB.Add(aCnew, aCX);
	}
	}</code></td>
          <td>	<code>if (myOrigins.IsBound(aCX)) {
	aCXnew=myOrigins.Find(aCX);
	aCXnew.Orientation(aCX.Orientation())
	aBB.Add(aCnew, aCXnew);
	}
	else {
	aBB.Add(aCnew, aCX);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 80-86</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 93-99 [49]</strong></td>
        </tr>
        <tr>
          <td>	<code>bool hasElement(const size_t row, con
	{
	if (mat.size() >= row)
	{
	for (const auto& it : (*mat[row]))
	{
	if (col == it.first)</code></td>
          <td>	<code>T getElement(const size_t row, const
	{
	if (mat.size() >= row)
	{
	for (const auto& it : (*mat[row]))
	{
	if (col == it.first)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 497-510</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 122-135[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_DataMapOfShapeShape& aImages
	TopTools_DataMapOfShapeShape& aOrigin
	TopoDS_Shape& aEx)
	{
	Standard_Boolean bFree;
	TopAbs_ShapeEnum aType;
	Standard_Integer aR;
	BRep_Builder BB;
	TopoDS_Iterator aIt;
	//
	aType=aE.ShapeType();
	//
	if (aOriginals.IsBound(aE)) {
	aEx=aOriginals.ChangeFind(aE);</code></td>
          <td>	<code>void CopySource(const TopoDS_Shape& aS,
	TopTools_IndexedDataMapOfShapeShape&
	TopoDS_Shape& aSC)
	{
	Standard_Boolean bFree;
	TopAbs_ShapeEnum aT;
	TopoDS_Iterator aIt;
	TopoDS_Shape aSF;
	BRep_Builder BB;
	//
	aT=aS.ShapeType();
	//
	if (aMapSS.Contains(aS)) {
	aSC=aMapSS.ChangeFromKey(aS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 533-544</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 596-607[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_Orientation anOr;
	TopoDS_Shell aNewShell;
	TopoDS_Face aFR;
	TopTools_IndexedMapOfShape aMS;
	TopExp_Explorer aExp;
	BRep_Builder aBB;
	//
	TopExp::MapShapes(myShape, TopAbs_SHE
	//
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shell& aShell=TopoDS::Sh</code></td>
          <td>	<code>Standard_Integer i, aNbF, aNbSDF, iEr
	TopoDS_Shape aNewShape;
	TopTools_IndexedMapOfShape aMF;
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_PassKeyShape aPKF;
	GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	TopExp::MapShapes(myShape, aType, aMF
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 9-27</strong></td>
        <td style="text-align:center"><strong>src/PPP/TypeDefs.h: line 37-55     [48]</strong></td>
        </tr>
        <tr>
          <td>	<code>using namespace PPP;
	
	/**
	* to specify search input criteria an
	*
	* CONSIDER: boundbox tree may be buil
	* need a relative tolerance like to j
	* */
	enum class ShapeSearchType
	{
	UniqueId, ///!< geometry ID hashed fr
	GeometryFile, ///!< read the geometry
	BoundBox, ///!< axis align bound box,
	};
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeSea
	{ShapeSearchType::UniqueId, "UniqueId
	{ShapeSearchType::GeometryFile, "Geom
	{ShapeSearchType::BoundBox, "BoundBox
	});</code></td>
          <td>	<code>using namespace magic_enum;
	
	/**
	* Processing on CPU should be impleme
	* GPU is not supported yet (tensorflo
	* currently, only CPU is implemented.
	* */
	enum class DevicePreference
	{
	CPU, ///< item count is small, but pr
	GPU, ///< GPU acceleraton, suitable f
	FPGA, ///< good for realtime data pro
	};
	
	NLOHMANN_JSON_SERIALIZE_ENUM(DevicePr
	{DevicePreference::CPU, "CPU"},
	{DevicePreference::GPU, "GPU"},
	{DevicePreference::FPGA, "FPGA"},
	});</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 342-349</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 391-398[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_Gluer2::MakeVertex(aLSD, aVn
	//
	myImages.Bind(aVnew, aLSD);
	//
	aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aV=aItLS.Value();
	myOrigins.Bind(aV, aVnew);</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSD=myIm
	//
	myImages.Bind(aEnew, aLSD);
	//
	aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aEx=aItLS.Value()
	myOrigins.Bind(aEx, aEnew);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 117-135</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 138-157[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillImagesVertices();
	if (HasErrors()) {
	return;
	}
	//
	BuildResult(TopAbs_VERTEX);
	if (HasErrors()) {
	return;
	}
	// 3.2 Edges
	FillImagesEdges();
	if (HasErrors()) {
	return;
	}
	//
	BuildResult(TopAbs_EDGE);
	if (HasErrors()) {
	return;
	}
	</code></td>
          <td>	<code>FillImagesContainers(TopAbs_WIRE);
	if (HasErrors()) {
	return;
	}
	//
	BuildResult(TopAbs_WIRE);
	if (HasErrors()) {
	return;
	}
	
	// 3.4 Faces
	FillImagesFaces();
	if (HasErrors()) {
	return;
	}
	//
	BuildResult(TopAbs_FACE);
	if (HasErrors()) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 122-135</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 497-510[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>void CopySource(const TopoDS_Shape& aS,
	TopTools_IndexedDataMapOfShapeShape&
	TopoDS_Shape& aSC)
	{
	Standard_Boolean bFree;
	TopAbs_ShapeEnum aT;
	TopoDS_Iterator aIt;
	TopoDS_Shape aSF;
	BRep_Builder BB;
	//
	aT=aS.ShapeType();
	//
	if (aMapSS.Contains(aS)) {
	aSC=aMapSS.ChangeFromKey(aS);</code></td>
          <td>	<code>TopTools_DataMapOfShapeShape& aImages
	TopTools_DataMapOfShapeShape& aOrigin
	TopoDS_Shape& aEx)
	{
	Standard_Boolean bFree;
	TopAbs_ShapeEnum aType;
	Standard_Integer aR;
	BRep_Builder BB;
	TopoDS_Iterator aIt;
	//
	aType=aE.ShapeType();
	//
	if (aOriginals.IsBound(aE)) {
	aEx=aOriginals.ChangeFind(aE);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 37-41</strong></td>
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 30-33[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TYPESYSTEM_SOURCE(Geom::GeometryPropert
	TYPESYSTEM_SOURCE(Geom::GeometrySearchB
	TYPESYSTEM_SOURCE(Geom::BoundBoxBuilder
	
	TYPESYSTEM_SOURCE(Geom::CollisionDetect</code></td>
          <td>	<code>TYPESYSTEM_SOURCE(PPP::Processor, Base:
	TYPESYSTEM_SOURCE(PPP::Reader, PPP::Pro
	TYPESYSTEM_SOURCE(PPP::Writer, PPP::Pro
	TYPESYSTEM_SOURCE(PPP::CouplingMatrixBu
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 549-552</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 968-971[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>aExp.Init(aShell, TopAbs_FACE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Face& aF=TopoDS::Face(aE
	aFR=TopoDS::Face(myOrigins.Find(aF));</code></td>
          <td>	<code>aExpE.Init(aW, TopAbs_EDGE);
	for (; aExpE.More(); aExpE.Next()) {
	const TopoDS_Edge& aE=TopoDS::Edge(aE
	aER=TopoDS::Edge(myOrigins.Find(aE));</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 62-71</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 74-83[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape& aMV=aMCV.
	aMV.Add(aF1);
	aMV.Add(aF2);
	}
	else {
	TopTools_IndexedMapOfShape aMV;
	aMV.Add(aF1);
	aMV.Add(aF2);
	aMCV.Add(aF1, aMV);
	}</code></td>
          <td>	<code>TopTools_IndexedMapOfShape& aMV=aMCV.
	aMV.Add(aF1);
	aMV.Add(aF2);
	}
	else {
	TopTools_IndexedMapOfShape aMV;
	aMV.Add(aF1);
	aMV.Add(aF2);
	aMCV.Add(aF2, aMV);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 15-22</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 28-34[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>j = nlohmann::json{xmin, ymin, zmin,
	}
	
	/// Bnd_Box: Standard_Real xmin, ymin,
	inline void from_json(const nlohmann::j
	{
	std::vector<Standard_Real> v = j;
	b.Update(v[0], v[1], v[2], v[3], v[4]</code></td>
          <td>	<code>j = nlohmann::json{p.Red(), p.Green()
	}
	/// json array [R, G, B, A]; Quantity_C
	inline void from_json(const nlohmann::j
	{
	std::vector<Standard_Real> v = j;
	b.SetValues(v[0], v[1], v[2], Quantit
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 30-33</strong></td>
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 32-36      [48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TYPESYSTEM_SOURCE(PPP::Processor, Base:
	TYPESYSTEM_SOURCE(PPP::Reader, PPP::Pro
	TYPESYSTEM_SOURCE(PPP::Writer, PPP::Pro
	TYPESYSTEM_SOURCE(PPP::CouplingMatrixBu
	</code></td>
          <td>	<code>TYPESYSTEM_SOURCE(Geom::GeometryProcess
	TYPESYSTEM_SOURCE(Geom::GeometryReader,
	TYPESYSTEM_SOURCE(Geom::GeometryWriter,
	
	TYPESYSTEM_SOURCE(Geom::GeometryShapeCh</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 154-164</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 165-176[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (aType1==TopAbs_FACE) {
	if (aType2==TopAbs_VERTEX) {
	iRet=3;
	}
	else if (aType2==TopAbs_EDGE) {
	iRet=4;
	}
	else if (aType2==TopAbs_FACE) {
	iRet=5;
	}
	</code></td>
          <td>	<code>}
	// So_1,*_2
	else if (aType1==TopAbs_SOLID) {
	if (aType2==TopAbs_VERTEX) {
	iRet=6;
	}
	else if (aType2==TopAbs_EDGE) {
	iRet=7;
	}
	else if (aType2==TopAbs_FACE) {
	iRet=8;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/TypeDefs.h: line 37-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 9-27[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>using namespace magic_enum;
	
	/**
	* Processing on CPU should be impleme
	* GPU is not supported yet (tensorflo
	* currently, only CPU is implemented.
	* */
	enum class DevicePreference
	{
	CPU, ///< item count is small, but pr
	GPU, ///< GPU acceleraton, suitable f
	FPGA, ///< good for realtime data pro
	};
	
	NLOHMANN_JSON_SERIALIZE_ENUM(DevicePr
	{DevicePreference::CPU, "CPU"},
	{DevicePreference::GPU, "GPU"},
	{DevicePreference::FPGA, "FPGA"},
	});</code></td>
          <td>	<code>using namespace PPP;
	
	/**
	* to specify search input criteria an
	*
	* CONSIDER: boundbox tree may be buil
	* need a relative tolerance like to j
	* */
	enum class ShapeSearchType
	{
	UniqueId, ///!< geometry ID hashed fr
	GeometryFile, ///!< read the geometry
	BoundBox, ///!< axis align bound box,
	};
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeSea
	{ShapeSearchType::UniqueId, "UniqueId
	{ShapeSearchType::GeometryFile, "Geom
	{ShapeSearchType::BoundBox, "BoundBox
	});</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 32-36</strong></td>
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 37-41      [48]</strong></td>
        </tr>
        <tr>
          <td>	<code>TYPESYSTEM_SOURCE(Geom::GeometryProcess
	TYPESYSTEM_SOURCE(Geom::GeometryReader,
	TYPESYSTEM_SOURCE(Geom::GeometryWriter,
	
	TYPESYSTEM_SOURCE(Geom::GeometryShapeCh</code></td>
          <td>	<code>TYPESYSTEM_SOURCE(Geom::GeometryPropert
	TYPESYSTEM_SOURCE(Geom::GeometrySearchB
	TYPESYSTEM_SOURCE(Geom::BoundBoxBuilder
	
	TYPESYSTEM_SOURCE(Geom::CollisionDetect</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 266-278</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 494-507[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//-----------------------------------
	if (myMapInfo.Contains(aS)) {
	return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//-----------------------------------
	aInfo.SetType(TopAbs_SOLID);
	FillNbSubShapes(aS, aInfo);
	</code></td>
          <td>	<code>TopoDS_Edge aE;
	//-----------------------------------
	if (myMapInfo.Contains(aS)) {
	return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//-----------------------------------
	aInfo.SetType(TopAbs_EDGE);
	//
	FillNbSubShapes(aS, aInfo);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 742-747</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 748-753[48]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace("mySolidIDs", s
	myOutputData->emplace("myShapeErrors"
	
	// those three types are not used in
	myOutputData->emplace("myShells", std
	myOutputData->emplace("myCompounds",</code></td>
          <td>	<code>myOutputData->emplace("myOtherShapes"
	
	// STEP214 meta data
	myOutputData->emplace("myColorMap", s
	myOutputData->emplace("myMaterialMap"
	myOutputData->emplace<MapType<ItemHas</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/setup.py: line 89-90</strong></td>
        <td style="text-align:center"><strong>src/python/setup.py: line 94-95    [47]</strong></td>
        </tr>
        <tr>
          <td>	<code>app_output_path = os.path.dirname(os.
	ppp_application = glob.glob(lib_outpu</code></td>
          <td>	<code>lib_output_path = os.path.dirname(os.
	ppp_libraries = glob.glob(lib_output_</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 308-318</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 622-632[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aDMSLS.IsBound(aSkey)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aSS2);
	}
	else {
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aSS2);
	aDMSLS.Bind(aSkey, aLS);
	}
	}</code></td>
          <td>	<code>if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 269-277</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 404-413[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNb;
	gp_Pnt aP;
	TopTools_IndexedMapOfShape aM;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_VER
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	</code></td>
          <td>	<code>Standard_Integer i, aNbE;
	TopoDS_Shape aER;
	TopTools_ListOfShape aLE;
	TopTools_IndexedMapOfShape aME;
	//
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 109-112</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 117-120[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline const std::string itemName(con
	{
	if (myNameMap->find((*myShapeIDs)[ind
	return (*myNameMap)[(*myShapeIDs)[ind</code></td>
          <td>	<code>ShapeErrorType itemError(const ItemIn
	{
	if (myShapeErrors->find((*myShapeIDs)
	return (*myShapeErrors)[(*myShapeIDs)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 160-206</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.hxx: line 63-81[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void SetShapeWhere(const Topo
	
	/**
	* Selector. Returns the shape where t
	* @return
	* The shape where the search is inten
	*/
	Standard_EXPORT
	const TopoDS_Shape& ShapeWhere() cons
	
	/**
	* Modifier. Sets the tolerance of mas
	* @param theTol
	* The value tolerance of mass.
	*/
	Standard_EXPORT
	void SetTolMass(const Standard_Real t
	
	/**
	* Selector. Returns the value toleran
	* @return
	* The value tolerance of mass.
	*/
	Standard_EXPORT
	Standard_Real TolMass() const;
	
	/**
	* Modifier. Sets the tolerance of cen
	* @param theTol
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	void SetTolCG(const Standard_Real the
	
	/**
	* Selector. Returns the tolerance of
	* @return
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	Standard_Real TolCG() const;
	
	/**
	* Perform the algorithm.
	*/
	Standard_EXPORT
	virtual void Perform() ;</code></td>
          <td>	<code>void AddTool(const TopoDS_Shape& theS
	
	Standard_EXPORT
	const TopTools_ListOfShape& Tools()co
	
	Standard_EXPORT
	void SetLimit(const TopAbs_ShapeEnum
	
	Standard_EXPORT
	TopAbs_ShapeEnum Limit()const;
	
	Standard_EXPORT
	void SetLimitMode(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer LimitMode()const;
	
	Standard_EXPORT
	virtual void Clear();
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1129-1139</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 293-303[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShapesOn.IsBound(aS1)) {
	TopTools_MapOfShape& aMS=myShapesOn.C
	aMS.Add(aS2);
	}
	else {
	TopTools_MapOfShape aMS;
	//
	aMS.Add(aS2);
	myShapesOn.Bind(aS1, aMS);
	}
	}</code></td>
          <td>	<code>if (aMPKLF.Contains(aPKF)) {
	TopTools_ListOfShape& aLSDF=aMPKLF.Ch
	aLSDF.Append(aS);
	}
	else {
	TopTools_ListOfShape aLSDF;
	//
	aLSDF.Append(aS);
	aMPKLF.Add(aPKF, aLSDF);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 413-424</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 433-443  [47]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> const T paramet
	{
	Parameter<T> p;
	if (myConfig.contains(name))
	{
	const json& a = myConfig[name];
	p = Parameter<T>::fromJson(a);
	}
	else
	{
	LOG_F(ERROR,
	"parameter `%s` is not found in confi</code></td>
          <td>	<code>template <typename T> const T paramet
	{
	Parameter<T> p;
	if (myConfig.contains(name))
	{
	const json& a = myConfig[name];
	p = Parameter<T>::fromJson(a);
	}
	else
	{
	LOG_F(WARNING, "parameter `%s` is not
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 57-60</strong></td>
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 96-98[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif()
	
	
	#######################################</code></td>
          <td>	<code>endif()
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 143-153</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 162-173[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType2==TopAbs_VERTEX) {
	iRet=0;
	}
	}
	else if (aType1==TopAbs_EDGE) {
	if (aType2==TopAbs_VERTEX) {
	iRet=1;
	}
	else if (aType2==TopAbs_EDGE) {
	iRet=2;
	}
	</code></td>
          <td>	<code>else if (aType2==TopAbs_FACE) {
	iRet=5;
	}
	}
	// So_1,*_2
	else if (aType1==TopAbs_SOLID) {
	if (aType2==TopAbs_VERTEX) {
	iRet=6;
	}
	else if (aType2==TopAbs_EDGE) {
	iRet=7;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Logger.h: line 15-22</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 132-139[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>NLOHMANN_JSON_SERIALIZE_ENUM(NamedVer
	{Verbosity_OFF, "OFF"},
	{Verbosity_FATAL, "FATAL"}, /// progr
	{Verbosity_ERROR, "ERROR"}, /// red t
	{Verbosity_WARNING, "WARNING"}, /// y
	{Verbosity_INFO, "INFO"}, /// default
	{Verbosity_1, "PROGRESS"}, /// 1 for
	{Verbosity_2, "DEBUG"}, /// 2 for log</code></td>
          <td>	<code>NLOHMANN_JSON_SERIALIZE_ENUM(Collisio
	{NoCollision, "NoCollision"},
	{Clearance, "Clearance"},
	{FaceContact, "FaceContact"},
	{EdgeContact, "EdgeContact"},
	{VertexContact, "VertexContact"},
	{Interference, "Interference"},
	{Coincidence, "Coincidence"},</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 574-583</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 618-627[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLin=aGAC.Line();
	aP=aLin.Location();
	aD=aLin.Direction();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_LINE
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetLocation(aP);
	aInfo.SetDirection(aD);
	//
	bInf1=Precision::IsNegativeInfinite(a</code></td>
          <td>	<code>aP=aCirc.Location();
	aAx2=aCirc.Position();
	aR1=aCirc.Radius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_CIRC
	aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 145-166</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 65-86[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Real Radius2() const;
	
	Standard_EXPORT
	void SetLength(const Standard_Real aL
	
	Standard_EXPORT
	Standard_Real Length() const;
	
	Standard_EXPORT
	void SetWidth(const Standard_Real aW)
	
	Standard_EXPORT
	Standard_Real Width() const;
	
	Standard_EXPORT
	void SetHeight(const Standard_Real aH
	
	Standard_EXPORT
	Standard_Real Height() const;
	
	Standard_EXPORT
	void Dump() const;</code></td>
          <td>	<code>const Handle(GEOMAlgo_Clsf)& Clsf() c
	
	Standard_EXPORT
	void SetShapeType(const TopAbs_ShapeE
	
	Standard_EXPORT
	TopAbs_ShapeEnum ShapeType() const;
	
	Standard_EXPORT
	void SetState(const GEOMAlgo_State aS
	
	Standard_EXPORT
	GEOMAlgo_State State() const;
	
	Standard_EXPORT
	void SetNbPntsMin(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer NbPntsMin() const;
	
	Standard_EXPORT
	void SetNbPntsMax(const Standard_Inte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 372-378</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 226-233[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>}// for (j=1; j<=aNbS2; ++j) {
	//
	aItDMSLS.Initialize(aDMSLS);
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aS1=aItDMSLS.Key(
	const TopTools_ListOfShape& aLS2=aItD
	aCS.SetShape1(aS1);
	</code></td>
          <td>	<code>}
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt
	//
	aItS.Initialize(aLVSD);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 105-110</strong></td>
        <td style="text-align:center"><strong>src/PPP/TypeDefs.h: line 103-108   [47]</strong></td>
        </tr>
        <tr>
          <td>	<code>{ShapeErrorType::Interference, "Inter
	{ShapeErrorType::Coincidence, "Coinci
	{ShapeErrorType::Enclosure, "Enclosur
	{ShapeErrorType::UnknownError, "Unkno
	{ShapeErrorType::TessellationError, "
	});</code></td>
          <td>	<code>{IndexPattern::LowerTriangle, "LowerT
	{IndexPattern::DenseMatrix, "DenseMat
	{IndexPattern::SparseMatrix, "SparseM
	{IndexPattern::FilteredMatrix, "Filte
	{IndexPattern::PartitionIdVector, "Pa
	});</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 426-435</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 319-329[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	TopExp::MapShapes(myArgument, aType,
	//
	aNbW=aMW.Extent();
	for (i=1; i<=aNbW; ++i) {
	const TopoDS_Shape& aW=aMW(i);
	//
	if (!aMFence.Add(aW)) {
	</code></td>
          <td>	<code>GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	myErrorStatus=0;
	//
	TopExp::MapShapes(myArgument, aType,
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	if (aType==TopAbs_FACE) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 344-354</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 523-530[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_KindOfName aKN, aKNE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	//
	// 1. may be it is circle/ellipse
	if (aNbV==1 && aNbE==1) {</code></td>
          <td>	<code>GEOMAlgo_KindOfShape aKSE;//, aKSE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 667-668</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 669-670[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (xp.Init(aShape, TopAbs_EDGE, Top
	this->myOtherShapes[xp.Current().Hash</code></td>
          <td>	<code>for (xp.Init(aShape, TopAbs_VERTEX, T
	this->myOtherShapes[xp.Current().Hash</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 132-139</strong></td>
        <td style="text-align:center"><strong>src/PPP/Logger.h: line 15-22       [47]</strong></td>
        </tr>
        <tr>
          <td>	<code>NLOHMANN_JSON_SERIALIZE_ENUM(Collisio
	{NoCollision, "NoCollision"},
	{Clearance, "Clearance"},
	{FaceContact, "FaceContact"},
	{EdgeContact, "EdgeContact"},
	{VertexContact, "VertexContact"},
	{Interference, "Interference"},
	{Coincidence, "Coincidence"},</code></td>
          <td>	<code>NLOHMANN_JSON_SERIALIZE_ENUM(NamedVer
	{Verbosity_OFF, "OFF"},
	{Verbosity_FATAL, "FATAL"}, /// progr
	{Verbosity_ERROR, "ERROR"}, /// red t
	{Verbosity_WARNING, "WARNING"}, /// y
	{Verbosity_INFO, "INFO"}, /// default
	{Verbosity_1, "PROGRESS"}, /// 1 for
	{Verbosity_2, "DEBUG"}, /// 2 for log</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 319-329</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 367-376[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_IndexedDataMapOfPassKeyShape
	//
	myErrorStatus=0;
	//
	TopExp::MapShapes(myArgument, aType,
	//
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aS=aMF(i);
	//
	if (aType==TopAbs_FACE) {</code></td>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	TopExp::MapShapes(myArgument, theType
	//
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);
	//
	if (!aMFence.Add(aE)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 103-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 121-123[47]</strong></td>
        </tr>
        <tr>
          <td>	<code>try
	{
	BRepPrimAPI_MakeBox aBoxMaker(gp_Pnt(</code></td>
          <td>	<code>try
	{
	BRepPrimAPI_MakeBox aBoxMaker(gp_Pnt(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 308-311</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 317-320[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (not OccUtils::isBndBoxCoincident(
	{
	VLOG_F(LOGLEVEL_DEBUG, "changed Bound
	itemName(i).c_str(), j);</code></td>
          <td>	<code>if (not OccUtils::isBndBoxCoincident(
	{
	VLOG_F(LOGLEVEL_DEBUG, "changed Bound
	itemName(j).c_str(), i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1058-1066</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 734-742[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aMSS;
	//
	GetSubShapes(aS, aMSS);
	//
	bRet=Standard_False;
	aNbSS=aMSS.Extent();
	for (i=1; i<=aNbSS; ++i) {
	const TopoDS_Shape& aSS=aMSS(i);
	if (aSS.ShapeType()==TopAbs_WIRE) {</code></td>
          <td>	<code>const TopTools_MapOfShape& aMSInF=(bH
	//
	MapBRepShapes(theF2, aMS2);
	//
	bFound=Standard_False;
	aNbS2=aMS2.Extent();
	for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aS2=aMS2(i);
	if (aS2.IsSame(theF2)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 604-607</strong></td>
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 28-31[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>Utilities::UniqueIdType gid = Utiliti
	v_props.Mass(), {v_props.CentreOfMass
	return gid;
	}</code></td>
          <td>	<code>auto gid = PPP::Utilities::geometryUn
	v_props.Mass(), {v_props.CentreOfMass
	return gid;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 458-472</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 526-539[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.Add(aWnew, aEnew);
	}
	else {
	aBB.Add(aWnew, aE);
	}
	}
	//
	//myImages / myOrigins
	TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aW);
	myImages.Bind(aWnew, aLSD);
	myOrigins.Bind(aW, aWnew);
	//
	}//for (i=1; i<=aNbE; ++i) {</code></td>
          <td>	<code>aBB.Add(aCnew, aCXnew);
	}
	else {
	aBB.Add(aCnew, aCX);
	}
	}
	//
	//myImages / myOrigins
	TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aC);
	myImages.Bind(aCnew, aLSD);
	myOrigins.Bind(aC, aCnew);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 486-496</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 516-526[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbS=NbSubShapes(TopAbs_SOLID);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();
	//
	printf(" *COMPSOLID\n");
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	printf(" number of faces : %d\n", aNb
	printf(" number of solids : %d\n", aN</code></td>
          <td>	<code>aNbF=NbSubShapes(TopAbs_FACE);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();
	//
	printf(" *SOLID\n");
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	printf(" number of faces : %d\n", aNb
	DumpKindOfShape (aKS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 119-144</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 162-187[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Gluer2::SetKeepNonSolids(
	{
	myKeepNonSolids=aFlag;
	}
	//=====================================
	//function : KeepNonSolids
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer2::KeepN
	{
	return myKeepNonSolids;
	}
	//=====================================
	//function : ShapesDetected
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myImagesDetected;
	}
	//=====================================
	//function : ImagesToWork
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn2::SetNbPnts
	{
	myNbPntsMax=aNb;
	}
	//=====================================
	//function : NbPntsMax
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_FinderShapeOn
	{
	return myNbPntsMax;
	}
	//=====================================
	// function: MSS
	// purpose:
	//=====================================
	const GEOMAlgo_IndexedDataMapOfShapeS
	{
	return myMSS;
	}
	//=====================================
	// function: Shapes
	// purpose:
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Fi
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 365-371</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 477-483[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myMapShapeAnc.IsBound(theShape))
	TopTools_ListIteratorOfListOfShape an
	
	for (; anAncIt.More(); anAncIt.Next()
	const TopoDS_Shape &anAncShape = anAn
	
	if (!myMapRemoved.Contains(anAncShape</code></td>
          <td>	<code>if (myMapShapeAnc.IsBound(theWire)) {
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aParent = anIter.
	
	if (aParent.ShapeType() == TopAbs_FAC</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 436-443</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 468-475  [46]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myConfig.contains(name))
	{
	const json& a = myConfig[name];
	p = Parameter<T>::fromJson(a);
	}
	else
	{
	LOG_F(WARNING, "parameter `%s` is not</code></td>
          <td>	<code>if (gConfig.contains(name))
	{
	const json& a = gConfig[name];
	p = Parameter<T>::fromJson(a);
	}
	else
	{
	LOG_F(ERROR, "parameter %s is not fou</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 123-124</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 63-64 [46]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	# configuration header, shared by all p</code></td>
          <td>	<code>#######################################
	# optional dep, boost::process dep on b</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 768-775</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 496-502[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, j, aNbS, aNbF;
	TopTools_IndexedMapOfShape aMS, aMF;
	TopTools_MapIteratorOfMapOfShape aItM
	//
	TopExp::MapShapes(theShape, TopAbs_SO
	//
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {</code></td>
          <td>	<code>Standard_Integer i, aNbS, j, aNbF;
	TopTools_IndexedMapOfShape aM, aMF;
	TopAbs_State aSt;
	//
	TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 227-234</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 120-126[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>AddInternalShapes(aLSR, aMSI);
	}
	//
	aItLS.Initialize(aLSR);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSR=aItLS.Value()
	aBB.Add(myResult, aSR);
	}</code></td>
          <td>	<code>aMFS.Add(aF, TopAbs_IN);
	}
	aIt.Initialize(myLSOUT);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aF=aIt.Value();
	aMFS.Add(aF, TopAbs_OUT);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 716-722</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 19-24[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>throw OSD_Exception("General Fusion f
	
	std::vector<TopoDS_Shape> res; // out
	for (TopExp_Explorer anExp(mkGFA->Sha
	{
	res.push_back(anExp.Current());
	}</code></td>
          <td>	<code>const auto& origShapes = mkGFA->Argum
	std::vector<TopoDS_Shape> resultShape
	for (TopExp_Explorer anExp(mkGFA->Sha
	{
	resultShapes.push_back(anExp.Current(
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 28-31</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 604-607[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto gid = PPP::Utilities::geometryUn
	v_props.Mass(), {v_props.CentreOfMass
	return gid;
	}</code></td>
          <td>	<code>Utilities::UniqueIdType gid = Utiliti
	v_props.Mass(), {v_props.CentreOfMass
	return gid;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 19-24</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 716-722[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>const auto& origShapes = mkGFA->Argum
	std::vector<TopoDS_Shape> resultShape
	for (TopExp_Explorer anExp(mkGFA->Sha
	{
	resultShapes.push_back(anExp.Current(
	}
	</code></td>
          <td>	<code>throw OSD_Exception("General Fusion f
	
	std::vector<TopoDS_Shape> res; // out
	for (TopExp_Explorer anExp(mkGFA->Sha
	{
	res.push_back(anExp.Current());
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 421-430</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 572-581[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Cone aCone;
	//
	aCone=aGAS.Cone();
	aP0=aCone.Location();
	aAx3=aCone.Position();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_CONE
	aInfo.SetKindOfName(GEOMAlgo_KN_CONE)
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);</code></td>
          <td>	<code>gp_XYZ aXYZ1, aXYZ2, aXYZc;
	//
	aLin=aGAC.Line();
	aP=aLin.Location();
	aD=aLin.Direction();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_LINE
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetLocation(aP);
	aInfo.SetDirection(aD);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 734-742</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1058-1066[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_MapOfShape& aMSInF=(bH
	//
	MapBRepShapes(theF2, aMS2);
	//
	bFound=Standard_False;
	aNbS2=aMS2.Extent();
	for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aS2=aMS2(i);
	if (aS2.IsSame(theF2)) {</code></td>
          <td>	<code>TopTools_IndexedMapOfShape aMSS;
	//
	GetSubShapes(aS, aMSS);
	//
	bRet=Standard_False;
	aNbSS=aMSS.Extent();
	for (i=1; i<=aNbSS; ++i) {
	const TopoDS_Shape& aSS=aMSS(i);
	if (aSS.ShapeType()==TopAbs_WIRE) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 251-261</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 338-346[46]</strong></td>
        </tr>
        <tr>
          <td>	<code>"doc": "detect contact or collision,
	"tolerance": {
	"type": "quantity",
	"value": 0.001,
	"unit": "mm",
	"range": [1e-5, 1],
	"doc": "tolerance for boolean operati
	},
	"clearanceThreshold": {
	"type": "quantity",
	"value": 0.5,</code></td>
          <td>	<code>"className": "Geom::GeometryFaceter",
	"tessellationResolution": {
	"type": "quantity",
	"value": 0.1,
	"unit": "mm",
	"range": [1e-3, 10],
	"doc": "length resolution or mesh siz
	},
	"output": {"type": "filename", "value
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 390-394</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 409-412[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (theWhat.ShapeType() == TopAbs_COM
	theWhat.ShapeType() == TopAbs_COMPSOL
	// recursive processing of compound/c
	TopoDS_Iterator anIt (theWhat, Standa
	for (; anIt.More(); anIt.Next()) {</code></td>
          <td>	<code>if (theShape.ShapeType() == TopAbs_CO
	theShape.ShapeType() == TopAbs_COMPSO
	TopoDS_Iterator It (theShape, Standar
	for (; It.More(); It.Next()) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 48-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 105-129[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void prepareOutput() override
	{
	// volumeCheck();
	// dump(dataStoragePath("gproperties_
	// report, save and display erroneous
	if (myConfig.contains("output"))
	{
	auto file_name = dataStoragePath(para
	writeMetaData(file_name);
	}
	else
	{
	LOG_F(WARNING, "user must provided ou
	}
	myOutputData->emplace("myGeometryProp
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>virtual void prepareOutput() override
	{
	
	if (myConfig.contains("output"))
	{
	auto file_name = dataStoragePath(para
	writeResult(file_name);
	}
	else
	{
	LOG_F(WARNING, "user must provided ou
	}
	/*
	if (suppressMatched)
	{
	for (size_t r = 0; r < myFilterCount;
	{
	const auto& matched = myMatchedResult
	{
	// done in writeResult()
	}
	}
	}
	*/
	myOutputData->emplace<decltype(myMatc</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 559-565</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 506-513[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>aME.Clear();
	TopExp::MapShapes(aF1, TopAbs_EDGE, a
	//
	bFound=Standard_False;
	aNbE=aME.Extent();
	for (i=1; i<=aNbE; ++i) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge
	</code></td>
          <td>	<code>aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 415-422</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 459-466[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	GEOMAlgo_StateCollector aSC;
	GEOMAlgo_ListOfPnt aLP;
	//
	const TopoDS_Face& aF=TopoDS::Face(aM
	//
	if (myState==GEOMAlgo_ST_ON) {
	Handle(Geom_Surface) aS;</code></td>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	GEOMAlgo_StateCollector aSC;
	GEOMAlgo_ListOfPnt aLP;
	//
	const TopoDS_Face& aF=TopoDS::Face(aM
	//
	if (myState==GEOMAlgo_ST_ON) {
	Handle(Geom_Surface) aS;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 107-112</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 134-139[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_IndexedMapOfShape& aMV
	aNbV=aMV.Extent();
	for (j=1; j<=aNbV; ++j) {
	const TopoDS_Shape& aFx=aMV(j);
	ProcessBlock(aFx, aMCV, aProcessed, a
	}</code></td>
          <td>	<code>const TopTools_IndexedMapOfShape& aMV
	aNbV=aMV.Extent();
	for (j=1; j<=aNbV; ++j) {
	const TopoDS_Shape& aFx=aMV(j);
	ProcessBlock(aFx, aMCV, aProcessed, a
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 227-232</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 478-483[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>anAncIt.Initialize(myMapShapeAnc.Find
	
	for (; anAncIt.More(); anAncIt.Next()
	const TopoDS_Shape &anAncShape = anAn
	
	if (anAncShape.ShapeType() == TopAbs_</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aParent = anIter.
	
	if (aParent.ShapeType() == TopAbs_FAC</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 403-408</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 623-629[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(aF, TopAbs_VERTEX,
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);
	</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	TopExp::MapShapes(aCnew, TopAbs_SOLID
	
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 524-543</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 747-766[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>break;
	}
	}
	if (!bFound) {
	return;
	}
	//
	bFound=CheckCoincidence(theE1, theE2)
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(theE1, theE2);
	}
	}
	//=====================================
	//function : PerformVF
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformVF()</code></td>
          <td>	<code>break;
	}
	}
	if (!bFound) {
	return;
	}
	//
	bFound=CheckCoincidence(theF1, theF2)
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(theF1, theF2);
	}
	}
	//=====================================
	//function : FillSolidsOn
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillSolidsOn(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 961-977</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1079-1095[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	//=====================================
	//function : FillImgSimple
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillImgSimple
	(const TopoDS_Shape &theShape,
	const TopAbs_ShapeEnum theSubShapeTyp
	const Standard_Boolean IsWhere)
	{
	TopTools_IndexedMapOfShape aMS;
	
	TopExp::MapShapes(theShape, theSubSha
	
	Standard_Integer i;
	const Standard_Integer aNbS = aMS.Ext</code></td>
          <td>	<code>}
	
	//=====================================
	//function : FillImgComplex
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillImgComple
	(const TopoDS_Shape &theShape,
	const TopAbs_ShapeEnum theSubShapeTyp
	const Standard_Boolean IsWhere)
	{
	TopTools_IndexedMapOfShape aMS;
	
	TopExp::MapShapes(theShape, theSubSha
	
	Standard_Integer i;
	const Standard_Integer aNbS = aMS.Ext</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 623-629</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 403-408[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	TopExp::MapShapes(aCnew, TopAbs_SOLID
	
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);</code></td>
          <td>	<code>TopExp::MapShapes(aF, TopAbs_VERTEX,
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 178-191</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 94-106[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Handle(IntTools_Context)& aCtx)
	
	//
	Standard_EXPORT
	static void FindChains(const GEOMAlgo
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void FindChains(const GEOMAlgo
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void CopyShape(const TopoDS_Sh
	TopoDS_Shape& aSC) ;</code></td>
          <td>	<code>virtual Standard_Boolean IsDeleted(co
	
	Standard_EXPORT
	static void MakeVertex(const TopTools
	TopoDS_Vertex& theV) ;
	
	Standard_EXPORT
	static void MapBRepShapes(const TopoD
	TopTools_MapOfShape& theM) ;
	
	Standard_EXPORT
	static void MapShapes(const TopoDS_Sh
	TopTools_MapOfShape& theM) ;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 123-128</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 233-237[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItW.Initialize(aFF);
	for (; aItW.More(); aItW.Next()) {
	const TopoDS_Shape& aW=aItW.Value();
	//
	if (!myOrigins.IsBound(aW)) {
	aBB.Add(aFnew, aW);</code></td>
          <td>	<code>aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 251-258</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 151-158[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);
	aType=aS.ShapeType();
	if (aType!=TopAbs_FACE) {
	continue;
	}
	//
	aState=TopAbs_UNKNOWN;</code></td>
          <td>	<code>for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);
	aType=aS.ShapeType();
	if (aType!=TopAbs_EDGE) {
	continue;
	}
	//
	aE=*((TopoDS_Edge*)&pDS->Shape(i));</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 151-158</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 251-258[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);
	aType=aS.ShapeType();
	if (aType!=TopAbs_EDGE) {
	continue;
	}
	//
	aE=*((TopoDS_Edge*)&pDS->Shape(i));</code></td>
          <td>	<code>for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);
	aType=aS.ShapeType();
	if (aType!=TopAbs_FACE) {
	continue;
	}
	//
	aState=TopAbs_UNKNOWN;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 89-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 109-124[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>SET(GEOMAlgo_SOURCES
	GEOMAlgo_Algo.cxx
	GEOMAlgo_AlgoTools.cxx
	GEOMAlgo_AlgoTools_1.cxx
	GEOMAlgo_BndSphere.cxx
	GEOMAlgo_BndSphereTree.cxx
	GEOMAlgo_BoxBndTree.cxx
	GEOMAlgo_BuilderShape.cxx
	GEOMAlgo_Clsf.cxx
	GEOMAlgo_ClsfBox.cxx
	GEOMAlgo_ClsfQuad.cxx
	GEOMAlgo_ClsfSolid.cxx
	GEOMAlgo_ClsfSurf.cxx
	GEOMAlgo_CoupleOfShapes.cxx
	GEOMAlgo_FinderShapeOn2.cxx
	GEOMAlgo_Extractor.cxx</code></td>
          <td>	<code>#GEOMAlgo_GetInPlaceAPI.cxx
	GEOMAlgo_GlueAnalyser.cxx
	GEOMAlgo_GlueDetector.cxx
	GEOMAlgo_Gluer.cxx
	GEOMAlgo_Gluer2.cxx
	GEOMAlgo_Gluer2_1.cxx
	GEOMAlgo_Gluer2_2.cxx
	GEOMAlgo_Gluer2_3.cxx
	GEOMAlgo_GluerAlgo.cxx
	GEOMAlgo_HAlgo.cxx
	GEOMAlgo_PassKey.cxx
	GEOMAlgo_PassKeyMapHasher.cxx
	GEOMAlgo_PassKeyShape.cxx
	GEOMAlgo_PassKeyShapeMapHasher.cxx
	GEOMAlgo_RemoverWebs.cxx
	GEOMAlgo_ShapeAlgo.cxx</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 321-326</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 332-336[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItDMSLS.Initialize(aDMSLS);
	for (; aItDMSLS.More(); aItDMSLS.Next
	//const TopoDS_Shape& aSkey=aItDMSLS.
	const TopTools_ListOfShape& aLS=aItDM
	aNbS=aLS.Extent();
	if (aNbS!=2) {</code></td>
          <td>	<code>aItDMSLS.Initialize(myImagesToWork);
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke
	aType=aSkey.ShapeType();
	if (aType!=TopAbs_VERTEX) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 711-718</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 720-726[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapesAndAncestors(myResul
	TopExp::MapShapes(myResult, TopAbs_SO
	//
	
	myNbAlone=0;
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aSolid=aMS(i);</code></td>
          <td>	<code>aMFS.Clear();
	TopExp::MapShapes(aSolid, TopAbs_FACE
	//
	bFound=Standard_False;
	aNbFS=aMFS.Extent();
	for (j=1; j<=aNbFS; ++j) {
	const TopoDS_Shape& aFS=aMFS(j);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 105-129</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 48-62[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void prepareOutput() override
	{
	
	if (myConfig.contains("output"))
	{
	auto file_name = dataStoragePath(para
	writeResult(file_name);
	}
	else
	{
	LOG_F(WARNING, "user must provided ou
	}
	/*
	if (suppressMatched)
	{
	for (size_t r = 0; r < myFilterCount;
	{
	const auto& matched = myMatchedResult
	{
	// done in writeResult()
	}
	}
	}
	*/
	myOutputData->emplace<decltype(myMatc</code></td>
          <td>	<code>virtual void prepareOutput() override
	{
	// volumeCheck();
	// dump(dataStoragePath("gproperties_
	// report, save and display erroneous
	if (myConfig.contains("output"))
	{
	auto file_name = dataStoragePath(para
	writeMetaData(file_name);
	}
	else
	{
	LOG_F(WARNING, "user must provided ou
	}
	myOutputData->emplace("myGeometryProp
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 409-412</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 390-394[45]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (theShape.ShapeType() == TopAbs_CO
	theShape.ShapeType() == TopAbs_COMPSO
	TopoDS_Iterator It (theShape, Standar
	for (; It.More(); It.Next()) {
	</code></td>
          <td>	<code>if (theWhat.ShapeType() == TopAbs_COM
	theWhat.ShapeType() == TopAbs_COMPSOL
	// recursive processing of compound/c
	TopoDS_Iterator anIt (theWhat, Standa
	for (; anIt.More(); anIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 600-607</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 768-776[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aIt;
	TopTools_IndexedMapOfShape aMF, aME;
	TopTools_MapIteratorOfMapOfShape aItM
	//
	TopExp::MapShapes(theShape, TopAbs_FA
	aNbF=aMF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Face& aF1=*((TopoDS_Face
	</code></td>
          <td>	<code>Standard_Integer i, j, aNbS, aNbF;
	TopTools_IndexedMapOfShape aMS, aMF;
	TopTools_MapIteratorOfMapOfShape aItM
	//
	TopExp::MapShapes(theShape, TopAbs_SO
	//
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aSD1=aMS(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 231-239</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 232-241[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>aM.Clear();
	TopExp::MapShapes(myShape, myShapeTyp
	aNb=aM.Extent();
	if (!aNb) {
	myWarningStatus=10; // No found sub-s
	return;
	}
	//
	for (i=1; i<=aNb; ++i) {
	</code></td>
          <td>	<code>NCollection_UBTreeFiller <Standard_In
	//
	TopExp::MapShapes(myShape, TopAbs_VER
	aNbV=aMV.Extent();
	if (!aNbV) {
	myErrorStatus=2; // no vertices in so
	return;
	}
	//
	for (i=1; i<=aNbV; ++i) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 760-776</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 778-794[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function :NbShells
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_ShapeInfoFill
	(const TopoDS_Solid& aSd)
	{
	Standard_Integer iCnt;
	TopoDS_Iterator aIt;
	//
	iCnt=0;
	//
	aIt.Initialize(aSd);
	for (; aIt.More(); aIt.Next()) {
	++iCnt;
	}</code></td>
          <td>	<code>}
	//=====================================
	//function : NbWires
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_ShapeInfoFill
	(const TopoDS_Face& aF)
	{
	Standard_Integer iCnt;
	TopoDS_Iterator aIt;
	//
	iCnt=0;
	//
	aIt.Initialize(aF);
	for (; aIt.More(); aIt.Next()) {
	++iCnt;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 754-761</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 558-566[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!BuildTriangulation(aE)) {
	myErrorStatus=20; // no triangulation
	return;
	}
	aPE = BRep_Tool::Polygon3D(aE, aLoc);
	}
	const gp_Trsf& aTrsf=aLoc.Transformat
	const TColgp_Array1OfPnt& aNodes=aPE-
	</code></td>
          <td>	<code>if (!GEOMAlgo_AlgoTools::BuildTriangu
	myWarningStatus=20; // no triangulati
	return;
	}
	aTRF=BRep_Tool::Triangulation(aF, aLo
	}
	//
	const gp_Trsf& aTrsf=aLoc.Transformat
	const Poly_Array1OfTriangle& aTrs=aTR</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 163-167</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 642-646[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(
	if (aM.Add(aSIm)) {
	aBB.Add(myShape, aSIm);</code></td>
          <td>	<code>aIt.Initialize(aLE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aE2=aIt.Value();
	if (aE2.IsSame(aE1)) {
	aLESD.Append(aE2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 106-127</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 77-98[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_Gluer::GEOMAlgo_Gluer()
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myTol=myTolerance;
	myCheckGeometry=Standard_True;
	myKeepNonSolids=Standard_False;
	myNbAlone=0;
	}
	//=====================================
	//function : ~GEOMAlgo_Gluer
	//purpose :
	//=====================================
	GEOMAlgo_Gluer::~GEOMAlgo_Gluer()
	{
	}
	//=====================================
	//function : SetCheckGeometry
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::SetCheckGeometry(c</code></td>
          <td>	<code>GEOMAlgo_FinderShapeOn2::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;
	myNbPntsMax=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_FinderShapeOn2::~GEOMAlgo_Find
	{
	}
	//=====================================
	//function : SetClsf
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetClsf(c</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 129-145</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.hxx: line 62-78[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	void SetPnt2(const gp_Pnt& aP) ;
	
	Standard_EXPORT
	const gp_Pnt& Pnt2() const;
	
	Standard_EXPORT
	void SetRadius1(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius1() const;
	
	Standard_EXPORT
	void SetRadius2(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius2() const;</code></td>
          <td>	<code>Standard_EXPORT
	void AddTool(const TopoDS_Shape& theS
	
	Standard_EXPORT
	const TopTools_ListOfShape& Tools()co
	
	Standard_EXPORT
	void SetLimit(const TopAbs_ShapeEnum
	
	Standard_EXPORT
	TopAbs_ShapeEnum Limit()const;
	
	Standard_EXPORT
	void SetLimitMode(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer LimitMode()const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 104-111</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 111-117[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (floatEqual(allVol, sumOrigVols, 1
	{
	/* count total face, edge and vertex
	Standard_Real totalArea = 0.0;
	for (const auto& s : origShapes)
	totalArea += area(s);
	Standard_Real resultArea = area(mkGFA
	if (floatEqual(totalArea, resultArea)</code></td>
          <td>	<code>if (floatEqual(totalArea, resultArea)
	{
	Standard_Real totalPerimeter = 0.0;
	for (const auto& s : origShapes)
	totalPerimeter += perimeter(s);
	Standard_Real resultPerimeter = perim
	if (floatEqual(totalPerimeter, result
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 406-412</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 417-423[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (mapShape.Add(anExp.Current())) {
	TopoDS_Shape curWhat = anExp.Current(
	isFoundAny = GetInPlaceByHistory(theW
	if (isFoundAny) isFound = Standard_Tr
	}
	}
	}</code></td>
          <td>	<code>if (mapShape.Add(anExp.Current())) {
	TopoDS_Shape curWhat = anExp.Current(
	isFoundAny = GetInPlaceByHistory(theW
	if (isFoundAny) isFound = Standard_Tr
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 141-148</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 717-724[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aSolid=aMS(i);
	//
	aMF.Clear();
	TopExp::MapShapes(aSolid, TopAbs_FACE
	//
	aNbFIN=0;
	aNbFOUT=0;</code></td>
          <td>	<code>for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aSolid=aMS(i);
	//
	aMFS.Clear();
	TopExp::MapShapes(aSolid, TopAbs_FACE
	//
	bFound=Standard_False;
	aNbFS=aMFS.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 80-84</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 87-89[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>CollisionType::Coincidence);
	
	// not completely inside, enclosure,
	TopoDS_Shape aCylinder5 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl</code></td>
          <td>	<code>anAxis.SetLocation(gp_Pnt(0.0, 0.0, H
	TopoDS_Shape aCylinder6 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 136-155</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.cxx: line 66-85[44]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_GetInPlace::SetShapeWhere
	{
	myShapeWhere=theShape;
	}
	//=====================================
	//function : ShapeWhere
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_GetInPlace
	{
	return myShapeWhere;
	}
	//=====================================
	//function : ShapesIn
	//purpose :
	//=====================================
	const GEOMAlgo_DataMapOfShapeMapOfShape
	{
	return myShapesIn;
	}</code></td>
          <td>	<code>void GEOMAlgo_CoupleOfShapes::SetShape2
	{
	myShape2=aS2;
	}
	//=====================================
	//function : Shape1
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_CoupleOfSh
	{
	return myShape1;
	}
	//=====================================
	//function : Shape2
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_CoupleOfSh
	{
	return myShape2;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 905-911</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 163-167[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>aMapFence.Clear();
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (aMapFence.Add(aSubShape)) {
	aBuilder.Add(aResult, aSubShape);</code></td>
          <td>	<code>aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(
	if (aM.Add(aSIm)) {
	aBB.Add(myShape, aSIm);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 194-209</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 205-220[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfQuad::C
	{
	return GEOMAlgo_Clsf::CanBeON(aC);
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfQuad::C
	{</code></td>
          <td>	<code>}
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfBox::Ca
	{
	return GEOMAlgo_Clsf::CanBeON(aC);
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfBox::Ca
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 52-59</strong></td>
        <td style="text-align:center"><strong>src/PPP/Executor.h: line 59-67     [43]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void process() override
	{
	myProcessor->prepareInput();
	const size_t NItems = myProcessor->in
	if (NItems == 0)
	{
	LOG_F(ERROR, "item count is zero in d
	}
	</code></td>
          <td>	<code>virtual void process() override
	{
	myProcessor->prepareInput();
	
	const size_t NItems = myProcessor->in
	if (NItems == 0)
	{
	LOG_F(ERROR, "no items are loaded for
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 442-452</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 477-487[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbF, aN
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	aNbS=NbSubShapes(TopAbs_SOLID);
	aNbC=NbSubShapes(TopAbs_COMPSOLID);</code></td>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbF, aN
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	aNbS=NbSubShapes(TopAbs_SOLID);
	aKS=KindOfShape();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 154-160</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 484-490[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	//
	aIt.Initialize(myArguments);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();
	aType=aS.ShapeType();
	if (aType==theType && !myMapTools.Con</code></td>
          <td>	<code>myWarningStatus=0;
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();
	aType=aCx.ShapeType();
	if (aType==TopAbs_COMPOUND) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 170-171</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 172-173[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>info = {{"compounds", compounds->Leng
	{"solids", solids->Length()}, {"shell</code></td>
          <td>	<code>{"faces", faces->Length()}, {"wires",
	{"vertices", vertices->Length()}, {"e</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 526-529</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 529-532[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(floatEqual(d, 10.0));
	
	auto b3 = BRepPrimAPI_MakeBox(gp_Pnt(
	REQUIRE(floatEqual(distance(b1, b3),</code></td>
          <td>	<code>REQUIRE(floatEqual(distance(b1, b3),
	
	auto b4 = BRepPrimAPI_MakeBox(gp_Pnt(
	REQUIRE(floatEqual(distance(b1, b4),</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Executor.h: line 59-67</strong></td>
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 52-59[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void process() override
	{
	myProcessor->prepareInput();
	
	const size_t NItems = myProcessor->in
	if (NItems == 0)
	{
	LOG_F(ERROR, "no items are loaded for
	}</code></td>
          <td>	<code>virtual void process() override
	{
	myProcessor->prepareInput();
	const size_t NItems = myProcessor->in
	if (NItems == 0)
	{
	LOG_F(ERROR, "item count is zero in d
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 205-220</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 194-209[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfBox::Ca
	{
	return GEOMAlgo_Clsf::CanBeON(aC);
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfBox::Ca
	{</code></td>
          <td>	<code>}
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfQuad::C
	{
	return GEOMAlgo_Clsf::CanBeON(aC);
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfQuad::C
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 185-193</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1194-1199[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	aBuilder.MakeCompound(aComp2);
	
	for (; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aShape2 = anIt.Va
	
	aBuilder.Add(aComp2, aShape2);
	}</code></td>
          <td>	<code>const TopTools_ListOfShape& aLS=myIma
	aItLS.Initialize(aLS);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSD=aItLS.Value()
	aBB.Add(aC, aSD);
	}
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 226-231</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 512-517[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>TreatCompound(aS, aLSX);
	//
	aItX.Initialize(aLSX);
	for (; aItX.More(); aItX.Next()) {
	const TopoDS_Shape& aSX=aItX.Value();
	aTypeX=aSX.ShapeType();</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(aC);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();
	aType=aCX.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 607-613</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 776-782[43]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Face& aF1=*((TopoDS_Face
	//
	aME.Clear();
	TopExp::MapShapes(aF1, TopAbs_EDGE, a
	aNbE=aME.Extent();
	for (j=1; j<=aNbE; ++j) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge</code></td>
          <td>	<code>const TopoDS_Shape& aSD1=aMS(i);
	//
	aMF.Clear();
	TopExp::MapShapes(aSD1, TopAbs_FACE,
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF1=aMF(j);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 96-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 181-191[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	static void MakeVertex(const TopTools
	TopoDS_Vertex& theV) ;
	
	Standard_EXPORT
	static void MapBRepShapes(const TopoD
	TopTools_MapOfShape& theM) ;
	
	Standard_EXPORT
	static void MapShapes(const TopoDS_Sh
	TopTools_MapOfShape& theM) ;</code></td>
          <td>	<code>Standard_EXPORT
	static void FindChains(const GEOMAlgo
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void FindChains(const GEOMAlgo
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void CopyShape(const TopoDS_Sh
	TopoDS_Shape& aSC) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 93-117</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 130-154[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : SolidsToGlue
	//purpose :
	//=====================================
	const GEOMAlgo_ListOfCoupleOfShapes&
	{
	return mySolidsToGlue;
	}
	//=====================================
	//function : SolidsAlone
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_
	{
	return mySolidsAlone;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;</code></td>
          <td>	<code>}
	//=====================================
	//function : ShapesDetected
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myImagesDetected;
	}
	//=====================================
	//function : ImagesToWork
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myImagesToWork;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 195-198</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 165-167[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline void to_json(json& j, const Pr
	{
	j = json{
	{"name", p.name}, {"type", p.type}, {</code></td>
          <td>	<code>inline void to_json(json& j, const Co
	{
	j = json{{"firstIndex", p.first}, {"s
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 109-120</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 84-95[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Geom_Plane) aPlane = new Geom_
	
	myPlanes.push_back(GeomAdaptor_Surfac
	myPlanes.back().Load( aPlane );
	}
	}
	
	//===================================
	//function : GetCorners
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfQuad::GetCorners(gp_P</code></td>
          <td>	<code>Handle(Geom_Plane) aPlane = new Geom_
	myPlanes.push_back( GeomAdaptor_Surfa
	myPlanes.back().Load( aPlane );
	}
	}
	
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	
	void GEOMAlgo_FinderShapeOnQuad::CheckD</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.hxx: line 52-67</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 84-94[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	const TopoDS_Shape& Shape() const;
	
	//! Returns the list of shapes genera
	//! shape theS. <br>
	Standard_EXPORT
	virtual const TopTools_ListOfShape& G
	
	//! Returns the list of shapes modifi
	//! shape theS. <br>
	Standard_EXPORT
	virtual const TopTools_ListOfShape& M
	
	//! Returns true if the shape theS ha
	Standard_EXPORT
	virtual Standard_Boolean IsDeleted(co</code></td>
          <td>	<code>Standard_EXPORT
	const TopTools_DataMapOfShapeListOfSh
	
	Standard_EXPORT
	virtual const TopTools_ListOfShape& G
	
	Standard_EXPORT
	virtual const TopTools_ListOfShape& M
	
	Standard_EXPORT
	virtual Standard_Boolean IsDeleted(co
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 357-362</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 121-127[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapesAndAncestors(myShape
	//
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aIm=aItIm.Key();
	if (aIm.ShapeType()!=TopAbs_FACE) {
	</code></td>
          <td>	<code>aBB.MakeFace (aFnew, aS, aLoc, aTol);
	//
	aItW.Initialize(aFF);
	for (; aItW.More(); aItW.Next()) {
	const TopoDS_Shape& aW=aItW.Value();
	//
	if (!myOrigins.IsBound(aW)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 433-443</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 991-1001[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.Add(aNewSolid, aShellR);
	}
	//
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aSolid);
	myImages.Bind(aNewSolid, aLS);
	myOrigins.Bind(aSolid, aNewSolid);
	//
	aBB.Add(theResult, aNewSolid);
	}</code></td>
          <td>	<code>aBB.Add(newWire, aER);
	}
	// xf
	TopTools_ListOfShape aLW;
	//
	aLW.Append(aW);
	myImages.Bind(newWire, aLW);
	myOrigins.Bind(aW, newWire);
	// xt
	aBB.Add(newFace, newWire);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 818-836</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 911-928[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" Y : %.3lf %.3lf %.3lf \n", a
	}
	//=====================================
	//function : DumpKindOfBounds
	//purpose :
	//=====================================
	void DumpKindOfBounds(const GEOMAlgo_Ki
	{
	const char *pStr[]={
	"KB_UNKNOWN",
	"KB_TRIMMED",
	"KB_INFINITE"
	};
	int i;
	//
	i=(Standard_Integer)aKB;
	printf(" KindOfBounds: %s\n", pStr[i]
	
	}</code></td>
          <td>	<code>printf(" KindOfName : %s\n", pStr[i])
	}
	//=====================================
	//function : DumpKindOfDef
	//purpose :
	//=====================================
	void DumpKindOfDef(const GEOMAlgo_KindO
	{
	const char *pStr[]={
	"KD_UNKNOWN",
	"KD_SPECIFIED",
	"KB_ARBITRARY"
	};
	int i;
	//
	i=(Standard_Integer)aKD;
	printf(" KindOfDef: %s\n", pStr[i]);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 196-217</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 132-153[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	//
	FillSolids();
	if (myErrorStatus) {
	return;
	}
	//
	FillCompSolids();
	if (myErrorStatus) {
	return;
	}
	//
	FillCompounds();
	if (myErrorStatus) {
	return;
	}
	//
	BuildResult();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>return;
	}
	//
	DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}
	//
	DetectFaces();
	if (myErrorStatus) {
	return;
	}
	//
	DetectSolids();
	if (myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 114-121</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 115-120[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShellSolid::Perform();
	//
	// 2. fill Shape-State map
	aIt.Initialize(myLSIN);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aF=aIt.Value();
	aMFS.Add(aF, TopAbs_IN);
	}</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSD=aItD
	aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSx=aItLS.Value()
	myOriginsDetected.Bind(aSx, aSkey);
	}
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 17-19</strong></td>
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 21-23[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>built_module_dir = os.path.dirname(th
	if os.path.exists(os.path.abspath(bui
	sys.path.append(os.path.abspath(built</code></td>
          <td>	<code>built_module_dir = os.path.dirname(th
	if os.path.exists(os.path.abspath(bui
	sys.path.append(os.path.abspath(built</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 580-597</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 825-842[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (bFound) {
	continue;
	}
	//
	bFound=CheckCoincidence(aF1, aV2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aF1, aV2);
	}
	}
	}
	//=====================================
	//function : FillFacesOn
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillFacesOn(c</code></td>
          <td>	<code>if (bFound) {
	continue;
	}
	//------------------------------
	bFound=CheckCoincidence(aSo1, aF2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aSo1, aF2);
	}
	}
	}
	//=====================================
	//function : PerformZZ
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformZZ()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 78-85</strong></td>
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 86-93  [42]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (hasFileExt(filename, "msgpac
	{
	v_buffer = json::to_msgpack(jObj);
	}
	else if (hasFileExt(filename, "ubjson
	{
	v_buffer = json::to_ubjson(jObj);</code></td>
          <td>	<code>}
	else if (hasFileExt(filename, "cbor")
	{
	v_buffer = json::to_cbor(jObj);
	}
	else if (hasFileExt(filename, "bson")
	{
	v_buffer = json::to_bson(jObj);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 84-94</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.hxx: line 52-67[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	const TopTools_DataMapOfShapeListOfSh
	
	Standard_EXPORT
	virtual const TopTools_ListOfShape& G
	
	Standard_EXPORT
	virtual const TopTools_ListOfShape& M
	
	Standard_EXPORT
	virtual Standard_Boolean IsDeleted(co
	
	
	
	
	</code></td>
          <td>	<code>Standard_EXPORT
	const TopoDS_Shape& Shape() const;
	
	//! Returns the list of shapes genera
	//! shape theS. <br>
	Standard_EXPORT
	virtual const TopTools_ListOfShape& G
	
	//! Returns the list of shapes modifi
	//! shape theS. <br>
	Standard_EXPORT
	virtual const TopTools_ListOfShape& M
	
	//! Returns true if the shape theS ha
	Standard_EXPORT
	virtual Standard_Boolean IsDeleted(co</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 84-95</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 109-120[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Geom_Plane) aPlane = new Geom_
	myPlanes.push_back( GeomAdaptor_Surfa
	myPlanes.back().Load( aPlane );
	}
	}
	
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	
	void GEOMAlgo_FinderShapeOnQuad::CheckD</code></td>
          <td>	<code>Handle(Geom_Plane) aPlane = new Geom_
	
	myPlanes.push_back(GeomAdaptor_Surfac
	myPlanes.back().Load( aPlane );
	}
	}
	
	//===================================
	//function : GetCorners
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfQuad::GetCorners(gp_P</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Algo.cxx: line 51-78</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_HAlgo.cxx: line 52-79[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Algo::CheckData()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: CheckResult
	// purpose:
	//=====================================
	void GEOMAlgo_Algo::CheckResult()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: ErrorStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_Algo::ErrorSt
	{
	return myErrorStatus;
	}
	//=====================================
	// function: WarningStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_Algo::Warning
	{
	return myWarningStatus;
	}</code></td>
          <td>	<code>void GEOMAlgo_HAlgo::CheckData()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: CheckResult
	// purpose:
	//=====================================
	void GEOMAlgo_HAlgo::CheckResult()
	{
	myErrorStatus=0;
	}
	//=====================================
	// function: ErrorStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_HAlgo::Erro
	{
	return myErrorStatus;
	}
	//=====================================
	// function: WarningStatus
	// purpose:
	//=====================================
	Standard_Integer GEOMAlgo_HAlgo::Warn
	{
	return myWarningStatus;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 198-201</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 359-362[42]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt2.Initialize(aSD);
	for (; aIt2.More(); aIt2.Next()) {
	const TopoDS_Shape& aSi=aIt2.Value();
	if (aSi.ShapeType()!=TopAbs_SHELL) {</code></td>
          <td>	<code>aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aIm=aItIm.Key();
	if (aIm.ShapeType()!=TopAbs_FACE) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 692-700</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 744-752[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListOfShape aModifList;
	
	getModified(aSubShape, aModifList);
	
	// Copy shapes to the list of other s
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient</code></td>
          <td>	<code>TopTools_ListOfShape aModifList;
	
	getModified(aSubShape, aModifList);
	
	// Copy shapes to the list of other s
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 86-90</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 70-75[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeometryProcessor::prepareInput();
	if (myInputData->contains("myShapeOri
	myShapeOrientedBoundBoxes = myInputDa
	
	myGeometryProperties = myInputData->g
	</code></td>
          <td>	<code>myShapeBoundBoxes = myInputData->get<
	
	if (myInputData->contains("myShapeOri
	myShapeOrientedBoundBoxes = myInputDa
	
	myGeometryProperties = myInputData->g</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 70-75</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 86-90[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>myShapeBoundBoxes = myInputData->get<
	
	if (myInputData->contains("myShapeOri
	myShapeOrientedBoundBoxes = myInputDa
	
	myGeometryProperties = myInputData->g</code></td>
          <td>	<code>GeometryProcessor::prepareInput();
	if (myInputData->contains("myShapeOri
	myShapeOrientedBoundBoxes = myInputDa
	
	myGeometryProperties = myInputData->g
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 316-325</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 413-423[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}
	//
	aSt=myClsf->State();
	bIsConformState=GEOMAlgo_SurfaceTools
	</code></td>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}
	//
	aSt=myClsf->State();
	//
	bIsToBreak=aSC.AppendState(aSt);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 509-516</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 600-607[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	//
	GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(aC);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();</code></td>
          <td>	<code>return;
	}
	//
	GEOMAlgo_AlgoTools::MakeContainer(Top
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCX=aItC.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 610-620</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 650-660[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}// if (aCT==GeomAbs_Line) {
	//
	// Circle
	else if (aCT==GeomAbs_Circle) {
	gp_Circ aCirc;
	//
	aCirc=aGAC.Circle();
	aP=aCirc.Location();
	aAx2=aCirc.Position();
	aR1=aCirc.Radius();</code></td>
          <td>	<code>}
	}// else if (aCT==GeomAbs_Circle) {
	//
	// Ellipse
	else if (aCT==GeomAbs_Ellipse) {
	gp_Elips aElips;
	//
	aElips=aGAC.Ellipse();
	aP=aElips.Location();
	aAx2=aElips.Position();
	aR1=aElips.MajorRadius();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 464-477</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 495-508[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" number of compsolids : %d\n"
	printf(" number of compounds : %d\n",
	DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);
	}
	//=====================================
	//function : DumpCompSolid
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::DumpCompSolid(
	{
	Standard_Integer aNbV, aNbE, aNbF, aN</code></td>
          <td>	<code>printf(" number of faces : %d\n", aNb
	printf(" number of solids : %d\n", aN
	DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);
	}
	//=====================================
	//function : DumpSolid
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::DumpSolid()con
	{
	Standard_Integer aNbV, aNbE, aNbF;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 279-285</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 330-336[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator anIter(theShape);
	TopTools_MapOfShape aMapFence;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (aMapFence.Add(aSubShape)) {</code></td>
          <td>	<code>TopoDS_Iterator anIter(theShape);
	TopTools_MapOfShape aMapFence;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (aMapFence.Add(aSubShape)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.cxx: line 59-82</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 57-80[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : SetShape
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSolid::SetShape(con
	{
	myShape=aS;
	}
	//=====================================
	//function : Shape
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ClsfSoli
	{
	return myShape;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSolid::CheckData()
	{
	myErrorStatus=0;</code></td>
          <td>	<code>}
	//=====================================
	// function: SetShape2
	// purpose:
	//=====================================
	void GEOMAlgo_SolidSolid::SetShape2(con
	{
	myS2=aS2;
	}
	//=====================================
	// function: Shape2
	// purpose:
	//=====================================
	const TopoDS_Shape& GEOMAlgo_SolidSolid
	{
	return myS2;
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_SolidSolid::Perform()
	{
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 754-761</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 84-91[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>myGAS.Load(mySurface);
	aType=myGAS.GetType();
	aType==GeomAbs_Sphere)) {
	myErrorStatus=14; // unallowed surfac
	}
	}</code></td>
          <td>	<code>myGAS.Load(myS);
	aType=myGAS.GetType();
	aType==GeomAbs_Sphere)) {
	myErrorStatus=11; // unallowed surfac
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 94-96</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 71-75[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>assert len(shape.Solids) == 5
	assert shape.ShapeType == "CompSolid"
	assert len(shape.Faces) == 30 # 4 cub
	
	</code></td>
          <td>	<code># assert len(shape.Compounds) == 0
	assert shape.ShapeType == "CompSolid"
	
	assert len(shape.Faces) == nonshared_
	# 2 cubes shares 1 face, total 11 fac</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 752-756</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 768-772[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>myPnt1.Coord(aX, aY, aZ);
	printf(" Pnt1 : %.3lf %.3lf %.3lf\n",
	myPnt2.Coord(aX, aY, aZ);
	printf(" Pnt2 : %.3lf %.3lf %.3lf\n",
	}</code></td>
          <td>	<code>myPnt1.Coord(aX, aY, aZ);
	printf(" Pnt1 : %.3lf %.3lf %.3lf\n",
	myPnt2.Coord(aX, aY, aZ);
	printf(" Pnt2 : %.3lf %.3lf %.3lf\n",
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1194-1197</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 162-165[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLS=myIma
	aItLS.Initialize(aLS);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aSD=aItLS.Value()</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSIm=myI
	aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1096-1103</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 517-524[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aR>TopAbs_VERTEX) {
	return;
	}
	//
	aIt.Initialize(aS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSS=aIt.Value();
	aMSS.Add(aSS);</code></td>
          <td>	<code>if (aNbVSD < 2) {
	return ;
	}
	//
	aItLS.Initialize(aLVSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aVSD=aItLS.Value(
	aMVSD.Add(aVSD);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 146-149</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 204-207[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>def process_part_feature(self, o):
	d = self.shapes[o.attrib["name"]]
	for p in o.find("Properties").findall
	if p.attrib["name"] == "Label": # the</code></td>
          <td>	<code>if o.attrib["name"] in self.shapes.ke
	d = self.shapes[o.attrib["name"]]
	for p in o.find("Properties").findall
	if p.attrib["name"] == "ShapeColor":</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 71-75</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 94-96[41]</strong></td>
        </tr>
        <tr>
          <td>	<code># assert len(shape.Compounds) == 0
	assert shape.ShapeType == "CompSolid"
	
	assert len(shape.Faces) == nonshared_
	# 2 cubes shares 1 face, total 11 fac</code></td>
          <td>	<code>assert len(shape.Solids) == 5
	assert shape.ShapeType == "CompSolid"
	assert len(shape.Faces) == 30 # 4 cub
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 248-251</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 429-433[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLSIm=myI
	aItIm.Initialize(aLSIm);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(
	</code></td>
          <td>	<code>const TopTools_MapOfShape& aMSOn=mySh
	//aNbSOn=aMSOn.Extent();
	aItMS.Initialize(aMSOn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aV2=aItMS.Key();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 338-345</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 217-224[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIP=aIt1.Key();
	const TopoDS_Shape& aVP=aMIS.FindFrom
	if (!j) {
	aVF=aVP;
	}
	aLVSD.Append(aVP);
	aMVProcessed.Add(aVP);
	}</code></td>
          <td>	<code>aIndex=aIt.Value();
	const TopoDS_Shape& aVx=aMIS.FindFrom
	if(!j) {
	aVF=aVx;
	}
	aLVSD.Append(aVx);
	aMVProcessed.Add(aVx);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 302-307</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 325-329[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLC1.Clear();
	aIt.Initialize(aLC);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aC=aIt.Value(); /
	//
	aItC.Initialize(aC);</code></td>
          <td>	<code>aLC.Clear();
	aIt.Initialize(aLC1);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSC=aIt.Value();
	aLC.Append(aSC);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 158-167</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 168-176[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape& theC);
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Edge& theEdge,
	const Handle(IntTools_Context)& theCt
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Face& theFSr,</code></td>
          <td>	<code>const Handle(IntTools_Context)& theCt
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Shape& theSr,
	const Handle(IntTools_Context)& theCt
	Standard_EXPORT
	static Standard_Integer BuildPCurveFo
	const TopoDS_Edge& aEnew,
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 363-368</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 371-376[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>aKN=GEOMAlgo_KN_DISKCIRCLE;
	aInfo.SetKindOfName(aKN);
	aInfo.SetRadius1(aInfoE.Radius1());
	aInfo.SetLocation(aInfoE.Location());
	aInfo.SetPosition(aInfoE.Position());
	aInfo.SetKindOfDef(GEOMAlgo_KD_SPECIF</code></td>
          <td>	<code>aKN=GEOMAlgo_KN_DISKELLIPSE;
	aInfo.SetKindOfName(aKN);
	aInfo.SetRadius1(aInfoE.Radius1());
	aInfo.SetRadius2(aInfoE.Radius2());
	aInfo.SetLocation(aInfoE.Location());
	aInfo.SetPosition(aInfoE.Position());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 517-524</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1096-1103[41]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbVSD < 2) {
	return ;
	}
	//
	aItLS.Initialize(aLVSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aVSD=aItLS.Value(
	aMVSD.Add(aVSD);</code></td>
          <td>	<code>if (aR>TopAbs_VERTEX) {
	return;
	}
	//
	aIt.Initialize(aS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSS=aIt.Value();
	aMSS.Add(aSS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 729-736</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 369-376[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Ax3 aAx3(aAx2new);
	aInfo.SetLocation(aPc);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aRmax);
	aInfo.SetRadius2(aRmin);
	aInfo.SetHeight(aHeight);
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_SPECIF</code></td>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_SPHE
	aInfo.SetKindOfName(GEOMAlgo_KN_SPHER
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 487-495</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 224-230[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	aMEV.Add(aE, aLV);
	}
	// 2. Checking
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	//const TopoDS_Shape& aV=aItIm.Key();
	const TopTools_ListOfShape& aLVSD=aIt</code></td>
          <td>	<code>}
	myImages.Bind(aVF, aLVSD);
	}
	// Origins
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShapeMapHasher.hxx: line 28-52</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyMapHasher.hxx: line 28-51[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyShapeMapHasher
	#define _GEOMAlgo_PassKeyShapeMapHasher
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	#include <GEOMAlgo_PassKeyShape.hxx>
	
	//=====================================
	//class : GEOMAlgo_PassKeyShapeMapHashe
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyShapeMapHasher
	{
	public:
	Standard_EXPORT
	static Standard_Integer HashCode(cons
	const Standard_Integer Upper) ;
	
	Standard_EXPORT
	static Standard_Boolean IsEqual(const
	const GEOMAlgo_PassKeyShape& aPKey2)
	};
	#endif</code></td>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyMapHasher_Head
	#define _GEOMAlgo_PassKeyMapHasher_Head
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	#include <GEOMAlgo_PassKey.hxx>
	
	//=====================================
	//class : GEOMAlgo_PassKeyMapHasher
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyMapHasher {
	public:
	Standard_EXPORT
	static Standard_Integer HashCode(cons
	const Standard_Integer Upper) ;
	
	Standard_EXPORT
	static Standard_Boolean IsEqual(const
	const GEOMAlgo_PassKey& aPKey2) ;
	};
	#endif
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 68-78</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 79-89[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType==TopAbs_EDGE) {
	TopoDS_Edge aEE, aEEnew;
	//
	aEE=*((TopoDS_Edge*)&theS);
	MakeEdge(aEE, aEEnew);
	if (myErrorStatus) {
	return;
	}
	//
	theSnew=aEEnew;
	}</code></td>
          <td>	<code>else if (aType==TopAbs_FACE) {
	TopoDS_Face aFF, aFFnew;
	//
	aFF=*((TopoDS_Face*)&theS);
	MakeFace(aFF, aFFnew);
	if (myErrorStatus) {
	return;
	}
	//
	theSnew=aFFnew;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 146-152</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 639-644[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aItM
	//
	BOPTools_AlgoTools::MakeContainer(Top
	//
	aItMS.Initialize(aMFence);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS=aItMS.Key();</code></td>
          <td>	<code>aTol2=aTol*aTol;
	GEOMAlgo_AlgoTools::PointOnShape(aE1,
	//
	aIt.Initialize(aLE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aE2=aIt.Value();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 309-316</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 506-512[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType1=myGAS.GetType();
	//
	TopExp::MapShapes(myShape, TopAbs_EDG
	//
	bIsConformState=Standard_False;
	//
	aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {</code></td>
          <td>	<code>aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 400-400</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 206-206[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>############### module specific post pr</code></td>
          <td>	<code>##################### module specific p</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyMapHasher.hxx: line 28-51</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShapeMapHasher.hxx: line 28-52[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyMapHasher_Head
	#define _GEOMAlgo_PassKeyMapHasher_Head
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	#include <GEOMAlgo_PassKey.hxx>
	
	//=====================================
	//class : GEOMAlgo_PassKeyMapHasher
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyMapHasher {
	public:
	Standard_EXPORT
	static Standard_Integer HashCode(cons
	const Standard_Integer Upper) ;
	
	Standard_EXPORT
	static Standard_Boolean IsEqual(const
	const GEOMAlgo_PassKey& aPKey2) ;
	};
	#endif
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_PassKeyShapeMapHasher
	#define _GEOMAlgo_PassKeyShapeMapHasher
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	#include <Standard_Boolean.hxx>
	#include <GEOMAlgo_PassKeyShape.hxx>
	
	//=====================================
	//class : GEOMAlgo_PassKeyShapeMapHashe
	//purpose :
	//=====================================
	class GEOMAlgo_PassKeyShapeMapHasher
	{
	public:
	Standard_EXPORT
	static Standard_Integer HashCode(cons
	const Standard_Integer Upper) ;
	
	Standard_EXPORT
	static Standard_Boolean IsEqual(const
	const GEOMAlgo_PassKeyShape& aPKey2)
	};
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 108-132</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 145-169[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	return myContext;
	}
	//=====================================
	//function : Images
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myImages;
	}
	//=====================================
	//function : Origins
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeShape& GEO
	{
	return myOrigins;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::Clear()
	{</code></td>
          <td>	<code>{
	return myShapeWhere;
	}
	//=====================================
	//function : ShapesIn
	//purpose :
	//=====================================
	const GEOMAlgo_DataMapOfShapeMapOfShape
	{
	return myShapesIn;
	}
	//=====================================
	//function : ShapesOn
	//purpose :
	//=====================================
	const GEOMAlgo_DataMapOfShapeMapOfShape
	{
	return myShapesOn;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::Clear()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 143-146</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 167-169[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>Data data = Data(length, 1);
	// B& ref = cdata;
	d.set("C", std::move(data)); // templ
	REQUIRE(d.get<Data>("C")->size() == l</code></td>
          <td>	<code>data.resize(length, 2); // refill the
	d.setSerializable("C_S", std::move(da
	REQUIRE(d.get<Data>("C_S")->size() ==
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 156-159</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 384-387[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLSD=aItD
	aItLS1.Initialize(aLSD);
	for (; aItLS1.More(); aItLS1.Next())
	const TopoDS_Shape& aSx=aItLS1.Value(</code></td>
          <td>	<code>const TopTools_ListOfShape& aLVSD=aIt
	aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 206-206</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 400-400[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>##################### module specific p</code></td>
          <td>	<code>############### module specific post pr</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 841-853</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 917-928[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>void DumpKindOfClosed(const GEOMAlgo_Ki
	{
	const char *pStr[]={
	"KC_UNKNOWN",
	"KC_CLOSED",
	"KC_NOTCLOSED"
	};
	int i;
	//
	i=(Standard_Integer)aKC;
	printf(" KindOfClosed: %s\n", pStr[i]
	
	}</code></td>
          <td>	<code>void DumpKindOfDef(const GEOMAlgo_KindO
	{
	const char *pStr[]={
	"KD_UNKNOWN",
	"KD_SPECIFIED",
	"KB_ARBITRARY"
	};
	int i;
	//
	i=(Standard_Integer)aKD;
	printf(" KindOfDef: %s\n", pStr[i]);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 555-562</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 598-605[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>else if (aKN==GEOMAlgo_KN_POLYHEDRON)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	}
	else if (aKN==GEOMAlgo_KN_BOX) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Length : %.3lf\n", myLength)</code></td>
          <td>	<code>if (aKN==GEOMAlgo_KN_PLANE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	}
	else if (aKN==GEOMAlgo_KN_DISKCIRCLE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 105-120</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 213-227[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_SurfaceTools::GetState(myPnt
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfSurf::C
	{
	GeomAbs_SurfaceType aST;
	GeomAbs_CurveType aCT;
	GeomAdaptor_Curve aGAC;
	//
	aGAC.Load(aC);
	aCT=aGAC.GetType();
	//
	aST=myGAS.GetType();</code></td>
          <td>	<code>return GEOMAlgo_Clsf::CanBeON(aC);
	}
	//=====================================
	//function : CanBeON
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ClsfBox::Ca
	{
	Standard_Boolean bRet;
	GeomAbs_SurfaceType aST1;
	GeomAdaptor_Surface aGAS1;
	//
	aGAS1.Load(aS1);
	aST1=aGAS1.GetType();
	bRet=(aST1==GeomAbs_Plane);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 112-115</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 124-127[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>if o.attrib["type"].find("App::Part")
	self.parts[o.attrib["name"]] = {
	"type": o.attrib["type"],
	"id": o.attrib["id"],</code></td>
          <td>	<code>elif o.attrib["type"].find("App::Docu
	self.groups[o.attrib["name"]] = {
	"type": o.attrib["type"],
	"id": o.attrib["id"],</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 639-644</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 146-152[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>aTol2=aTol*aTol;
	GEOMAlgo_AlgoTools::PointOnShape(aE1,
	//
	aIt.Initialize(aLE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aE2=aIt.Value();
	</code></td>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aItM
	//
	BOPTools_AlgoTools::MakeContainer(Top
	//
	aItMS.Initialize(aMFence);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS=aItMS.Key();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 165-168</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 205-208[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>d = groups[o.attrib["name"]]
	for p in o.find("Properties").findall
	if p.attrib["name"] == "Label":
	d["label"] = p.find("String").attrib[</code></td>
          <td>	<code>d = self.shapes[o.attrib["name"]]
	for p in o.find("Properties").findall
	if p.attrib["name"] == "ShapeColor":
	d["color"] = unpack_color_value(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 30-33</strong></td>
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 34-37    [40]</strong></td>
        </tr>
        <tr>
          <td>	<code>p.value = j["value"].get<T>();
	if (j.contains("name"))
	p.name = j["name"].get<std::string>()
	if (j.contains("doc"))</code></td>
          <td>	<code>p.doc = j["doc"].get<std::string>();
	if (j.contains("unit"))
	p.unit = j["unit"].get<std::string>()
	if (j.contains("range"))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 159-163</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 168-171[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>d.setValue<Data>("CP_V", cref);
	REQUIRE(d.get<Data>("CP_V")->size() =
	
	// test const, const can not be moved
	d.set<const Data>("CP_C", std::make_s</code></td>
          <td>	<code>d.setSerializable("C_S", std::move(da
	REQUIRE(d.get<Data>("C_S")->size() ==
	
	d.setSerializable<const Data>("CP_S",
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 237-240</strong></td>
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 51-52    [40]</strong></td>
        </tr>
        <tr>
          <td>	<code>j = json{{"volume", p.volume}, {"area
	{"perimeter", p.perimeter}, {"toleran
	{"solidCount", p.solidCount}, {"faceC
	{"edgeCount", p.edgeCount}, {"centerO</code></td>
          <td>	<code>return json{{"type", p.type}, {"name"
	{"range", p.range}, {"unit", p.unit},
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 959-964</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 118-123[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>aTol=BRep_Tool::Tolerance(aFFWD);
	BRepTools::UVBounds(aF, aUMin, aUMax,
	//
	aBB.MakeFace (newFace, aS, aLoc, aTol
	//
	aExpW.Init(aFFWD, TopAbs_WIRE);</code></td>
          <td>	<code>bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP
	BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	aBB.MakeFace (aFnew, aS, aLoc, aTol);
	//
	aItW.Initialize(aFF);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 54-56</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 242-246[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	class StackedBoxesTest(GeomTestBase):
	def build_geometry(self, doc):
	
	</code></td>
          <td>	<code>#######################################
	
	
	class PipelineController(object):
	def __init__(self):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 873-888</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 907-922[40]</strong></td>
        </tr>
        <tr>
          <td>	<code>};
	int i;
	//
	i=(Standard_Integer)aKS;
	printf(" KindOfShape : %s\n", pStr[i]
	}
	//=====================================
	//function : DumpKindOfName
	//purpose :
	//=====================================
	void DumpKindOfName(const GEOMAlgo_Kind
	{
	const char *pStr[]={
	"KN_UNKNOWN",
	"KN_SPHERE",
	"KN_CYLINDER",</code></td>
          <td>	<code>};
	int i;
	//
	i=(Standard_Integer)aKS;
	printf(" KindOfName : %s\n", pStr[i])
	}
	//=====================================
	//function : DumpKindOfDef
	//purpose :
	//=====================================
	void DumpKindOfDef(const GEOMAlgo_KindO
	{
	const char *pStr[]={
	"KD_UNKNOWN",
	"KD_SPECIFIED",
	"KB_ARBITRARY"</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 858-872</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 883-897[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>void DumpKindOfShape(const GEOMAlgo_Kin
	{
	const char *pStr[]={
	"KS_UNKNOWN",
	"KS_SPHERE",
	"KS_CYLINDER",
	"KS_BOX",
	"KS_TORUS",
	"KS_CONE",
	"KS_ELLIPSE",
	"KS_PLANE",
	"KS_CIRCLE",
	"KS_LINE",
	"KS_DEGENERATED",
	"KS_BSPLINE"</code></td>
          <td>	<code>void DumpKindOfName(const GEOMAlgo_Kind
	{
	const char *pStr[]={
	"KN_UNKNOWN",
	"KN_SPHERE",
	"KN_CYLINDER",
	"KN_TORUS",
	"KN_CONE",
	"KN_ELLIPSE",
	"KN_CIRCLE",
	"KN_PLANE",
	"KN_LINE",
	"KN_BOX",
	"KN_SEGMENT",
	"KN_ARCCIRCLE",</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 125-127</strong></td>
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 129-131[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!::gmtime_s(&tm, &as_time_t)) //
	if (std::strftime(some_buffer, sizeof
	return std::string{some_buffer};</code></td>
          <td>	<code>if (::gmtime_r(&as_time_t, &tm)) // C
	if (std::strftime(some_buffer, sizeof
	return std::string{some_buffer};</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/TypeDefs.h: line 93-103</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 19-26[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>DenseMatrix, ///< 2D traverse, both o
	/// coupled operation
	SparseMatrix, ///< must provide a ind
	FilteredMatrix, ///< executor will ca
	
	};
	
	NLOHMANN_JSON_SERIALIZE_ENUM(IndexPat
	{IndexPattern::Linear, "Linear"},
	{IndexPattern::UpperTriangle, "UpperT
	{IndexPattern::LowerTriangle, "LowerT</code></td>
          <td>	<code>UniqueId, ///!< geometry ID hashed fr
	GeometryFile, ///!< read the geometry
	BoundBox, ///!< axis align bound box,
	};
	NLOHMANN_JSON_SERIALIZE_ENUM(ShapeSea
	{ShapeSearchType::UniqueId, "UniqueId
	{ShapeSearchType::GeometryFile, "Geom
	{ShapeSearchType::BoundBox, "BoundBox
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 308-311</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 487-490[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aS=aItC.Value();
	aType=aS.ShapeType();
	if (aType==TopAbs_COMPOUND) {</code></td>
          <td>	<code>for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();
	aType=aCx.ShapeType();
	if (aType==TopAbs_COMPOUND) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 85-92</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 136-143[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>def validate_geometry(self, shape):
	print(
	"geometry info (type, solid count, fa
	shape.ShapeType,
	len(shape.Solids),
	len(shape.Faces),
	)
	N = len(shape.Solids)</code></td>
          <td>	<code>def validate_geometry(self, shape):
	print(
	"geometry info (type, solid count, fa
	shape.ShapeType,
	len(shape.Solids),
	len(shape.Faces),
	)
	N = len(shape.Solids)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 24-27</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 42-45[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>nBoxes = N ** dim
	# Part.makeBox(length, length, length
	boxes = [doc.addObject("Part::Box", "
	for z in range(N):</code></td>
          <td>	<code>nBoxes = N
	# Part.makeBox(length, length, length
	boxes = [doc.addObject("Part::Box", "
	for x in range(N):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 339-344</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1003-1008[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean isToRm = Standard_Tr
	
	for (; anAncIt.More(); anAncIt.Next()
	const TopoDS_Shape &anAncShape = anAn
	
	if (!myMapRemoved.Contains(anAncShape</code></td>
          <td>	<code>Standard_Boolean isComposedOri = Stan
	
	for (; aSubShIt.More(); aSubShIt.Next
	const TopoDS_Shape &aSubSh = aSubShIt
	
	if (!aMapSubShapes.Contains(aSubSh))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 240-240</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 241-241[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Solid box2 = BRepPrimAPI_MakeB</code></td>
          <td>	<code>TopoDS_Solid box3 = BRepPrimAPI_MakeB</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 737-743</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 805-812[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (const auto& p : row)
	{
	const auto& cinfo = p.second;
	auto j = cinfo.second;
	if (cinfo.type == CollisionType::Coin
	{
	if (i < j) // remove either is fine,
	</code></td>
          <td>	<code>for (const auto& p : row)
	{
	const auto& cinfo = p.second;
	auto j = cinfo.second;
	// ignore CollisionType::Unknown, it
	if (cinfo.type == CollisionType::Unkn
	{
	if (not(itemSuppressed(i) or itemSupp</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 481-489</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 585-592[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aItC;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();
	aType=aCx.ShapeType();</code></td>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	bHasImage=Standard_False;
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();
	bHasImage=HasImage(aCx);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 310-316</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 524-531[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>aM.Add(aS);
	}
	//
	aIt.Initialize(aS);
	for(; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();
	aType=aSx.ShapeType();
	</code></td>
          <td>	<code>aMVSD.Add(aVSD);
	}
	//
	aItLS.Initialize(aLVSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aVSD=aItLS.Value(
	//
	iRet=CheckAncesstors(aVSD, aMVSD, aMV</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 248-250</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 214-217[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>j.at("tolerance").get_to(p.tolerance)
	j.at("solidCount").get_to(p.solidCoun
	j.at("faceCount").get_to(p.faceCount)
	</code></td>
          <td>	<code>j.at("name").get_to(p.name);
	j.at("type").get_to(p.type);
	// j.at("data").get_to(p.data);
	j.at("flag").get_to(p.flag); // enum</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 612-617</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1030-1035[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator anIter(theFOrSo);
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (aSubShape.IsSame(anOuterSubShape)</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSubSi = aItLS.Va
	
	if (aMSx.Add(aSubSi)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 455-458</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 311-314[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(aF, TopAbs_VERTEX,
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);</code></td>
          <td>	<code>aNb=aM.Extent();
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 163-178</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 197-212[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (bIsConformState) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();</code></td>
          <td>	<code>if (aS.ShapeType()==myShapeType) {
	pL->Append(aS);
	}
	}
	return myLS;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 103-115</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 118-130[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetLocation(const gp_Pnt& aP) ;
	
	Standard_EXPORT
	const gp_Pnt& Location() const;
	
	Standard_EXPORT
	void SetDirection(const gp_Dir& aD) ;
	
	Standard_EXPORT
	const gp_Dir& Direction() const;
	
	Standard_EXPORT
	void SetPosition(const gp_Ax2& aAx2)</code></td>
          <td>	<code>void SetPosition(const gp_Ax3& aAx3)
	
	Standard_EXPORT
	const gp_Ax3& Position() const;
	
	Standard_EXPORT
	void SetPnt1(const gp_Pnt& aP) ;
	
	Standard_EXPORT
	const gp_Pnt& Pnt1() const;
	
	Standard_EXPORT
	void SetPnt2(const gp_Pnt& aP) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 322-327</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 553-558[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(aS, TopAbs_VERTEX,
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_GProps aGPropsX;
	//
	const TopoDS_Vertex& aVX=*((TopoDS_Ve</code></td>
          <td>	<code>TopExp::MapShapes(myShape, TopAbs_SOL
	aNbS=aM.Extent();
	for (i=1; i<=aNbS; ++i) {
	GEOMAlgo_StateCollector aSC;
	//
	const TopoDS_Shape& aSd=aM(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 552-558</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 597-603[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetLength(aLength);
	//
	aXYZ1=aP1.XYZ();
	aXYZ2=aP2.XYZ();
	aXYZc=aXYZ1+aXYZ2;
	aXYZc.Multiply(0.5);
	aPc.SetXYZ(aXYZc);</code></td>
          <td>	<code>aLength=aP1.Distance(aP2);
	aXYZ1=aP1.XYZ();
	aXYZ2=aP2.XYZ();
	aXYZc=aXYZ1+aXYZ2;
	aXYZc.Multiply(0.5);
	//
	aPc.SetXYZ(aXYZc);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 239-239</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 240-240[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Solid box1 = BRepPrimAPI_MakeB</code></td>
          <td>	<code>TopoDS_Solid box2 = BRepPrimAPI_MakeB</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 139-159</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 101-120[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	//=====================================
	//function : GetResult
	//purpose :
	//=====================================
	const TopoDS_Shape &GEOMAlgo_Extractor:
	{
	return myResult;
	}
	
	//=====================================
	//function : clear
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::clear()
	{
	myErrorStatus = 1;
	myWarningStatus = 0;
	myResult.Nullify();
	myRemoved.Clear();</code></td>
          <td>	<code>}
	//=====================================
	//function : SolidsAlone
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_
	{
	return mySolidsAlone;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	mySolidsToGlue.Clear();
	mySolidsAlone.Clear();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 719-725</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 383-390[39]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	aMEE.Add(aS, aLESD);
	//
	aIt1.Initialize(aLESD);
	for (; aIt1.More(); aIt1.Next()) {
	const TopoDS_Shape& aE1=aIt1.Value();
	</code></td>
          <td>	<code>}
	//
	myImages.Bind(aS1, aLSDF);
	//
	// origins
	aItLS.Initialize(aLSDF);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aFSD=aItLS.Value(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1353-1357</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 426-431[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aZoneSubShapes.Append(aSubShape);
	anExp.Init(aSubShape, aBoundType);
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aSubSubShape = an
	</code></td>
          <td>	<code>aNewSolid.Orientation(anOr);
	//
	aExp.Init(aSolid, TopAbs_SHELL);
	for (; aExp.More(); aExp.Next())
	{
	const TopoDS_Shape& aShell=aExp.Curre</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.cxx: line 66-85</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 136-155[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_CoupleOfShapes::SetShape2
	{
	myShape2=aS2;
	}
	//=====================================
	//function : Shape1
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_CoupleOfSh
	{
	return myShape1;
	}
	//=====================================
	//function : Shape2
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_CoupleOfSh
	{
	return myShape2;
	}</code></td>
          <td>	<code>void GEOMAlgo_GetInPlace::SetShapeWhere
	{
	myShapeWhere=theShape;
	}
	//=====================================
	//function : ShapeWhere
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_GetInPlace
	{
	return myShapeWhere;
	}
	//=====================================
	//function : ShapesIn
	//purpose :
	//=====================================
	const GEOMAlgo_DataMapOfShapeMapOfShape
	{
	return myShapesIn;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 493-503</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 705-715[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Geom_Curve) aC3D;
	TopoDS_Edge aE;
	//-----------------------------------
	if (myMapInfo.Contains(aS)) {
	return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C</code></td>
          <td>	<code>gp_Pnt aP;
	TopoDS_Vertex aV;
	//
	if (myMapInfo.Contains(aS)) {
	return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 456-460</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 479-484[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (Utilities::hasFileExt(file_name,
	{
	STEPCAFControl_Reader aReader;
	aReader.SetColorMode(true);
	aReader.SetNameMode(true);
	</code></td>
          <td>	<code>else if (Utilities::hasFileExt(file_n
	{
	// IGESControl_Controller::Init();
	IGESCAFControl_Reader aReader;
	aReader.SetColorMode(true);
	aReader.SetNameMode(true);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 212-220</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 248-254[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>set<T>(key, std::make_shared<T>(std::
	}
	
	/* set value by move semantics, given
	* it is enforced by type trait at com
	* by `std::enable_if<std::is_rvalue_r
	*/
	template <class DType, typename = std
	void set(const std::string& key, DTyp</code></td>
          <td>	<code>myProperties.emplace(key, std::move(p
	}
	
	/** accept only rvalue, produced by s
	*/
	template <class T, typename = std::en
	void setSerializable(const std::strin
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.hxx: line 28-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.hxx: line 28-56[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_WireSolid_HeaderFile
	#define _GEOMAlgo_WireSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_WireSolid
	//purpose :
	//=====================================
	class GEOMAlgo_WireSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() ;
	};
	#endif
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_VertexSolid_HeaderFil
	#define _GEOMAlgo_VertexSolid_HeaderFil
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_VertexSolid
	//purpose :
	//=====================================
	class GEOMAlgo_VertexSolid : public GEO
	{
	public:
	Standard_EXPORT
	GEOMAlgo_VertexSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_VertexSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() ;
	};
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 786-791</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 795-800[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItMS.Initialize(aMSOn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aSD1, aS2);
	}
	}</code></td>
          <td>	<code>aItMS.Initialize(aMSIn);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS2=aItMS.Key();
	FillShapesOn(aSD1, aS2);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 350-350</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 400-400[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>############### module specific pipelin</code></td>
          <td>	<code>############### module specific post pr</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 109-121</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/CMakeLists.txt: line 122-134[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>#GEOMAlgo_GetInPlaceAPI.cxx
	GEOMAlgo_GlueAnalyser.cxx
	GEOMAlgo_GlueDetector.cxx
	GEOMAlgo_Gluer.cxx
	GEOMAlgo_Gluer2.cxx
	GEOMAlgo_Gluer2_1.cxx
	GEOMAlgo_Gluer2_2.cxx
	GEOMAlgo_Gluer2_3.cxx
	GEOMAlgo_GluerAlgo.cxx
	GEOMAlgo_HAlgo.cxx
	GEOMAlgo_PassKey.cxx
	GEOMAlgo_PassKeyMapHasher.cxx
	GEOMAlgo_PassKeyShape.cxx</code></td>
          <td>	<code>GEOMAlgo_PassKeyShapeMapHasher.cxx
	GEOMAlgo_RemoverWebs.cxx
	GEOMAlgo_ShapeAlgo.cxx
	GEOMAlgo_ShapeInfo.cxx
	GEOMAlgo_ShapeInfoFiller.cxx
	GEOMAlgo_ShapeInfoFiller_1.cxx
	GEOMAlgo_ShapeSolid.cxx
	GEOMAlgo_ShellSolid.cxx
	GEOMAlgo_SolidSolid.cxx
	GEOMAlgo_Splitter.cxx
	GEOMAlgo_StateCollector.cxx
	GEOMAlgo_SurfaceTools.cxx
	GEOMAlgo_VertexSolid.cxx</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 121-123</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 123-124[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	
	# header install, binded with other lib</code></td>
          <td>	<code>#######################################
	# configuration header, shared by all p
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 684-691</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 793-799[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSubShapeType = TopAbs_SOLID;
	//aSubSubShapeType = TopAbs_FACE;
	}
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (myMapModified.IsBound(aSubShape))</code></td>
          <td>	<code>aComplexBndType = TopAbs_SHELL;
	}
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aShape = anExp.Cu
	
	if (aMapFence.Add(aShape)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 158-163</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 169-172[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(floatEqual(perimeter(mkGFA->S
	REQUIRE(ctype == CollisionType::FaceC
	// REQUIRE(detectCollisionType(aCylin
	
	// todo:
	TopoDS_Shape box2 = BRepPrimAPI_MakeB</code></td>
          <td>	<code>REQUIRE(floatEqual(perimeter(mkGFA->S
	REQUIRE(ctype == CollisionType::EdgeC
	
	TopoDS_Shape box3 = BRepPrimAPI_MakeB
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 77-80</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 199-202[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();
	if (aS.ShapeType()!=TopAbs_SOLID) {
	myErrorStatus=11;</code></td>
          <td>	<code>for (; aIt2.More(); aIt2.Next()) {
	const TopoDS_Shape& aSi=aIt2.Value();
	if (aSi.ShapeType()!=TopAbs_SHELL) {
	aOr=aSi.Orientation();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 244-249</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 194-199[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItDMSLS.Initialize(myShapesToGlue);
	for (; aItDMSLS.More(); aItDMSLS.Next
	//const TopoDS_Shape& aSkey=aItDMSLS.
	const TopTools_ListOfShape& aLSG=aItD
	aItLS.Initialize(aLSG);
	for (i=0; aItLS.More(); aItLS.Next(),</code></td>
          <td>	<code>aIt1.Initialize(aShape);
	for (; aIt1.More(); aIt1.Next()) {
	const TopoDS_Shape& aSD=aIt1.Value();
	//
	aIt2.Initialize(aSD);
	for (; aIt2.More(); aIt2.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.hxx: line 28-56</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.hxx: line 28-55[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_VertexSolid_HeaderFil
	#define _GEOMAlgo_VertexSolid_HeaderFil
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_VertexSolid
	//purpose :
	//=====================================
	class GEOMAlgo_VertexSolid : public GEO
	{
	public:
	Standard_EXPORT
	GEOMAlgo_VertexSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_VertexSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() ;
	};
	#endif</code></td>
          <td>	<code>#ifndef _GEOMAlgo_WireSolid_HeaderFile
	#define _GEOMAlgo_WireSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_WireSolid
	//purpose :
	//=====================================
	class GEOMAlgo_WireSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() ;
	};
	#endif
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 621-630</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 729-736[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aKN==GEOMAlgo_KN_POLYGON) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	}
	//
	// SPHERE
	else if (aKN==GEOMAlgo_KN_SPHERE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf", myRadius1)</code></td>
          <td>	<code>if (aKN==GEOMAlgo_KN_LINE) {
	DumpLocation (myLocation);
	DumpDirection(myDirection);
	}
	else if (aKN==GEOMAlgo_KN_SEGMENT) {
	DumpLocation (myLocation);
	DumpDirection(myDirection);
	printf(" Length : %.3lf\n", myLength)
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 477-483</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1398-1406[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myMapShapeAnc.IsBound(theWire)) {
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aParent = anIter.
	
	if (aParent.ShapeType() == TopAbs_FAC
	</code></td>
          <td>	<code>const TopAbs_ShapeEnum theShapeType)
	{
	// This shape is modified.
	TopTools_ListIteratorOfListOfShape an
	
	for (; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aSubShape = anIt.
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 171-181</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 223-234  [38]</strong></td>
        </tr>
        <tr>
          <td>	<code>myDataStorage = std::make_shared<Data
	// myDataStorage->setStoragePath(stor
	myConfig["dataStorage"] = storageInfo
	}
	
	void Context::setupLogger(const Config&
	{
	Config logConfig;
	if (config.contains("logger"))
	{
	logConfig = config["logger"];
	</code></td>
          <td>	<code>loguru::add_file(myLogFile.c_str(), l
	
	myConfig["logger"] = logConfig;
	}
	
	// todo: may merge into storageInfo
	void Context::setupParallelism(const Co
	{
	Config myParallism;
	if (config.contains("parallelism"))
	{
	myParallism = config["parallelism"];</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 170-180</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 200-210[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>return any_cast<default_pointer_type<
	}
	else
	{
	throw std::runtime_error("no property
	}
	}
	
	/** const version of get property dat
	* */
	template <typename T> T getValue(cons</code></td>
          <td>	<code>return any_cast<default_pointer_type<
	}
	else
	{
	throw std::runtime_error("no property
	}
	}
	
	/// set value by move semantics, like
	/// produced by std::move(your_type)
	template <typename T> void emplace(co</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 330-336</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 737-743[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator anIter(theShape);
	TopTools_MapOfShape aMapFence;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (aMapFence.Add(aSubShape)) {</code></td>
          <td>	<code>TopoDS_Iterator anIter(theCompound);
	TopTools_ListOfShape aNewSubShapes;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	if (myMapModified.IsBound(aSubShape))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/TypeDefs.h: line 104-108</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 78-82[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>{IndexPattern::DenseMatrix, "DenseMat
	{IndexPattern::SparseMatrix, "SparseM
	{IndexPattern::FilteredMatrix, "Filte
	{IndexPattern::PartitionIdVector, "Pa
	});</code></td>
          <td>	<code>{ShapeType::Wire, "Wire"},
	{ShapeType::Face, "Face"},
	{ShapeType::Edge, "Edge"},
	{ShapeType::Vertex, "Vertex"},
	});</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 395-398</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 150-153[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLS.Initialize(aLSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aEx=aItLS.Value()
	myOrigins.Bind(aEx, aEnew);</code></td>
          <td>	<code>aItMS.Initialize(aMFence);
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aS=aItMS.Key();
	aBB.Add(aShape, aS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 249-272</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 96-119[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>SetPosition(aAx3);
	}
	//=====================================
	//function : SetPosition
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPosition(co
	{
	myPosition=aAx3;
	}
	//=====================================
	//function : Position
	//purpose :
	//=====================================
	const gp_Ax3& GEOMAlgo_ShapeInfo::Posit
	{
	return myPosition;
	}
	
	//=====================================
	//function : SetPnt1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPnt1(const</code></td>
          <td>	<code>return myDetector.StickedShapes();
	}
	//=====================================
	//function : SetShapesToGlue
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::SetShapesToGlue
	(const TopTools_DataMapOfShapeListOfS
	{
	myShapesToGlue=aM;
	}
	//=====================================
	//function : ShapesToGlue
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myShapesToGlue;
	}
	//=====================================
	//function : SetKeepNonSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::SetKeepNonSolids(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 96-119</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 249-272[38]</strong></td>
        </tr>
        <tr>
          <td>	<code>return myDetector.StickedShapes();
	}
	//=====================================
	//function : SetShapesToGlue
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::SetShapesToGlue
	(const TopTools_DataMapOfShapeListOfS
	{
	myShapesToGlue=aM;
	}
	//=====================================
	//function : ShapesToGlue
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeListOfShap
	{
	return myShapesToGlue;
	}
	//=====================================
	//function : SetKeepNonSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::SetKeepNonSolids(</code></td>
          <td>	<code>SetPosition(aAx3);
	}
	//=====================================
	//function : SetPosition
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPosition(co
	{
	myPosition=aAx3;
	}
	//=====================================
	//function : Position
	//purpose :
	//=====================================
	const gp_Ax3& GEOMAlgo_ShapeInfo::Posit
	{
	return myPosition;
	}
	
	//=====================================
	//function : SetPnt1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPnt1(const</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 76-85</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 172-180[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	GEOMAlgo_GluerAlgo::Clear();
	//
	myImagesDetected.Clear();
	myOriginsDetected.Clear();
	myShapesToGlue.Clear();
	myImagesToWork.Clear();
	myOriginsToWork.Clear();</code></td>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	GEOMAlgo_GluerAlgo::Clear();
	myIterator.Clear();
	myShapesIn.Clear();
	myShapesOn.Clear();
	myShapesInclusive.Clear();
	myMapShapePnt.Clear();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 34-38</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 55-59[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>box = doc.addObject("Part::Box", "Box
	box.Width = 9 # Y axis length, make t
	objs.append(box)
	
	doc.recompute()</code></td>
          <td>	<code>box = doc.addObject("Part::Box", "Box
	box.Width = 10 # Y axis length, make
	objs.append(box)
	
	doc.recompute()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 228-237</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 269-278[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//-----------------------------------
	aInfo.SetType(aType);
	FillNbSubShapes(aS, aInfo);</code></td>
          <td>	<code>return;
	}
	else {
	GEOMAlgo_ShapeInfo aInfoX;
	myMapInfo.Add(aS, aInfoX);
	}
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//-----------------------------------
	aInfo.SetType(TopAbs_SOLID);
	FillNbSubShapes(aS, aInfo);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 104-109</strong></td>
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 51-55[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRep_Builder cBuilder;
	TopoDS_Shape shape;
	
	BRepTools::Read(shape, file_name.c_st
	if (shape.IsNull())
	throw std::runtime_error("brep read d</code></td>
          <td>	<code>BRep_Builder cBuilder;
	TopoDS_Shape shape;
	BRepTools::Read(shape, filename.c_str
	if (shape.IsNull())
	throw std::runtime_error("brep read d
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 1-11</strong></td>
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 1-11[37]</strong></td>
        </tr>
        <tr>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	import json
	import unittest
	
	"""feature test done by FreeCAD script,</code></td>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	import json
	import unittest
	
	"""</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 115-124</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 64-80[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	NoCollision = 0, ///< not related, XO
	Clearance = 1, ///< within a gap thre
	VertexContact = 2, ///< only share ve
	EdgeContact = 4, ///< share edge, but
	FaceContact = 8, ///< face contact, t
	WeakInterference = 16, ///< small int
	Interference = 32, ///< overlapping,
	Coincidence = 64, ///< identical shap
	Enclosure = 128, ///< a smaller shape
	
	
	
	
	
	
	</code></td>
          <td>	<code>{
	None = 0, /*!< No special property ty
	
	/// document transaction management,
	Output = 4, /*!< Modified property do
	NoRecompute = 16, /*!< Modified prope
	
	///
	internal = 32, /*!< Access control, p
	Immutable = 64, /*!< Property is read
	
	Hidden = 128, /*!< Property won't app
	ReadOnly = 256, /*!< Property is read
	
	// serializable, jsonizable
	ExternalLink = 512, /*!< large data i
	Transient = 1024, /*!< tranisent or t</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 570-573</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 385-388[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLV.Initialize(*pLV);
	for (; aItLV.More(); aItLV.Next()) {
	const TopoDS_Shape& aV=aItLV.Value();
	if (!aV.IsSame(aVSD)) {</code></td>
          <td>	<code>aItS.Initialize(aLVSD);
	for (; aItS.More(); aItS.Next()) {
	const TopoDS_Shape& aVSD=aItS.Value()
	if (!myOrigins.IsBound(aVSD)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 170-172</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 247-249[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLSG=aItD
	aItLS1.Initialize(aLSG);
	for (i=0; aItLS1.More(); aItLS1.Next(</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSG=aItD
	aItLS.Initialize(aLSG);
	for (i=0; aItLS.More(); aItLS.Next(),</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 369-375</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 139-144[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>myImages.UnBind(aV);
	}
	//
	// Bind new vertices
	aItIm.Initialize(aMVV);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aV=aItIm.Key();</code></td>
          <td>	<code>aLEr.Append(aEr);
	}
	//
	aItLE.Initialize(aLEr);
	for (; aItLE.More(); aItLE.Next()) {
	const TopoDS_Shape& aEr=aItLE.Value()
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 661-674</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 724-737[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!aNewShapes.IsEmpty()) {
	// Store modified shapes.
	myMapModified.ChangeFind(theFOrSo) =
	}
	}
	
	//=====================================
	//function : processShOrCS
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::processShOrCS(
	{
	// Treat sub-shapes.
	TopoDS_Iterator anIter(theShOrCS);</code></td>
          <td>	<code>if (!aNewOtherShapes.IsEmpty()) {
	// Store modified shapes.
	myMapModified.ChangeFind(theShOrCS) =
	}
	}
	
	//=====================================
	//function : processCompound
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::processCompoun
	{
	// Treat sub-shapes.
	TopoDS_Iterator anIter(theCompound);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 64-80</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 115-124[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	None = 0, /*!< No special property ty
	
	/// document transaction management,
	Output = 4, /*!< Modified property do
	NoRecompute = 16, /*!< Modified prope
	
	///
	internal = 32, /*!< Access control, p
	Immutable = 64, /*!< Property is read
	
	Hidden = 128, /*!< Property won't app
	ReadOnly = 256, /*!< Property is read
	
	// serializable, jsonizable
	ExternalLink = 512, /*!< large data i
	Transient = 1024, /*!< tranisent or t</code></td>
          <td>	<code>{
	NoCollision = 0, ///< not related, XO
	Clearance = 1, ///< within a gap thre
	VertexContact = 2, ///< only share ve
	EdgeContact = 4, ///< share edge, but
	FaceContact = 8, ///< face contact, t
	WeakInterference = 16, ///< small int
	Interference = 32, ///< overlapping,
	Coincidence = 64, ///< identical shap
	Enclosure = 128, ///< a smaller shape
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 44-51</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 473-480[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (const auto& s : origShapes)
	{
	GProp_GProps v_props;
	BRepGProp::VolumeProperties(s, v_prop
	auto v = v_props.Mass();
	origVols.push_back(v);
	}
	}</code></td>
          <td>	<code>for (const auto& s : resultsPieces)
	{
	GProp_GProps v_props;
	BRepGProp::VolumeProperties(s, v_prop
	auto v = v_props.Mass();
	resultsVols.push_back(v);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 64-65</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 147-149[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	debugging = 0 # this debugging only con
	</code></td>
          <td>	<code>#######################################
	
	globalParameters = { # shared by all pr</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 111-117</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 163-169[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>else if (Utilities::hasFileExt(file_n
	{
	this->readManifestFile(file_name);
	}
	else if (Utilities::hasFileExt(file_n
	{
	readBrep(file_name);</code></td>
          <td>	<code>else if (Utilities::hasFileExt(file_n
	{
	this->readFreeCADFile(file_name);
	}
	else if (Utilities::hasFileExt(file_n
	{
	readBrep(file_name, metadata);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 228-233</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 235-240[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS1=aCS.Shape1();
	if (!myOriginsDetected.IsBound(aS1))
	myErrorStatus=30;
	return;
	}
	const TopoDS_Shape& aSkey1=myOriginsD</code></td>
          <td>	<code>const TopoDS_Shape& aS2=aCS.Shape2();
	if (!myOriginsDetected.IsBound(aS2))
	myErrorStatus=30;
	return;
	}
	const TopoDS_Shape& aSkey2=myOriginsD</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 145-149</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 810-814[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Real aTol)
	{
	const gp_XYZ &aLoc = aCyl.Location().
	const gp_Ax1 &aAxis = aCyl.Axis();
	const gp_XYZ &aDAxis = aAxis.Directio</code></td>
          <td>	<code>void DumpPosition(const gp_Ax3& aAx3)
	{
	const gp_Dir& aDZ=aAx3.Axis().Directi
	const gp_Dir& aDX=aAx3.XDirection();
	const gp_Dir& aDY=aAx3.YDirection();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 1-11</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 1-11[37]</strong></td>
        </tr>
        <tr>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	import json
	import unittest
	
	"""</code></td>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	import json
	import unittest
	
	"""feature test done by FreeCAD script,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 884-891</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 145-153[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(theSo2, TopAbs_FACE
	//
	iCntIn=0;
	iCntOn=0;
	iCntOut=0;
	bFound=Standard_False;
	aNbS2=aMS2.Extent();
	for (i=1; i<=aNbS2; ++i) {
	</code></td>
          <td>	<code>TopExp::MapShapes(aSolid, TopAbs_FACE
	//
	aNbFIN=0;
	aNbFOUT=0;
	aNbFON=0;
	aNbFINTR=0;
	//
	aNbF=aMF.Extent();
	for(j=1; j<aNbF; ++j) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.hxx: line 57-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 52-67[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_Splitter(const Handle(NColle
	
	Standard_EXPORT
	virtual ~GEOMAlgo_Splitter();
	
	Standard_EXPORT
	void AddTool(const TopoDS_Shape& theS
	
	Standard_EXPORT
	const TopTools_ListOfShape& Tools()co
	
	Standard_EXPORT
	void SetLimit(const TopAbs_ShapeEnum
	
	Standard_EXPORT
	TopAbs_ShapeEnum Limit()const;</code></td>
          <td>	<code>GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)
	
	Standard_EXPORT
	const TopoDS_Shape& Shape() const;
	
	Standard_EXPORT
	void SetTolerance(const Standard_Real
	
	Standard_EXPORT
	Standard_Real Tolerance() const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 661-667</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 614-621[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aR2=aElips.MinorRadius();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_ELLI
	aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	aInfo.SetRadius2(aR2);
	</code></td>
          <td>	<code>gp_Ax3 aAx3=aCyl.Position();
	aAx3.SetLocation(aPc);
	//
	aInfo.SetPosition(aAx3);
	aInfo.SetLocation(aPc);
	aInfo.SetHeight(aHeight);
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_SPECIF</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 68-74</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 74-81[37]</strong></td>
        </tr>
        <tr>
          <td>	<code># assert len(shape.Faces) == 20 # 4 c
	
	def test(self):
	self.validate()
	
	
	class WeakInterferenceTest(GeomTestBase
	</code></td>
          <td>	<code>assert len(shape.Faces) == nonshared_
	# 2 cubes shares 1 face, total 11 fac
	
	def test(self):
	self.validate()
	
	
	class AlignedBoxesTest(GeomTestBase):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 698-707</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 624-632[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIx=aHatcher.AddHatching(aHCur);
	//
	aHatcher.Trim(aIx);
	bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	myErrorStatus=42;
	return;
	}
	//
	aHatcher.ComputeDomains(aIx);</code></td>
          <td>	<code>aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	if (!aNbV) {
	myErrorStatus=11; // circle edge with
	return;
	}
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 54-66</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 94-97    [37]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport std::map<std::string, int>
	
	/// based on axis-aligned boundbox ma
	GeomExport Standard_Boolean isCoincid
	
	/// two-step unifying: first unify ed
	/// deprecated: use glueFaces() inste
	GeomExport TopoDS_Shape unifyFaces(co
	
	/// the input shapes to be glued shou
	/// adapted from Geom module of Salom
	/// see the function `glueFaces` in G
	GeomExport TopoDS_Shape glueFaces(con</code></td>
          <td>	<code>GeomExport Standard_Real tolerance(co
	GeomExport Standard_Real distance(con
	GeomExport UniqueIdType uniqueId(cons
	GeomExport UniqueIdType uniqueId(cons
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 428-432</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 396-399[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aExp.Init(aSolid, TopAbs_SHELL);
	for (; aExp.More(); aExp.Next())
	{
	const TopoDS_Shape& aShell=aExp.Curre
	const TopoDS_Shape& aShellR=myOrigins</code></td>
          <td>	<code>myIterator.Initialize(TopAbs_VERTEX,
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aV1=aCS.Shape1();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 810-814</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 145-149[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>void DumpPosition(const gp_Ax3& aAx3)
	{
	const gp_Dir& aDZ=aAx3.Axis().Directi
	const gp_Dir& aDX=aAx3.XDirection();
	const gp_Dir& aDY=aAx3.YDirection();</code></td>
          <td>	<code>const Standard_Real aTol)
	{
	const gp_XYZ &aLoc = aCyl.Location().
	const gp_Ax1 &aAxis = aCyl.Axis();
	const gp_XYZ &aDAxis = aAxis.Directio</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 139-144</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 310-315[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLEr.Append(aEr);
	}
	//
	aItLE.Initialize(aLEr);
	for (; aItLE.More(); aItLE.Next()) {
	const TopoDS_Shape& aEr=aItLE.Value()</code></td>
          <td>	<code>aM.Add(aS);
	}
	//
	aIt.Initialize(aS);
	for(; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 724-728</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 996-1002[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>aV2=aDomain.SecondPoint().Parameter()
	aVx=IntTools_Tools::IntermediatePoint
	// 3
	aS->D0(aUx, aVx, aPx);
	aLP.Append(aPx);
	
	</code></td>
          <td>	<code>aV2=aDomain.SecondPoint().Parameter()
	//
	aVx=IntTools_Tools::IntermediatePoint
	//
	aS->D0(aUx, aVx, aPx);
	//
	theP2D.SetCoord(aUx, aVx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 117-133</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 217-233[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>myWarningStatus=0;
	//
	mySolidsToGlue.Clear();
	mySolidsAlone.Clear();
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();
	//
	InnerTolerance();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>myWarningStatus=0;
	myLS.Clear();
	myMSS.Clear();
	//
	CheckData();
	if(myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_ShapeAlgo::Perform();
	//
	// 1
	ProcessVertices();
	if(myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 428-432</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 682-686[37]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbV==4 && aNbE==4) {
	aIt.Initialize(aF);
	if (aIt.More()) {
	aW=*((TopoDS_Wire*)&aIt.Value());
	}</code></td>
          <td>	<code>else if (aKSE==GEOMAlgo_KS_DEGENERATE
	aIt.Initialize(aE);
	if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/AppPy.cpp: line 23-26</strong></td>
        <td style="text-align:center"><strong>src/python/AppPy.cpp: line 36-40   [37]</strong></td>
        </tr>
        <tr>
          <td>	<code>typedef PPP::PipelineController pc;
	py::class_<pc>(m, "PipelineController
	.def(py::init<const std::string&>(),
	.def("config", &pc::config, "get conf
	</code></td>
          <td>	<code>typedef GeometryPipelineController mt
	py::class_<mt>(m, "GeometryPipeline")
	//.def(py::init<>(), "default constru
	.def(py::init<const std::string&>(),
	.def(py::init([](std::vector<std::str</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 388-399</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 391-402[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!myOrigins.IsBound(aVSD)) {
	myOrigins.Bind(aVSD, aV);
	}
	}
	}
	}
	//=====================================
	//function : MakeSubShapes
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeSubShapes (con
	TopTools_MapOfShape& theMS,</code></td>
          <td>	<code>if (!myOrigins.IsBound(aFSD)) {
	myOrigins.Bind(aFSD, aS1);
	}
	}
	}// for (i=1; i<=aNbF; ++i)
	}
	//=====================================
	//function : FacePassKey
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::FacePassKey
	GEOMAlgo_PassKeyShape& aPK)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 379-382</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 244-248[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLS.Initialize(aLS2);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aS2=aItLS.Value()
	aCS.SetShape2(aS2);
	</code></td>
          <td>	<code>aItDMSLS.Initialize(myShapesToGlue);
	for (; aItDMSLS.More(); aItDMSLS.Next
	//const TopoDS_Shape& aSkey=aItDMSLS.
	const TopTools_ListOfShape& aLSG=aItD
	aItLS.Initialize(aLSG);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 60-70</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 114-124[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>enum class ShapeType
	{
	Shape = TopAbs_SHAPE,
	Compound = TopAbs_COMPOUND,
	CompSolid = TopAbs_COMPSOLID,
	Solid = TopAbs_SOLID,
	Shell = TopAbs_SHELL,
	Wire = TopAbs_WIRE,
	Face = TopAbs_FACE,
	Edge = TopAbs_EDGE,
	Vertex = TopAbs_VERTEX</code></td>
          <td>	<code>enum CollisionType
	{
	NoCollision = 0, ///< not related, XO
	Clearance = 1, ///< within a gap thre
	VertexContact = 2, ///< only share ve
	EdgeContact = 4, ///< share edge, but
	FaceContact = 8, ///< face contact, t
	WeakInterference = 16, ///< small int
	Interference = 32, ///< overlapping,
	Coincidence = 64, ///< identical shap
	Enclosure = 128, ///< a smaller shape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Clsf.hxx: line 66-74</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.hxx: line 68-76[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
          <td>	<code>Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 124-127</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 182-185[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfName(aKNF);
	aInfo.SetLocation(aInfoF.Location());
	aInfo.SetPosition(aInfoF.Position());
	aInfo.SetRadius1(aInfoF.Radius1());</code></td>
          <td>	<code>aInfo.SetKindOfName(aKNF);
	aInfo.SetLocation(aInfoF.Location());
	aInfo.SetPosition(aInfoF.Position());
	aInfo.SetRadius1(aInfoF.Radius1());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 782-793</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 793-804[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>DumpLocation(myLocation);
	}
	//=====================================
	//function : DumpLocation
	//purpose :
	//=====================================
	void DumpLocation(const gp_Pnt& aP)
	{
	Standard_Real aX, aY, aZ;
	//
	aP.Coord(aX, aY, aZ);
	printf(" Location : %.3lf %.3lf %.3lf</code></td>
          <td>	<code>printf(" Location : %.3lf %.3lf %.3lf
	}
	//=====================================
	//function : DumpDirection
	//purpose :
	//=====================================
	void DumpDirection(const gp_Dir& aD)
	{
	Standard_Real aX, aY, aZ;
	//
	aD.Coord(aX, aY, aZ);
	printf(" Direction: %.3lf %.3lf %.3lf</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.hxx: line 28-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.hxx: line 28-53[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ShellSolid_HeaderFile
	#define _GEOMAlgo_ShellSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_ShellSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ShellSolid : public GEOM
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() {</code></td>
          <td>	<code>#ifndef _GEOMAlgo_WireSolid_HeaderFile
	#define _GEOMAlgo_WireSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_WireSolid
	//purpose :
	//=====================================
	class GEOMAlgo_WireSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_WireSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 57-73</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 98-114[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ClsfSurf::SetSurface(co
	{
	myS=aS;
	}
	//=====================================
	//function : Surface
	//purpose :
	//=====================================
	const Handle(Geom_Surface)& GEOMAlgo_
	{
	return myS;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSurf::CheckData()</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn2::SetClsf(c
	{
	myClsf=aClsf;
	}
	//=====================================
	//function : Clsf
	//purpose :
	//=====================================
	const Handle(GEOMAlgo_Clsf)& GEOMAlgo_F
	{
	return myClsf;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::SetShapeT</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 132-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 479-483[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aWr=myOrigins.Find(aW);
	//
	// clear contents of Wr
	aLEr.Clear();
	aItE.Initialize(aWr);
	for (; aItE.More(); aItE.Next()) {
	const TopoDS_Shape& aEr=aItE.Value();</code></td>
          <td>	<code>aLV.Clear();
	aMFence.Clear();
	aItA.Initialize(aE);
	for (; aItA.More(); aItA.Next()) {
	const TopoDS_Shape& aV=aItA.Value();
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 796-800</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 250-253[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aShape = anExp.Cu
	
	if (aMapFence.Add(aShape)) {
	if (myMapRemoved.Contains(aShape)) {</code></td>
          <td>	<code>for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aSIm=aItIm.Value(
	if (aM.Add(aSIm)) {
	if (!aMx.Contains(aSIm)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.hxx: line 68-76</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 75-83[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
          <td>	<code>Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	Standard_EXPORT
	virtual Standard_Boolean CanBeON(cons
	
	DEFINE_STANDARD_RTTIEXT(GEOMAlgo_Clsf
	
	protected:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 630-634</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 206-210[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbLinks=aMPKI.Extent();
	aIt.Initialize(aMPKI);
	for (; aIt.More(); aIt.Next()) {
	iCnt=aIt.Value();
	if (iCnt>1) {</code></td>
          <td>	<code>aNbIP=aMIP.Extent();
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {
	aIP=aIt1.Key();
	if (aMIPC.Contains(aIP)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 167-184</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 115-132[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_DataMapOfShapeListOfShap
	{
	return myImages;
	}
	//=====================================
	//function : Origins
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeShape& GEO
	{
	return myOrigins;
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::Perform()
	{</code></td>
          <td>	<code>const TopTools_DataMapOfShapeListOfShap
	{
	return myImages;
	}
	//=====================================
	//function : Origins
	//purpose :
	//=====================================
	const TopTools_DataMapOfShapeShape& GEO
	{
	return myOrigins;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::Clear()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 305-309</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 423-426[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (xp.Init(mkGFA->Shape(), TopAbs_S
	{
	// const TopoDS_Shape& s = BRepBuilde
	cBuilder.Add(compSolid, xp.Current())
	}</code></td>
          <td>	<code>for (TopExp_Explorer anExp(res->Shape
	{
	cBuilder.Add(compSolid, anExp.Current
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_2.cxx: line 151-154</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 378-381[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>theM.Add(theS);
	aIt.Initialize(theS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();</code></td>
          <td>	<code>aCS.SetShape1(aS1);
	aItLS.Initialize(aLS2);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aS2=aItLS.Value()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 103-106</strong></td>
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 71-74[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>void Context::setupConfig(const std::st
	{
	if (fs::exists(config_filename) && Ut
	{</code></td>
          <td>	<code>PipelineController::PipelineControlle
	{
	if (fs::exists(config_filename) && Ut
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 266-290</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 288-312[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	}// if (aNbSG) {
	}
	//=====================================
	//function : FillEdges
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillEdges()
	{
	FillBRepShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : FillFaces
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillFaces()
	{
	FillBRepShapes(TopAbs_FACE);
	}
	//=====================================
	//function : FillWires
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillWires()</code></td>
          <td>	<code>}
	}
	}
	}
	//=====================================
	//function : DetectFaces
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectFaces
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectEdges
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectShape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 212-221</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 85-95[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPTools_AlgoTools::MakeContainer(Top
	//
	aSB.SetContext(myContext);
	aSB.SetShapes(aSFS);
	aSB.Perform();
	iErr=aSB.HasErrors();
	if (iErr) {
	myErrorStatus=20; // SolidBuilder fai
	return;
	}
	</code></td>
          <td>	<code>myDetector.SetArgument(myArgument);
	myDetector.SetTolerance(myTolerance);
	myDetector.SetCheckGeometry(bCheckGeo
	//
	myDetector.Perform();
	iErr=myDetector.ErrorStatus();
	if (iErr) {
	// Detector is failed
	myErrorStatus=11;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 110-116</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 126-133[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	BOPDS_DS* pDS=(BOPDS_DS*)&aDS;
	</code></td>
          <td>	<code>gp_Pnt aP3D;
	//
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	BOPDS_DS* pDS=(BOPDS_DS*)&aDS;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 357-360</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 455-458[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	auto df_original = generateDumpName("
	OccUtils::saveShape({item(i), item(j)
	}</code></td>
          <td>	<code>{
	auto dump_file_name = generateDumpNam
	OccUtils::saveShape({item(i), item(j)
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 271-277</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 438-444[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbS;
	TopoDS_Iterator aIt;
	TopTools_ListOfShape aLS;
	//
	aIt.Initialize(myShape);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();</code></td>
          <td>	<code>TopoDS_Shape aVR;
	TopoDS_Iterator aIt;
	TopTools_ListOfShape aLV;
	//
	aIt.Initialize(aE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 225-231</strong></td>
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 251-259[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (auto indexer : ids[t]) // if the
	{
	if (dim == 2)
	myProcessor->processItemPair(indexer[
	else
	myProcessor->processItem(indexer[0]);
	}
	
	</code></td>
          <td>	<code>for (auto indexer : ids) // if there
	{
	if (dim == 2)
	myProcessor->processItemPair(indexer[
	else
	myProcessor->processItem(indexer[0]);
	// loglevel 1 means PROGRESS, disable
	// VLOG_F(PROGRESS, "processing pair
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 479-483</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 132-138[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLV.Clear();
	aMFence.Clear();
	aItA.Initialize(aE);
	for (; aItA.More(); aItA.Next()) {
	const TopoDS_Shape& aV=aItA.Value();
	
	</code></td>
          <td>	<code>aWr=myOrigins.Find(aW);
	//
	// clear contents of Wr
	aLEr.Clear();
	aItE.Initialize(aWr);
	for (; aItE.More(); aItE.Next()) {
	const TopoDS_Shape& aEr=aItE.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 249-254</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 258-263[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>continue;
	}
	//
	const TopoDS_Shape& aFi=aMF(i);
	const GEOMAlgo_ShapeInfo& aIFi=myMapI
	const gp_Dir& aDNi=aIFi.Position().Di</code></td>
          <td>	<code>continue;
	}
	//
	const TopoDS_Shape& aFj=aMF(j);
	const GEOMAlgo_ShapeInfo& aIFj=myMapI
	const gp_Dir& aDNj=aIFj.Position().Di</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 241-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 385-391[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else
	{
	const char* ns = p["name"].get<std::s
	LOG_F(WARNING, "shape `%s` is not sol
	}
	}</code></td>
          <td>	<code>}
	else
	{
	const char* ns = p["name"].get<std::s
	LOG_F(WARNING, "shape `%s` has been m
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 102-110</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 120-129[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>INFO("It is found to have such a fail
	d.erase("A"); // no effect if no such
	}
	
	TEST_CASE_METHOD(PropertyContainerTest,
	{
	PropertyContainer d;
	std::size_t length = 100;
	using B = std::vector<int>;
	</code></td>
          <td>	<code>REQUIRE(bb->size() == length + 1U);
	d.erase("B"); // no effect if no such
	}
	
	
	TEST_CASE_METHOD(PropertyContainerTest,
	{
	PropertyContainer d;
	std::size_t length = 100;
	using B = std::vector<int>;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 123-126</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 391-395[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>bbox1 = get_boundbox(f1)
	s = check_similarity(bbox, bbox1)
	
	#######################################
	</code></td>
          <td>	<code>)
	
	config_file_name = generate_config_file
	
	########################### module spec</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 115-117</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 24-26[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>doc.Cylinder.Placement = App.Placemen
	App.Vector(10, 10, 0), App.Rotation(A
	)</code></td>
          <td>	<code>objs[1].Placement = App.Placement(
	App.Vector(10, 0, 0), App.Rotation(Ap
	)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 206-211</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 527-531[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>iLimit=(Standard_Integer)myLimit;
	//
	// 1. Collect the shapes to process a
	aIt.Initialize(myArguments);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();</code></td>
          <td>	<code>aType=(TopAbs_ShapeEnum) aR;
	//
	aIt.Initialize(aE);//, Standard_False
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 591-595</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 630-634[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbLinks=aMPKI.Extent();
	aIt.Initialize(aMPKI);
	for (; aIt.More(); aIt.Next()) {
	iCnt=aIt.Value();
	if (iCnt==1) {</code></td>
          <td>	<code>aNbLinks=aMPKI.Extent();
	aIt.Initialize(aMPKI);
	for (; aIt.More(); aIt.Next()) {
	iCnt=aIt.Value();
	if (iCnt>1) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 103-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 111-112[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShapeErrors && myShapeErrors->f
	return (*myShapeErrors)[(*myShapeIDs)</code></td>
          <td>	<code>if (myNameMap->find((*myShapeIDs)[ind
	return (*myNameMap)[(*myShapeIDs)[ind</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 71-74</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 103-106  [36]</strong></td>
        </tr>
        <tr>
          <td>	<code>PipelineController::PipelineControlle
	{
	if (fs::exists(config_filename) && Ut
	{</code></td>
          <td>	<code>void Context::setupConfig(const std::st
	{
	if (fs::exists(config_filename) && Ut
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 438-444</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 271-277[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aVR;
	TopoDS_Iterator aIt;
	TopTools_ListOfShape aLV;
	//
	aIt.Initialize(aE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();</code></td>
          <td>	<code>Standard_Integer aNbS;
	TopoDS_Iterator aIt;
	TopTools_ListOfShape aLS;
	//
	aIt.Initialize(myShape);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1133-1149</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 64-80[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>return myGenerated;
	}
	//=====================================
	//function : Generated
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Gl
	{
	myGenerated.Clear();
	return myGenerated;
	}
	//=====================================
	//function : IsDeleted
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::IsDele
	{</code></td>
          <td>	<code>return myHistShapes;
	}
	//=====================================
	//function : Modified
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_
	{
	myHistShapes.Clear();
	return myHistShapes;
	}
	//=====================================
	//function : IsDeleted
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BuilderShap
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 647-655</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 761-767[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" Height : %.3lf\n", myHeight)
	}
	//
	// TORUS
	else if (aKN==GEOMAlgo_KN_TORUS) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius</code></td>
          <td>	<code>printf(" Radius2 : %.3lf\n", myRadius
	}
	else if (aKN==GEOMAlgo_KN_ARCELLIPSE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 454-456</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 549-551[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp_Explorer aExpE (aW, TopAbs_EDG
	for (; aExpE.More(); aExpE.Next()) {
	const TopoDS_Edge& aE=TopoDS::Edge(aE</code></td>
          <td>	<code>aExp.Init(aShell, TopAbs_FACE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Face& aF=TopoDS::Face(aE</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.h: line 77-81</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 160-190[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>void setupConfig(const std::string& c
	void setupAppInfo(const Config& confi
	void setupDataStorage(const Config& c
	void setupParallelism(const Config& c
	void setupLogger(const Config& config
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>void markRemoved(const TopoDS_Shape &
	
	/**
	* \brief This method marks ancestors
	* recursively called up to the level
	*
	* \param theShape the shape.
	*/
	void markAncestorsModified(const Topo
	
	/**
	* \brief This method performs computa
	* the provided type.
	*
	* \param theType the processed shape
	*/
	void processShapes(const TopAbs_Shape
	
	/**
	* \brief This method performs computa
	*
	* \param theEdge the modified edge (s
	*/
	void processEdge(const TopoDS_Shape &
	
	/**
	* \brief This method performs computa
	*
	* \param theWire the modified wire (s
	*/
	void processWire(const TopoDS_Shape &</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 391-395</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 123-126[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>)
	
	config_file_name = generate_config_file
	
	########################### module spec</code></td>
          <td>	<code>bbox1 = get_boundbox(f1)
	s = check_similarity(bbox, bbox1)
	
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 105-111</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 161-167[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>this->loadXCAFDoc();
	}
	else if (Utilities::hasFileExt(file_n
	{
	this->readFreeCADFile(file_name);
	}
	else if (Utilities::hasFileExt(file_n</code></td>
          <td>	<code>this->loadXCAFDoc(metadata);
	}
	else if (Utilities::hasFileExt(file_n
	{
	this->readFreeCADFile(file_name);
	}
	else if (Utilities::hasFileExt(file_n</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.hxx: line 34-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.hxx: line 28-53[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_RemoverWebs_HeaderFil
	#define _GEOMAlgo_RemoverWebs_HeaderFil
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	//
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_IndexedMapOfShape.hx
	
	//=====================================
	//function : GEOMAlgo_RemoverWebs
	//purpose :
	//=====================================
	class GEOMAlgo_RemoverWebs : public GEO
	{
	public:
	Standard_EXPORT
	GEOMAlgo_RemoverWebs();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_RemoverWebs();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ShellSolid_HeaderFile
	#define _GEOMAlgo_ShellSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_ShellSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ShellSolid : public GEOM
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	protected:
	Standard_EXPORT
	virtual void BuildResult() {
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.cxx: line 53-69</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 99-115[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeAlgo::SetContext(con
	{
	myContext=theContext;
	}
	//=====================================
	//function : Context
	//purpose :
	//=====================================
	const Handle(IntTools_Context)& GEOMAlg
	{
	return myContext;
	}
	//=====================================
	//function : SetShape
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeAlgo::SetShape(const</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn::SetSurface
	{
	mySurface=aS;
	}
	//=====================================
	//function : Surface
	//purpose :
	//=====================================
	const Handle(Geom_Surface)& GEOMAlgo_Fi
	{
	return mySurface;
	}
	//=====================================
	//function : SetShapeType
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::SetShapeTy</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 812-817</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 820-825[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (not(itemSuppressed(i) or itemSupp
	{
	unresolvedItems.insert(std::make_pair
	unresolvedItems.insert(std::make_pair
	}
	}</code></td>
          <td>	<code>if (not(itemSuppressed(i) or itemSupp
	{
	unresolvedItems.insert(std::make_pair
	unresolvedItems.insert(std::make_pair
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 527-531</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 206-211[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=(TopAbs_ShapeEnum) aR;
	//
	aIt.Initialize(aE);//, Standard_False
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();
	</code></td>
          <td>	<code>iLimit=(Standard_Integer)myLimit;
	//
	// 1. Collect the shapes to process a
	aIt.Initialize(myArguments);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 163-180</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 163-180[36]</strong></td>
        </tr>
        <tr>
          <td>	<code>aId=myMap(i);
	aIdN=NormalizedId(aId, myNbIds);
	mySum+=aIdN;
	}
	}
	//=====================================
	//function :NbIds
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Nb
	{
	return myNbIds;
	}
	//=====================================
	//function :Id
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Id</code></td>
          <td>	<code>aId=aS.HashCode(myUpper);
	aIdN=NormalizedId(aId, myNbIds);
	mySum+=aIdN;
	}
	}
	//=====================================
	//function :NbIds
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKeyShap
	{
	return myNbIds;
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyShap</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 158-162</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 157-161[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>aId=aIt.Value();
	myMap.Add(aId);
	}
	myNbIds=myMap.Extent();
	for(i=1; i<=myNbIds; ++i) {</code></td>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	myMap.Add(aS);
	}
	myNbIds=myMap.Extent();
	for(i=1; i<=myNbIds; ++i) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 68-83</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 176-214[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetCheckGeometry(const Standard_
	
	Standard_EXPORT
	Standard_Boolean CheckGeometry() cons
	
	Standard_EXPORT
	void SetKeepNonSolids(const Standard_
	
	Standard_EXPORT
	Standard_Boolean KeepNonSolids() cons
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	Standard_Integer AloneShapes() const;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>void SetTolMass(const Standard_Real t
	
	/**
	* Selector. Returns the value toleran
	* @return
	* The value tolerance of mass.
	*/
	Standard_EXPORT
	Standard_Real TolMass() const;
	
	/**
	* Modifier. Sets the tolerance of cen
	* @param theTol
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	void SetTolCG(const Standard_Real the
	
	/**
	* Selector. Returns the tolerance of
	* @return
	* The value tolerance of center of gr
	*/
	Standard_EXPORT
	Standard_Real TolCG() const;
	
	/**
	* Perform the algorithm.
	*/
	Standard_EXPORT
	virtual void Perform() ;
	
	/**
	* Returns state of the search.
	* @return
	* Standard_True if the whole argument
	*/
	Standard_EXPORT
	Standard_Boolean IsFound() const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/ProcessorSample.h: line 48-58</strong></td>
        <td style="text-align:center"><strong>src/PPP/CommandLineProcessor.h: line 100-111[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void prepareOutput() override
	{
	myOutputData->emplace<decltype(myData
	}
	
	/**
	* \brief process single data item in
	* @param index: index to get/set by i
	*/
	virtual void processItem(const ItemIn
	{
	</code></td>
          <td>	<code>virtual void prepareOutput() override
	{
	myOutputData->emplace<decltype(myItem
	}
	
	/**
	* \brief process data item in paralle
	*
	* @param index: index to get input da
	*/
	virtual void processItem(const ItemIn
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 249-255</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 715-720[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(IntTools_Context) aCtx=new Int
	//
	aNbSI=aMSI.Extent();
	for (i=1; i<=aNbSI; ++i) {
	const TopoDS_Shape& aSI=aMSI(i);
	//
	aItLS.Initialize(aLSR);</code></td>
          <td>	<code>myNbAlone=0;
	aNbS=aMS.Extent();
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aSolid=aMS(i);
	//
	aMFS.Clear();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 85-90</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 108-113[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.Vector(-9.9, -5, 0), App.Rotation
	)
	doc.recompute()
	return objs
	
	def validate_geometry(self, shape):</code></td>
          <td>	<code>App.Vector(-4.5, 5, 0), App.Rotation(
	)
	doc.recompute()
	return objs
	
	def validate_geometry(self, shape, su</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 41-47</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 47-53[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>#if defined(WIN32)
	#pragma comment(lib, "TKernel.lib")
	#pragma comment(lib, "TKMath.lib")
	
	#pragma comment(lib, "TKG2d.lib")
	#pragma comment(lib, "TKG3d.lib")
	#pragma comment(lib, "TKGeomBase.lib")</code></td>
          <td>	<code>#pragma comment(lib, "TKGeomBase.lib")
	#pragma comment(lib, "TKGeomAlgo.lib")
	
	#pragma comment(lib, "TKBRep.lib")
	#pragma comment(lib, "TKPrim.lib")
	#pragma comment(lib, "TKMesh.lib")
	#pragma comment(lib, "TKTopAlgo.lib")</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 296-300</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 740-744[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aSS2=aMS2(i);
	if (aMS1.Contains(aSS2)) {
	continue;
	}</code></td>
          <td>	<code>for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aS2=aMS2(i);
	if (aS2.IsSame(theF2)) {
	continue;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 715-722</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 174-180[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aV=TopoDS::Vertex(aS);
	aP=BRep_Tool::Pnt(aV);
	//
	aInfo.SetType(TopAbs_VERTEX);
	aInfo.SetLocation(aP);
	myMapInfo.Add(aS, aInfo);</code></td>
          <td>	<code>const TopoDS_Vertex& aV=*((TopoDS_Ver
	aPV=BRep_Tool::Pnt(aV);
	aTolV=BRep_Tool::Tolerance(aV);
	//
	aBox.SetGap(myTolerance);
	aBox.SetCenter(aPV);
	aBox.SetRadius(aTolV);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 85-91</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 755-761[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=myGAS.GetType();
	aType==GeomAbs_Sphere)) {
	myErrorStatus=11; // unallowed surfac
	}
	}</code></td>
          <td>	<code>aType=myGAS.GetType();
	aType==GeomAbs_Sphere)) {
	myErrorStatus=14; // unallowed surfac
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 233-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 249-263[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>PerformVF();
	if (myErrorStatus) {
	return;
	}
	//
	FillFacesOn(myArgument);
	FillFacesOn(myShapeWhere);
	if (myErrorStatus) {
	return;
	}
	//
	PerformEF();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>PerformFF();
	if (myErrorStatus) {
	return;
	}
	//
	FillSolidsOn(myArgument);
	FillSolidsOn(myShapeWhere);
	if (myErrorStatus) {
	return;
	}
	//
	PerformZF();
	if (myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 306-311</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 386-391[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>else
	{
	const char* ns = p["name"].get<std::s
	LOG_F(WARNING, "shape `%s` has been m
	}
	}</code></td>
          <td>	<code>else
	{
	const char* ns = p["name"].get<std::s
	LOG_F(WARNING, "shape `%s` has been m
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 108-111</strong></td>
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 117-120[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>{"range", {PPP::DevicePreference::CPU
	};
	auto d = Parameter<PPP::DevicePrefere
	REQUIRE(d.value == PPP::DevicePrefere</code></td>
          <td>	<code>{"range", {"CPU", "GPU"}},
	};
	auto d_str = Parameter<PPP::DevicePre
	REQUIRE(d_str.value == PPP::DevicePre</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 38-42</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 87-89[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>CollisionDetector::hasCollision(aCyli
	
	// completely inside
	TopoDS_Shape aCylinder3 = BRepPrimAPI
	REQUIRE(CollisionDetector::hasCollisi</code></td>
          <td>	<code>anAxis.SetLocation(gp_Pnt(0.0, 0.0, H
	TopoDS_Shape aCylinder6 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 525-533</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 638-644[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (iKept == 0)
	{
	results.push_back(theKept);
	results.push_back(theOtherShape);
	}
	else
	{
	results.push_back(theOtherShape);
	results.push_back(theKept);</code></td>
          <td>	<code>if (aNbV==1) {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	aInfo.SetKindOfName(GEOMAlgo_KN_CIRCL
	}
	else {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetKindOfName(GEOMAlgo_KN_ARCCI
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 60-65</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 473-478[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (const auto& s : resultShapes)
	{
	GProp_GProps v_props;
	BRepGProp::VolumeProperties(s, v_prop
	auto v = v_props.Mass();
	resVols.push_back(v);</code></td>
          <td>	<code>for (const auto& s : resultsPieces)
	{
	GProp_GProps v_props;
	BRepGProp::VolumeProperties(s, v_prop
	auto v = v_props.Mass();
	resultsVols.push_back(v);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 172-180</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 76-85[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	GEOMAlgo_GluerAlgo::Clear();
	myIterator.Clear();
	myShapesIn.Clear();
	myShapesOn.Clear();
	myShapesInclusive.Clear();
	myMapShapePnt.Clear();
	</code></td>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	GEOMAlgo_GluerAlgo::Clear();
	//
	myImagesDetected.Clear();
	myOriginsDetected.Clear();
	myShapesToGlue.Clear();
	myImagesToWork.Clear();
	myOriginsToWork.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CommandLineProcessor.h: line 100-111</strong></td>
        <td style="text-align:center"><strong>src/Geom/ProcessorSample.h: line 48-58[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void prepareOutput() override
	{
	myOutputData->emplace<decltype(myItem
	}
	
	/**
	* \brief process data item in paralle
	*
	* @param index: index to get input da
	*/
	virtual void processItem(const ItemIn
	{</code></td>
          <td>	<code>virtual void prepareOutput() override
	{
	myOutputData->emplace<decltype(myData
	}
	
	/**
	* \brief process single data item in
	* @param index: index to get/set by i
	*/
	virtual void processItem(const ItemIn
	{
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 680-686</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 525-533[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbV==1) {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	aInfo.SetKindOfName(GEOMAlgo_KN_ELLIP
	}
	else {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetKindOfName(GEOMAlgo_KN_ARCEL
	
	</code></td>
          <td>	<code>if (iKept == 0)
	{
	results.push_back(theKept);
	results.push_back(theOtherShape);
	}
	else
	{
	results.push_back(theOtherShape);
	results.push_back(theKept);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 519-528</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 754-763[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbSE, a
	TopoDS_Edge aE;
	TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfShape aKSE;//, aKSE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)</code></td>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbSE;
	TopoDS_Edge aE;
	TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfShape aKS;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aKS=aInfo.KindOfShape();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 2-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 2-28[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef PPP_GEOMETRY_READER_H
	#define PPP_GEOMETRY_READER_H
	
	#include "GeometryData.h"
	#include "GeometryProcessor.h"
	#include "PPP/Reader.h"
	
	#include "OpenCascadeAll.h"
	
	
	namespace Geom
	{
	using namespace PPP;
	
	/// \ingroup Geom
	/**
	* read geometry file and generate Geo
	* must be in sequential mode, should
	* for the input manifest of multiple
	*
	* Aupported geometry file formats
	* + step/stp AP214(with material and
	* + IGES/igs: OpenCASCADE XCAF reader
	* + FreeCAD native format *.FCStd
	* + parallel preproessor output: *.br
	* + manifest.json textual format: a l
	* this json file must ended with "man
	* ```json
	* [{
	* "material": "one_material",
	* "filename": "absolute_path or path_
	* },
	* {
	* "material": "another material",
	* "filename": "absolute_path or path_
	* }]
	* ```
	*
	*/
	class GeometryReader : public Reader
	{
	TYPESYSTEM_HEADER();
	
	private:
	// some info/objects should be obtain
	// const PipelineController* myProces
	
	/// @{
	Handle(XCAFApp_Application) hApp; //
	Handle(TDocStd_Document) hDoc; // lea
	
	Handle(XCAFDoc_ShapeTool) myShapeTool</code></td>
          <td>	<code>#ifndef PPP_GEOMETRY_WRITER_H
	#define PPP_GEOMETRY_WRITER_H
	
	
	#include "GeometryProcessor.h"
	#include "OccUtils.h"
	#include "PPP/Writer.h"
	
	
	namespace Geom
	{
	using namespace PPP;
	
	/// \ingroup Geom
	/**
	* \brief write out processed geometry
	*/
	class GeometryWriter : public Writer
	{
	TYPESYSTEM_HEADER();
	
	private:
	/// @{
	
	Handle(XCAFDoc_ShapeTool) myShapeTool
	Handle(XCAFDoc_ColorTool) myColorTool
	Handle(XCAFDoc_MaterialTool) myMateri
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 362-370</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 387-395  [35]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> const T paramet
	{
	// unit conversion may be necessary l
	if (myConfig.contains(name))
	{
	json& a = myConfig[name];
	if (a.contains("value"))
	{
	return a["value"].get<T>(); /// param</code></td>
          <td>	<code>const json parameterJson(const std::s
	{
	// unit conversion may be necessary l
	if (myConfig.contains(name))
	{
	json& a = myConfig[name];
	if (a.contains("value"))
	{
	return a["value"]; /// parameter form</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 214-219</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 311-316[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>makeMapShapeAncestors(myShape);
	}
	
	// Check if there are seam or degener
	for (anIter.Initialize(mySubShapes);
	const TopoDS_Shape &aSubShape = anIte</code></td>
          <td>	<code>markRemoved(aSubShape);
	}
	
	// Mark undestors of sub-shapes as mo
	for (anIter.Initialize(mySubShapes);
	const TopoDS_Shape &aSubShape = anIte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 61-64</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 114-116[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>return self.value
	
	
	#######################################</code></td>
          <td>	<code>outputFile = args.outputFile
	
	################################ geom a
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 28-58</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.hxx: line 25-50[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ClsfQuad_HeaderFile
	#define _GEOMAlgo_ClsfQuad_HeaderFile
	
	
	#include <GEOMAlgo_Clsf.hxx>
	
	#include <GeomAdaptor_Surface.hxx>
	#include <Standard_DefineHandle.hxx>
	
	#include <vector>
	
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfQua
	
	//=====================================
	// class : GEOMAlgo_ClsfQuad
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfQuad : public GEOMAl
	{
	
	public:
	
	Standard_EXPORT
	GEOMAlgo_ClsfQuad();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfQuad();
	
	Standard_EXPORT
	void SetCorners(const gp_Pnt &theTopL</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ClsfSolid_HeaderFile
	#define _GEOMAlgo_ClsfSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	#include <TopoDS_Shape.hxx>
	#include <Standard_Address.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfSol
	
	//=====================================
	//class : GEOMAlgo_ClsfSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 94-95</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 99-101[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder8 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	</code></td>
          <td>	<code>TopoDS_Shape aCylinder9 = BRepPrimAPI
	// saveShape({aCylinder, aCylinder9},
	REQUIRE(CollisionDetector::detectColl</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 197-201</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 623-627[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLSX.Clear();
	aNb=aM.Extent();
	for (j=1; j<=aNb; ++j) {
	const TopoDS_Shape& aS=aM(j);
	aLSX.Append(aS);</code></td>
          <td>	<code>j1=aTrs.Lower();
	j2=aTrs.Upper();
	for (j=j1; j<=j2; ++j) {
	const Poly_Triangle& aTr=aTrs(j);
	aTr.Get(n[0], n[1], n[2]);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 778-784</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 610-617[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>aP=aNodes(aIndex).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	if (!aNb && myNbPntsMin) {
	</code></td>
          <td>	<code>aP=aNodes(j).Transformed(aTrsf);
	aLP.Append(aP);
	}
	}
	//
	aNb=aLP.Extent();
	//
	if (!aNb && myNbPntsMin) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 2-28</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 2-53[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef PPP_GEOMETRY_WRITER_H
	#define PPP_GEOMETRY_WRITER_H
	
	
	#include "GeometryProcessor.h"
	#include "OccUtils.h"
	#include "PPP/Writer.h"
	
	
	namespace Geom
	{
	using namespace PPP;
	
	/// \ingroup Geom
	/**
	* \brief write out processed geometry
	*/
	class GeometryWriter : public Writer
	{
	TYPESYSTEM_HEADER();
	
	private:
	/// @{
	
	Handle(XCAFDoc_ShapeTool) myShapeTool
	Handle(XCAFDoc_ColorTool) myColorTool
	Handle(XCAFDoc_MaterialTool) myMateri
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>#ifndef PPP_GEOMETRY_READER_H
	#define PPP_GEOMETRY_READER_H
	
	#include "GeometryData.h"
	#include "GeometryProcessor.h"
	#include "PPP/Reader.h"
	
	#include "OpenCascadeAll.h"
	
	
	namespace Geom
	{
	using namespace PPP;
	
	/// \ingroup Geom
	/**
	* read geometry file and generate Geo
	* must be in sequential mode, should
	* for the input manifest of multiple
	*
	* Aupported geometry file formats
	* + step/stp AP214(with material and
	* + IGES/igs: OpenCASCADE XCAF reader
	* + FreeCAD native format *.FCStd
	* + parallel preproessor output: *.br
	* + manifest.json textual format: a l
	* this json file must ended with "man
	* ```json
	* [{
	* "material": "one_material",
	* "filename": "absolute_path or path_
	* },
	* {
	* "material": "another material",
	* "filename": "absolute_path or path_
	* }]
	* ```
	*
	*/
	class GeometryReader : public Reader
	{
	TYPESYSTEM_HEADER();
	
	private:
	// some info/objects should be obtain
	// const PipelineController* myProces
	
	/// @{
	Handle(XCAFApp_Application) hApp; //
	Handle(TDocStd_Document) hDoc; // lea
	
	Handle(XCAFDoc_ShapeTool) myShapeTool</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 121-130</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 135-143[35]</strong></td>
        </tr>
        <tr>
          <td>	<code>d.erase("B"); // no effect if no such
	}
	
	
	TEST_CASE_METHOD(PropertyContainerTest,
	{
	PropertyContainer d;
	std::size_t length = 100;
	using B = std::vector<int>;
	B b = B(length);</code></td>
          <td>	<code>REQUIRE(d.contains("B") == false);
	}
	
	TEST_CASE_METHOD(PropertyContainerTest,
	{
	PropertyContainer d;
	std::size_t length = 5;
	using Data = std::vector<int>;
	Data data = Data(length, 1);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 50-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 439-444[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ListIteratorOfListOfCoupleOf
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	//
	aItCS.Initialize(aLCS);
	for (; aItCS.More(); aItCS.Next()) {
	const GEOMAlgo_CoupleOfShapes& aCS=aI</code></td>
          <td>	<code>TopoDS_Iterator aIt;
	TopTools_ListOfShape aLV;
	//
	aIt.Initialize(aE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 215-219</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 221-225[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>aVR1=aV1;
	if (myOrigins.IsBound(aV1)) {
	aVR1=*((TopoDS_Vertex*)&myOrigins.Fin
	}
	aVR1.Orientation(TopAbs_FORWARD);</code></td>
          <td>	<code>aVR2=aV2;
	if (myOrigins.IsBound(aV2)) {
	aVR2=*((TopoDS_Vertex*)&myOrigins.Fin
	}
	aVR2.Orientation(TopAbs_REVERSED);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 230-237</strong></td>
        <td style="text-align:center"><strong>src/PPP/ProcessorResult.h: line 16-20[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>};
	
	/// enable automatic data conversion
	/// https://github.com/nlohmann/json#
	/// from_json() may not safe, use wit
	inline void to_json(json& j, const Ge
	{
	j = json{{"volume", p.volume}, {"area</code></td>
          <td>	<code>};
	
	inline void to_json(json& j, const Pr
	{
	j = json{{"status", p.status}, {"resu
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 826-831</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 229-235[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=100;
	return;
	}
	const TopoDS_Shape& aVR1=myOrigins.Fi
	const TopoDS_Shape& aVR2=myOrigins.Fi
	</code></td>
          <td>	<code>myErrorStatus=30;
	return;
	}
	const TopoDS_Shape& aSkey1=myOriginsD
	// 1.2
	const TopoDS_Shape& aS2=aCS.Shape2();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 419-424</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 500-503[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>const gp_Dir& aDZ=aPln.Axis().Directi
	//
	gp_Ax2 aAx2(aPc, aDZ, aDX);
	gp_Ax3 aAx3(aAx2);
	//
	aInfo.SetLocation(aPc);</code></td>
          <td>	<code>const gp_Dir& aDZ=aPln.Axis().Directi
	gp_Ax2 aAx2(aPc, aDZ, aDX);
	gp_Ax3 aAx3(aAx2);
	aInfo.SetPosition(aAx3);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 564-576</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 466-479[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListOfShape aLS;
	//
	aLS.Append(aShell);
	myImages.Bind(aNewShell, aLS);
	myOrigins.Bind(aShell, aNewShell);
	}
	}
	//=====================================
	//function : MakeFaces
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeFaces()
	{
	</code></td>
          <td>	<code>TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aW);
	myImages.Bind(aWnew, aLSD);
	myOrigins.Bind(aW, aWnew);
	//
	}//for (i=1; i<=aNbE; ++i) {
	}
	//=====================================
	//function : FillCompounds
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillCompounds()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1150-1153</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1196-1199[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &anEdge = anExp.Cu
	
	if (theMapEdgesToRm.Contains(anEdge))</code></td>
          <td>	<code>for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aFace = anExp.Cur
	
	if (theMapFacesToRm.Contains(aFace))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 27-64</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 27-62[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn1_Header
	#define _GEOMAlgo_FinderShapeOn1_Header
	
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_ListOfPnt.hxx>
	
	#include <TopAbs_State.hxx>
	#include <TopAbs_ShapeEnum.hxx>
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Edge.hxx>
	#include <TopTools_ListOfShape.hxx>
	
	#include <Geom_Surface.hxx>
	#include <GeomAdaptor_Surface.hxx>
	
	#include <gp_Pnt.hxx>
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn1
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn1 : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur</code></td>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn2_Header
	#define _GEOMAlgo_FinderShapeOn2_Header
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <Standard_Integer.hxx>
	
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Edge.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_ListOfPnt.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	#include <GEOMAlgo_ShapeAlgo.hxx>
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn2
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn2 : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn2();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn2();
	
	Standard_EXPORT
	void SetClsf(const Handle(GEOMAlgo_Cl
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 72-75</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 91-94[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder3 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	TopoDS_Shape aCylinder4 = BRepPrimAPI</code></td>
          <td>	<code>TopoDS_Shape aCylinder7 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	TopoDS_Shape aCylinder8 = BRepPrimAPI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 84-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 129-150[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : SetType
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetType(const
	{
	myType=aType;
	}
	//=====================================
	//function : Type
	//purpose :
	//=====================================
	TopAbs_ShapeEnum GEOMAlgo_ShapeInfo::Ty
	{
	return myType;
	}
	//=====================================
	//function : SetNbSubShapes
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetNbSubShapes</code></td>
          <td>	<code>}
	//=====================================
	//function : SetKindOfShape
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfShape
	{
	myKindOfShape=aT;
	}
	//=====================================
	//function : KindOfShape
	//purpose :
	//=====================================
	GEOMAlgo_KindOfShape GEOMAlgo_ShapeInfo
	{
	return myKindOfShape;
	}
	//=====================================
	//function : SetKindOfName
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetKindOfName(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 145-151</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 120-124[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.Remove(aWr, aEr);
	}
	//
	// refill contents of Wr
	aItE.Initialize(aW);
	for (; aItE.More(); aItE.Next()) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*</code></td>
          <td>	<code>aMFS.Add(aF, TopAbs_IN);
	}
	aIt.Initialize(myLSOUT);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aF=aIt.Value();
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 804-806</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 441-443[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbE; ++i) {
	const TopoDS_Shape& aE=aME(i);
	if (!myOrigins.IsBound(aE)) {</code></td>
          <td>	<code>for (i=1; i<=aNbX; ++i) {
	const TopoDS_Shape& aSx=aMx(i);
	if (!aMS.Contains(aSx)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 175-179</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 375-379[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (j>i) {
	const TopoDS_Shape& aSG1=aItLS1.Value
	const TopoDS_Shape& aSG2=aItLS2.Value
	aCS.SetShape1(aSG1);
	aCS.SetShape2(aSG2);</code></td>
          <td>	<code>for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aS1=aItDMSLS.Key(
	const TopTools_ListOfShape& aLS2=aItD
	aCS.SetShape1(aS1);
	aItLS.Initialize(aLS2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1028-1032</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 448-450[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aER=TopoDS::Edge(m
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	aT=IntTools_Tools::IntermediatePoint(
	aC3D->D0(aT, aP);</code></td>
          <td>	<code>Handle(Geom_Curve)aC1=BRep_Tool::Curv
	aT1=IntTools_Tools::IntermediatePoint
	aC1->D0(aT1, aP);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 106-111</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 423-430[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (TopExp_Explorer i(aBoxMaker.Shap
	{
	aBuilder.Add(aCompound, i.Current());
	}
	}
	catch (Standard_Failure f)
	
	</code></td>
          <td>	<code>for (TopExp_Explorer anExp(res->Shape
	{
	cBuilder.Add(compSolid, anExp.Current
	}
	}
	
	// if boolean fragments are not done,
	REQUIRE(countSubShapes(glueFaces(comp</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 734-741</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 74-79[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Extractor::processCompoun
	{
	// Treat sub-shapes.
	TopoDS_Iterator anIter(theCompound);
	TopTools_ListOfShape aNewSubShapes;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte</code></td>
          <td>	<code>if (aType == TopAbs_COMPOUND) {
	TopoDS_Iterator anIt(theS);
	TopTools_MapOfShape aMapInc;
	
	for(; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aS1x = anIt.Value
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 452-452</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 453-453[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>thisBox.Get(A[0], A[1], A[2], A[3], A</code></td>
          <td>	<code>otherBox.Get(B[0], B[1], B[2], B[3],</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 200-205</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 210-215[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aMVProcessed.Contains(aV)) {
	continue;
	}
	//
	const Bnd_Box& aBoxV=aMSB.FindFromKey
	const TColStd_ListOfInteger& aLI=aBSB</code></td>
          <td>	<code>if (aMIPC.Contains(aIP)) {
	continue;
	}
	//
	const TopoDS_Shape& aVP=aMIS.FindFrom
	const GEOMAlgo_BndSphere& aBoxVP=aMSB</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 266-267</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 358-359[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto df_original = generateDumpName("
	OccUtils::saveShape({item(i), item(j)</code></td>
          <td>	<code>auto df_original = generateDumpName("
	OccUtils::saveShape({item(i), item(j)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ProcessorResult.h: line 16-20</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 164-167[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>};
	
	inline void to_json(json& j, const Pr
	{
	j = json{{"status", p.status}, {"resu</code></td>
          <td>	<code>};
	inline void to_json(json& j, const Co
	{
	j = json{{"firstIndex", p.first}, {"s
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 117-122</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 151-155[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbF==1) {
	// mb: sphere, torus
	const TopoDS_Shape& aF=aMF(1);
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName(); // mb: sphe</code></td>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aF=aMF(i);
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName();
	if (aKNF==GEOMAlgo_KN_CYLINDER) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 90-94</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 50-54[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>)
	return parser
	
	
	############################### arg par</code></td>
          <td>	<code>doc.recompute()
	return boxes
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 78-84</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 120-126[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>else
	{
	LOG_F(INFO, "result is not merged (du
	finalShape = OccUtils::createCompSoli
	}
	
	BRepTools::Write(finalShape, file_nam</code></td>
          <td>	<code>else
	{
	LOG_F(INFO, "result is not merged (du
	finalShape = OccUtils::createCompound
	}
	/// NOTE: exportMetaData() is done in
	BRepTools::Write(finalShape, file_nam</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 453-453</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 22-22[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>otherBox.Get(B[0], B[1], B[2], B[3],</code></td>
          <td>	<code>b.Update(v[0], v[1], v[2], v[3], v[4]</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 586-591</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 516-521[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>myWarningStatus=0;
	//
	bHasImage=Standard_False;
	aItC.Initialize(myArgument);
	for (; aItC.More(); aItC.Next()) {
	const TopoDS_Shape& aCx=aItC.Value();</code></td>
          <td>	<code>const TopTools_MapOfShape& aMSIn=(bHa
	//
	bFound=Standard_True;
	aIt.Initialize(theE2);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV2=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 461-466</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 484-491[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>aReader.SetMatMode(true);
	// aReader.SetLayerMode(true);
	if (aReader.ReadFile((Standard_CStrin
	{
	throw OSD_Exception("cannot read STEP
	}
	
	</code></td>
          <td>	<code>aReader.SetNameMode(true);
	// aReader.SetMatMode(true); // no su
	
	// IGESControl_Reader aReader;
	if (aReader.ReadFile((Standard_CStrin
	{
	throw OSD_Exception("cannot read IGES
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 74-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 734-741[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType == TopAbs_COMPOUND) {
	TopoDS_Iterator anIt(theS);
	TopTools_MapOfShape aMapInc;
	
	for(; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aS1x = anIt.Value
	
	</code></td>
          <td>	<code>void GEOMAlgo_Extractor::processCompoun
	{
	// Treat sub-shapes.
	TopoDS_Iterator anIter(theCompound);
	TopTools_ListOfShape aNewSubShapes;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 119-132</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 120-133[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS3)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);
	aLS.Append(aS3);
	SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes</code></td>
          <td>	<code>const Standard_Integer aId3)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);
	SetIds(aLI);
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const S</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 448-450</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1028-1032[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Geom_Curve)aC1=BRep_Tool::Curv
	aT1=IntTools_Tools::IntermediatePoint
	aC1->D0(aT1, aP);
	
	</code></td>
          <td>	<code>const TopoDS_Edge& aER=TopoDS::Edge(m
	//
	aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	aT=IntTools_Tools::IntermediatePoint(
	aC3D->D0(aT, aP);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 27-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 27-64[34]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn2_Header
	#define _GEOMAlgo_FinderShapeOn2_Header
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <Standard_Integer.hxx>
	
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Edge.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_ListOfPnt.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	#include <GEOMAlgo_ShapeAlgo.hxx>
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn2
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn2 : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn2();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn2();
	
	Standard_EXPORT
	void SetClsf(const Handle(GEOMAlgo_Cl
	
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn1_Header
	#define _GEOMAlgo_FinderShapeOn1_Header
	
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_ListOfPnt.hxx>
	
	#include <TopAbs_State.hxx>
	#include <TopAbs_ShapeEnum.hxx>
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Edge.hxx>
	#include <TopTools_ListOfShape.hxx>
	
	#include <Geom_Surface.hxx>
	#include <GeomAdaptor_Surface.hxx>
	
	#include <gp_Pnt.hxx>
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn1
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn1 : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 51-54</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 91-94[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>return boxes
	
	
	#######################################</code></td>
          <td>	<code>return parser
	
	
	############################### arg par</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 189-196</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 876-882[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>myResult=aShape;
	return;
	}
	//
	// 2 Internal shapes: edges, vertices
	aIt1.Initialize(aShape);
	for (; aIt1.More(); aIt1.Next()) {
	const TopoDS_Shape& aSD=aIt1.Value();</code></td>
          <td>	<code>++iCnt;
	return;
	}
	//
	aIt.Initialize(aS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 252-258</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 260-266[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aM.Add(aSIm)) {
	if (!aMx.Contains(aSIm)) {
	aBB.Add(aC, aSIm);
	}
	}
	}
	}</code></td>
          <td>	<code>if (aM.Add(aS)) {
	if (!aMx.Contains(aS)) {
	aBB.Add(aC, aS);
	}
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 492-494</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 327-329[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>fs::path py_monitor_path = Processor:
	if (not fs::exists(py_monitor_path))
	{</code></td>
          <td>	<code>fs::path fc_parser_path = Processor::
	if (not fs::exists(fc_parser_path))
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 223-225</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 448-450[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	aT=IntTools_Tools::IntermediatePoint(
	aC3D->D0(aT, aP);</code></td>
          <td>	<code>Handle(Geom_Curve)aC1=BRep_Tool::Curv
	aT1=IntTools_Tools::IntermediatePoint
	aC1->D0(aT1, aP);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 107-109</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 685-686[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport std::vector<TopoDS_Shape>
	const Standard_Real tolerance,
	std::shared_ptr<BRepAlgoAPI_BuilderAl</code></td>
          <td>	<code>std::vector<TopoDS_Shape> generalFuse
	std::shared_ptr<BRepAlgoAPI_BuilderAl
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 94-94</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 118-119   [33]</strong></td>
        </tr>
        <tr>
          <td>	<code>############################### arg par
	</code></td>
          <td>	<code># python wrap currently only Geom modul
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 165-169</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 180-184[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>default_pointer_type<T> get(const std
	{
	std::cout << "DEBUG info: const verso
	if (contains(key))
	{</code></td>
          <td>	<code>template <typename T> T getValue(cons
	{
	std::cout << "DEBUG info: const verso
	if (contains(key))
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 17-19</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 16-18[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	#######################################</code></td>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	######################### moved to test</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 115-119</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 292-296[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(false);
	mkGFA->SetUseOBB(true);</code></td>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(false);
	mkGFA->SetUseOBB(true);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 685-686</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 107-109  [33]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::vector<TopoDS_Shape> generalFuse
	std::shared_ptr<BRepAlgoAPI_BuilderAl
	</code></td>
          <td>	<code>GeomExport std::vector<TopoDS_Shape>
	const Standard_Real tolerance,
	std::shared_ptr<BRepAlgoAPI_BuilderAl</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 206-211</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 177-182[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSC.Perform(aP3D, aTol);
	aSt=aSC.State();
	if (aSt==TopAbs_IN) {
	myLSIN.Append(aV);
	}
	else if (aSt==TopAbs_OUT) {</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSx=aMFS
	aNbSx=aLSx.Extent();
	if (aNbSx==1) {
	aSFS.Append(aFx);
	}
	else if (aNbSx==2) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 50-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 35-57[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>IMPLEMENT_STANDARD_RTTIEXT(GEOMAlgo_Cls
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_ClsfBox::GEOMAlgo_ClsfBox()
	:
	GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ClsfBox::~GEOMAlgo_ClsfBox()
	{
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfBox::SetBox(const T</code></td>
          <td>	<code>IMPLEMENT_STANDARD_RTTIEXT(GEOMAlgo_Cls
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_ClsfSurf::GEOMAlgo_ClsfSurf(
	:
	GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ClsfSurf::~GEOMAlgo_ClsfSurf
	{
	}
	//=====================================
	//function : SetSurface
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSurf::SetSurface(co</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 118-126</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 134-142[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_PassKey::SetIds(const S
	const Standard_Integer aId2,
	const Standard_Integer aId3)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);</code></td>
          <td>	<code>const Standard_Integer aId2,
	const Standard_Integer aId3,
	const Standard_Integer aId4)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/setup.py: line 70-71</strong></td>
        <td style="text-align:center"><strong>src/python/setup.py: line 87-89    [33]</strong></td>
        </tr>
        <tr>
          <td>	<code># FIXME: it is assume the out source bu
	ppp_lib_dir = os.path.dirname(os.path.d
	</code></td>
          <td>	<code>so_suffix = "so"
	
	app_output_path = os.path.dirname(os.</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 82-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 614-621[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>myDetector.Clear();
	myDetector.SetContext(myContext);
	//modified by NIZNHY-PKV Tue Mar 13 1
	myDetector.SetArgument(myArgument);
	myDetector.SetTolerance(myTolerance);
	myDetector.SetCheckGeometry(bCheckGeo
	//
	myDetector.Perform();</code></td>
          <td>	<code>gp_Ax3 aAx3=aCyl.Position();
	aAx3.SetLocation(aPc);
	//
	aInfo.SetPosition(aAx3);
	aInfo.SetLocation(aPc);
	aInfo.SetHeight(aHeight);
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_SPECIF</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 100-103</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 151-154[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbF && aKD==GEOMAlgo_KD
	const TopoDS_Shape& aF=aMF(i);
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKD=aInfoF.KindOfDef();</code></td>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aF=aMF(i);
	GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 876-882</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 72-78[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>++iCnt;
	return;
	}
	//
	aIt.Initialize(aS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();</code></td>
          <td>	<code>myErrorStatus=10;
	return;
	}
	//
	aIt.Initialize(myShape);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aS=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 152-183</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.h: line 77-81      [33]</strong></td>
        </tr>
        <tr>
          <td>	<code>void markShapes();
	
	/**
	* \brief This method marks theShape t
	* recursively marks its sub-shapes to
	*
	* \param theShape the shape.
	*/
	void markRemoved(const TopoDS_Shape &
	
	/**
	* \brief This method marks ancestors
	* recursively called up to the level
	*
	* \param theShape the shape.
	*/
	void markAncestorsModified(const Topo
	
	/**
	* \brief This method performs computa
	* the provided type.
	*
	* \param theType the processed shape
	*/
	void processShapes(const TopAbs_Shape
	
	/**
	* \brief This method performs computa
	*
	* \param theEdge the modified edge (s
	*/
	void processEdge(const TopoDS_Shape &</code></td>
          <td>	<code>void setupConfig(const std::string& c
	void setupAppInfo(const Config& confi
	void setupDataStorage(const Config& c
	void setupParallelism(const Config& c
	void setupLogger(const Config& config
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 228-231</strong></td>
        <td style="text-align:center"><strong>src/python/test_fixing.py: line 24-27[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.newDocument(document_name)
	Part.insert(f, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0]</code></td>
          <td>	<code>App.newDocument(document_name)
	Part.insert(filename, document_name)
	# doc = App.getDocument(document_name
	obj = App.ActiveDocument.Objects[0] #</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 1-1</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 5-5[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>################################# help</code></td>
          <td>	<code>#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 303-311</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1122-1129[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Extractor::markShapes()
	{
	TopTools_ListIteratorOfListOfShape an
	
	// Mark sub-shapes as removed.
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	markRemoved(aSubShape);</code></td>
          <td>	<code>if (!isKept) {
	// Collect history for children.
	TopoDS_Iterator anIter(theShape);
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte
	
	makeHistory(aSubShape, theMapFence);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 114-116</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 380-382[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>outputFile = args.outputFile
	
	################################ geom a</code></td>
          <td>	<code>config_file_content["processors"] = pro
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 794-809</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 817-831[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	return iCnt;
	}
	//=====================================
	//function : IsAllowedType
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ShapeInfoFill
	(const GeomAbs_CurveType aCT)
	{
	Standard_Boolean bRet;
	Standard_Integer i, aNb;
	GeomAbs_CurveType aTypes[]={
	GeomAbs_Line,
	GeomAbs_Circle,
	GeomAbs_Ellipse,</code></td>
          <td>	<code>}
	return bRet;
	}
	//=====================================
	//function : IsAllowedType
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_ShapeInfoFill
	(const GeomAbs_SurfaceType aST)
	{
	Standard_Boolean bRet;
	Standard_Integer i, aNb;
	GeomAbs_SurfaceType aTypes[]={
	GeomAbs_Plane, GeomAbs_Cylinder,
	GeomAbs_Cone, GeomAbs_Sphere,
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 440-445</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1015-1020[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator anIter(theEdge);
	TopTools_MapOfShape aMapFence;
	TopTools_ListOfShape aVtxList;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aShapeVertex = an</code></td>
          <td>	<code>TopoDS_Iterator aIt(theShape);
	TopTools_ListOfShape aLSx;
	TopTools_MapOfShape aMSx;
	
	for(; aIt.More(); aIt.Next()) {
	const TopoDS_Shape &aSubS = aIt.Value</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 261-268</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 341-346[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>"value": 0.5,
	"unit": "mm",
	"range": [1e-5, 1],
	"doc": "CollisionDector needs this th
	},
	"weakInterferenceThreshold": {
	"type": "float",
	"value": 0.1,</code></td>
          <td>	<code>"value": 0.1,
	"unit": "mm",
	"range": [1e-3, 10],
	"doc": "length resolution or mesh siz
	},
	"output": {"type": "filename", "value
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 525-531</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 318-325[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	aItLS.Initialize(aLVSD);
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape& aVSD=aItLS.Value(
	//
	iRet=CheckAncesstors(aVSD, aMVSD, aMV
	</code></td>
          <td>	<code>}
	//
	// 3.
	aItDMSLS.Initialize(aDMSLS);
	for (; aItDMSLS.More(); aItDMSLS.Next
	//const TopoDS_Shape& aSkey=aItDMSLS.
	const TopTools_ListOfShape& aLS=aItDM
	aNbS=aLS.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 689-692</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 711-714[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNb=myNbPntsMin+1;
	dU=(aUMax-aUMin)/aNb;
	for (i=1; i<aNb; ++i) {
	aUx=aUMin+i*dU;</code></td>
          <td>	<code>aNbT=aNbPntsMin+1;
	dT=(aT2-aT1)/aNbT;
	for (j=1; j<aNbT; ++j) {
	aT=aT1+j*dT;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 239-245</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 293-299[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T, typename Ptr =
	{
	if (contains(key))
	{
	myProperties.erase(key);
	}
	auto typeName = demangle(typeid(*pdat</code></td>
          <td>	<code>void setSerializable(const std::strin
	{
	if (contains(key))
	{
	myProperties.erase(key);
	}
	auto typeName = demangle(typeid(*pdat</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 177-182</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 206-211[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLSx=aMFS
	aNbSx=aLSx.Extent();
	if (aNbSx==1) {
	aSFS.Append(aFx);
	}
	else if (aNbSx==2) {</code></td>
          <td>	<code>aSC.Perform(aP3D, aTol);
	aSt=aSC.State();
	if (aSt==TopAbs_IN) {
	myLSIN.Append(aV);
	}
	else if (aSt==TopAbs_OUT) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 342-353</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 356-368[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>case TopAbs_COMPOUND:{
	TopoDS_Compound aC;
	aBB.MakeCompound(aC);
	theC=aC;
	}
	break;
	//
	case TopAbs_COMPSOLID:{
	TopoDS_CompSolid aCS;
	aBB.MakeCompSolid(aCS);
	theC=aCS;
	}
	</code></td>
          <td>	<code>case TopAbs_SOLID:{
	TopoDS_Solid aSolid;
	aBB.MakeSolid(aSolid);
	theC=aSolid;
	}
	break;
	//
	//
	case TopAbs_SHELL:{
	TopoDS_Shell aShell;
	aBB.MakeShell(aShell);
	theC=aShell;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_2.cxx: line 55-69</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 55-70[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : Generated
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Gl
	{
	myHistShapes.Clear();
	return myHistShapes;
	}
	//=====================================
	//function : Modified
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Gl
	</code></td>
          <td>	<code>}
	//
	//=====================================
	//function : Generated
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_
	{
	myHistShapes.Clear();
	return myHistShapes;
	}
	//=====================================
	//function : Modified
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 356-360</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 372-376[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>pass
	elif args.action == Action.decompose:
	processors.append(GeometryDecomposer)
	elif args.action == Action.detect:
	processors.append(CollisionDetector)</code></td>
          <td>	<code>config_file_content["writers"] = writ
	elif args.action == Action.search:
	processors.append(GeometrySearchBuild
	elif args.action == Action.tessellate:
	processors.append(GeometryFaceter)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 88-91</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 91-94[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder6 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	TopoDS_Shape aCylinder7 = BRepPrimAPI</code></td>
          <td>	<code>TopoDS_Shape aCylinder7 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	TopoDS_Shape aCylinder8 = BRepPrimAPI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 1-1</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 22-24[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>################################# help
	
	</code></td>
          <td>	<code># Suite 330, Boston, MA 02111-1307, USA
	# #
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 35-57</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 50-72[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>IMPLEMENT_STANDARD_RTTIEXT(GEOMAlgo_Cls
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_ClsfSurf::GEOMAlgo_ClsfSurf(
	:
	GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ClsfSurf::~GEOMAlgo_ClsfSurf
	{
	}
	//=====================================
	//function : SetSurface
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSurf::SetSurface(co</code></td>
          <td>	<code>IMPLEMENT_STANDARD_RTTIEXT(GEOMAlgo_Cls
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_ClsfBox::GEOMAlgo_ClsfBox()
	:
	GEOMAlgo_Clsf()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ClsfBox::~GEOMAlgo_ClsfBox()
	{
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfBox::SetBox(const T</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 327-329</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 492-494  [33]</strong></td>
        </tr>
        <tr>
          <td>	<code>fs::path fc_parser_path = Processor::
	if (not fs::exists(fc_parser_path))
	{</code></td>
          <td>	<code>fs::path py_monitor_path = Processor:
	if (not fs::exists(py_monitor_path))
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 691-701</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 713-724[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>suppressItemImpl(k, CollisionType::En
	}
	}
	else if (ctype == CollisionType::Erro
	{
	if (not itemSuppressed(i))
	{
	suppressItemImpl(i, ctype);
	}
	// notifyCollision(info, "Error: duri
	}
	</code></td>
          <td>	<code>suppressItemImpl(i, ctype);
	}
	}
	else if (ctype == CollisionType::Coin
	{
	// item i and j are both floating, on
	if (not itemSuppressed(i))
	{
	suppressItemImpl(i, ctype);
	}
	// LOG_F(info, "Error: both shapes wi
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 16-18</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 17-19[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	######################### moved to test</code></td>
          <td>	<code>from GeomTestBase import GeomTestBase,
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1015-1020</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 440-445[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aIt(theShape);
	TopTools_ListOfShape aLSx;
	TopTools_MapOfShape aMSx;
	
	for(; aIt.More(); aIt.Next()) {
	const TopoDS_Shape &aSubS = aIt.Value</code></td>
          <td>	<code>TopoDS_Iterator anIter(theEdge);
	TopTools_MapOfShape aMapFence;
	TopTools_ListOfShape aVtxList;
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aShapeVertex = an</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 184-189</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 290-295[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();
	json pp = p;</code></td>
          <td>	<code>int solidCount = 0;
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();
	UniqueIdType gid = OccUtils::uniqueId</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 86-98</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 291-303[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillSubShapes(const TopoDS_Shape
	
	Standard_EXPORT
	void FillShape(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void FillVertex(const TopoDS_Shape& a
	
	Standard_EXPORT
	void FillEdge(const TopoDS_Shape& aS)
	
	Standard_EXPORT
	void FillFace(const TopoDS_Shape& aS)</code></td>
          <td>	<code>void PerformFF(const TopoDS_Shape &th
	
	Standard_EXPORT
	void FillEdgesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillFacesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillSolidsOn(const TopoDS_Shape
	
	Standard_EXPORT
	void PerformZF() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 667-672</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 330-335[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_MapOfShape& aMSInF=(bH
	//
	aIt.Initialize(aE2);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV2=aIt.Value();</code></td>
          <td>	<code>myWarningStatus=0;
	//
	aItDMSLS.Initialize(myImagesToWork);
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 518-522</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 206-212[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>bFound=Standard_True;
	aIt.Initialize(theE2);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV2=aIt.Value();
	
	</code></td>
          <td>	<code>iLimit=(Standard_Integer)myLimit;
	//
	// 1. Collect the shapes to process a
	aIt.Initialize(myArguments);
	const TopoDS_Shape& aS=aIt.Value();
	if (myMapTools.Contains(aS)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 80-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 80-90[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}
	</code></td>
          <td>	<code>myErrorStatus=0;
	//
	try {
	if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 477-486</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 508-517[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbF, aN
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	aNbS=NbSubShapes(TopAbs_SOLID);</code></td>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbF;
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	aKS=KindOfShape();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 367-377</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 438-447[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(countSubShapes(glueFaces(merg
	}
	
	SECTION("test_merge_boxes_in_a_matrix
	{
	float tolerance = 0; // it is crucial
	float length = 10; // box edge size
	std::vector<TopoDS_Shape> shapes;
	
	// matrix layout, some are shared fac
	int Nboxes = 4;</code></td>
          <td>	<code>REQUIRE(countSubShapes(loadShape(tp.s
	}
	
	SECTION("test_merge_boxes_in_a_line")
	{
	float tolerance = 0; // it is crucial
	float length = 10; // box edge size
	std::vector<TopoDS_Shape> shapes;
	
	int Nboxes = 8;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 287-291</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 914-918[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!myMapShapeAnc.IsBound(aSubShape)
	myMapShapeAnc.Bind(aSubShape, TopTool
	}
	
	myMapShapeAnc.ChangeFind(aSubShape).A</code></td>
          <td>	<code>if (!myMapNewShapeAnc.IsBound(aSubSha
	myMapNewShapeAnc.Bind(aSubShape, TopT
	}
	
	myMapNewShapeAnc.ChangeFind(aSubShape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 70-80</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1139-1149[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& GEOMAlgo_
	{
	myHistShapes.Clear();
	return myHistShapes;
	}
	//=====================================
	//function : IsDeleted
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BuilderShap
	{</code></td>
          <td>	<code>const TopTools_ListOfShape& GEOMAlgo_Gl
	{
	myGenerated.Clear();
	return myGenerated;
	}
	//=====================================
	//function : IsDeleted
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::IsDele
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 151-155</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 518-521[33]</strong></td>
        </tr>
        <tr>
          <td>	<code>myImagesToWork=myImagesDetected;
	//
	aItDMSLS.Initialize(myImagesToWork);
	for (; aItDMSLS.More(); aItDMSLS.Next
	const TopoDS_Shape& aSkey=aItDMSLS.Ke</code></td>
          <td>	<code>bFound=Standard_True;
	aIt.Initialize(theE2);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV2=aIt.Value();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.hxx: line 28-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.hxx: line 25-50[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ClsfSurf_HeaderFile
	#define _GEOMAlgo_ClsfSurf_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	#include <GeomAdaptor_Surface.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	#include <Standard_Boolean.hxx>
	#include <Geom_Surface.hxx>
	#include <Geom_Curve.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfSur
	
	//=====================================
	// class : GEOMAlgo_ClsfSurf
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfSurf : public GEOMAl
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfSurf();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfSurf();
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ClsfSolid_HeaderFile
	#define _GEOMAlgo_ClsfSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_DefineHandle.hxx>
	#include <TopoDS_Shape.hxx>
	#include <Standard_Address.hxx>
	#include <GEOMAlgo_Clsf.hxx>
	
	DEFINE_STANDARD_HANDLE(GEOMAlgo_ClsfSol
	
	//=====================================
	//class : GEOMAlgo_ClsfSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ClsfSolid : public GEOMA
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ClsfSolid();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 546-551</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 592-597[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);
	//
	aLength=aP1.Distance(aP2);</code></td>
          <td>	<code>aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);
	//
	aLength=aP1.Distance(aP2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 52-52</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 74-75[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>myQuadNormal += gp_Vec( myPoints[i],
	</code></td>
          <td>	<code>myQuadNormal +=
	gp_Vec(myPoints[i], myPoints[i+1]) ^</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 684-694</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 549-559[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>InnerPoints(aE, aNbPntsMin, aLP);
	}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	const Standard_Integer aNbPntsMin,
	GEOMAlgo_ListOfPnt& aLP)
	{
	Standard_Boolean bInf1, bInf2;</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::PointOnEdge(aE, a
	}
	//=====================================
	//function : PointOnEdge
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::PointOnEdge(co
	const Standard_Real aT,
	gp_Pnt& aP3D)
	{
	Standard_Real aT1, aT2;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 42-46</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 69-73[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(CollisionDetector::hasCollisi
	
	// radius confusion()
	TopoDS_Shape aCylinder4 = BRepPrimAPI
	REQUIRE(CollisionDetector::hasCollisi</code></td>
          <td>	<code>REQUIRE(CollisionDetector::detectColl
	
	// radius + confusion()
	TopoDS_Shape aCylinder3 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1245-1249</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 987-991[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	
	for (;anIter.More(); anIter.Next()) {
	const TopTools_ListOfShape &anEdges =
	TopoDS_Shape aNewWireShape = makeShap</code></td>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aItM
	
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aSx = aItMS.Key()
	TopAbs_ShapeEnum aType = aSx.ShapeTyp</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 81-85</strong></td>
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 34-39[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>parser # must return parser, otherwis
	)
	
	
	############################ input and
	</code></td>
          <td>	<code>install(TARGETS UniqueIdValidator
	RUNTIME DESTINATION bin
	COMPONENT applications)
	
	
	######################### test registra</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 161-167</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 534-541[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>CopySource (aSx, aMapSS, aSCx);
	//
	aSCx.Orientation(aSx.Orientation());
	BB.Add(aSC, aSCx);
	}
	aSC.Free(bFree);
	}
	</code></td>
          <td>	<code>CopySource (aV, aImages, aOriginals,
	//
	aVx.Orientation(aV.Orientation());
	BB.Add(aEx, aVx);
	}
	//
	aEx.Free(bFree);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 118-121</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 124-127[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>elif o.attrib["type"].find("Part") >=
	self.shapes[o.attrib["name"]] = {
	"type": o.attrib["type"],
	"id": o.attrib["id"],</code></td>
          <td>	<code>elif o.attrib["type"].find("App::Docu
	self.groups[o.attrib["name"]] = {
	"type": o.attrib["type"],
	"id": o.attrib["id"],</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.cxx: line 35-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 62-79[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeAlgo::GEOMAlgo_ShapeAlgo(
	:
	GEOMAlgo_Algo()
	{
	myTolerance=0.0001;
	}
	
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeAlgo::~GEOMAlgo_ShapeAlgo
	{
	}
	//=====================================
	//function : SetContext
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeAlgo::SetContext(con</code></td>
          <td>	<code>GEOMAlgo_ShapeInfoFiller::GEOMAlgo_Shap
	:
	GEOMAlgo_Algo()
	{
	myTolerance=0.0001;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeInfoFiller::~GEOMAlgo_Sha
	{
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetToler
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 110-117</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 152-159[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLS1 = my
	
	if (aLS1.IsEmpty()) {
	// Empty list of parts. Should not be
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
          <td>	<code>const TopTools_ListOfShape &aLS2 = my
	
	if (aLS2.IsEmpty()) {
	// it should not be.
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 420-427</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 447-454[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myOrigins.IsBound(aE)) {
	aER=myOrigins.Find(aE);
	}
	else {
	aER=aE;
	}
	aLE.Append(aER);
	}</code></td>
          <td>	<code>if (myOrigins.IsBound(aV)) {
	aVR=myOrigins.Find(aV);
	}
	else {
	aVR=aV;
	}
	aLV.Append(aVR);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 987-991</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1245-1249[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aItM
	
	for (; aItMS.More(); aItMS.Next()) {
	const TopoDS_Shape& aSx = aItMS.Key()
	TopAbs_ShapeEnum aType = aSx.ShapeTyp</code></td>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	
	for (;anIter.More(); anIter.Next()) {
	const TopTools_ListOfShape &anEdges =
	TopoDS_Shape aNewWireShape = makeShap</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 125-134</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 173-181  [32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Config storageInfo;
	}
	
	
	void Context::setupDataStorage(const Co
	{
	Config storageInfo;
	if (config.contains("dataStorage"))
	{
	storageInfo = config["dataStorage"];</code></td>
          <td>	<code>myConfig["dataStorage"] = storageInfo
	}
	
	void Context::setupLogger(const Config&
	{
	Config logConfig;
	if (config.contains("logger"))
	{
	logConfig = config["logger"];
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 93-98</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 80-85[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aM;
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	const TopTools_ListOfShape& aLS=aDS.A
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {</code></td>
          <td>	<code>Standard_Integer aNbArgs;
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	const TopTools_ListOfShape& aLS=aDS.A
	aNbArgs=aLS.Extent();
	if (!aNbArgs) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 145-149</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 232-234[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(IntTools_Context) aCtx=myDSFil
	//BRepClass3d_SolidClassifier& aSC=aC
	//
	const BOPDS_IndexRange& aRange=pDS->R
	aRange.Indices(iBeg, iEnd);</code></td>
          <td>	<code>Handle(IntTools_Context) aCtx=myDSFil
	const BOPDS_IndexRange& aRange=pDS->R
	aRange.Indices(iBeg, iEnd);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 34-39</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 81-85[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>install(TARGETS UniqueIdValidator
	RUNTIME DESTINATION bin
	COMPONENT applications)
	
	
	######################### test registra</code></td>
          <td>	<code>parser # must return parser, otherwis
	)
	
	
	############################ input and
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.hxx: line 28-66</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.hxx: line 28-54[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn_HeaderF
	#define _GEOMAlgo_FinderShapeOn_HeaderF
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <Geom_Surface.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopoDS_Shape.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_DataMapOfShapeShape.
	
	
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn : public G
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur</code></td>
          <td>	<code>#ifndef _GEOMAlgo_SolidSolid_HeaderFile
	#define _GEOMAlgo_SolidSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <TopoDS_Shape.hxx>
	
	#include <GEOMAlgo_ShellSolid.hxx>
	
	//=====================================
	//function : GEOMAlgo_SolidSolid
	//purpose :
	//=====================================
	class GEOMAlgo_SolidSolid : public GEOM
	{
	public:
	Standard_EXPORT
	GEOMAlgo_SolidSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_SolidSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	void SetShape2(const TopoDS_Shape& aS
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 473-476</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 962-965[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapesAndAncestors(myArgum
	//
	aExp.Init(myArgument, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {</code></td>
          <td>	<code>aBB.MakeFace (newFace, aS, aLoc, aTol
	//
	aExpW.Init(aFFWD, TopAbs_WIRE);
	for (; aExpW.More(); aExpW.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 272-278</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 519-524[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>aS->D0(aUS1, aVS1, aP);
	//
	GeomAPI_ProjectPointOnCurve& aProjPC=
	//
	aProjPC.Perform(aP);
	aNbPoints=aProjPC.NbPoints();
	if (!aNbPoints) {</code></td>
          <td>	<code>const TopoDS_Face& aF2 = TopoDS::Face
	GeomAPI_ProjectPointOnSurf& aProj = a
	//
	aProj.Perform(aP1);
	bIsDone = aProj.IsDone();
	if (!bIsDone) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 63-74</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 119-125[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	static void FaceNormal (const TopoDS_
	const Standard_Real U,
	const Standard_Real V,
	gp_Vec& aN);
	
	//! Computes a point <theP> inside th
	//! <theP2D> - 2D representation of <
	//! on the surface of <theF> <br>
	//! Returns 0 in case of success. <br
	Standard_EXPORT
	static Standard_Integer PntInFace(con</code></td>
          <td>	<code>Standard_EXPORT
	static void PointOnFace(const TopoDS_
	const Standard_Real aU,
	const Standard_Real aV,
	gp_Pnt& aP3D) ;
	Standard_EXPORT
	static Standard_Boolean ProjectPointO
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 205-209</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 440-444[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aIt;
	//
	aIt.Initialize(aS);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSx=aIt.Value();</code></td>
          <td>	<code>TopTools_ListOfShape aLV;
	//
	aIt.Initialize(aE);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aV=aIt.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.hxx: line 28-54</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.hxx: line 28-66[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_SolidSolid_HeaderFile
	#define _GEOMAlgo_SolidSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <TopoDS_Shape.hxx>
	
	#include <GEOMAlgo_ShellSolid.hxx>
	
	//=====================================
	//function : GEOMAlgo_SolidSolid
	//purpose :
	//=====================================
	class GEOMAlgo_SolidSolid : public GEOM
	{
	public:
	Standard_EXPORT
	GEOMAlgo_SolidSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_SolidSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	void SetShape2(const TopoDS_Shape& aS
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn_HeaderF
	#define _GEOMAlgo_FinderShapeOn_HeaderF
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <Geom_Surface.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopoDS_Shape.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_DataMapOfShapeShape.
	
	
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn : public G
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 38-41</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 18-19[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>######################### utilities ###
	
	
	def generate_config(inf, outf, action="</code></td>
          <td>	<code>######################### moved to test
	def solid_interference_maker(doc):
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 457-460</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 971-974[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Edge aER=TopoDS::Edge(myOrigin
	//
	aER.Orientation(TopAbs_FORWARD);
	if (!BRep_Tool::Degenerated(aER)) {</code></td>
          <td>	<code>aER=TopoDS::Edge(myOrigins.Find(aE));
	//
	aER.Orientation(TopAbs_FORWARD);
	if (!BRep_Tool::Degenerated(aER)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 85-86</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 88-89[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>const BVH_Vec3d& aP1 = aBvh->MinPoint
	const BVH_Vec3d& aP2 = aBvh->MaxPoint</code></td>
          <td>	<code>const BVH_Vec3d& aQ1 = aBvh->MinPoint
	const BVH_Vec3d& aQ2 = aBvh->MaxPoint</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 195-198</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 274-277[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aS=aMx(i);
	aBB.Add(aC, aS);
	}</code></td>
          <td>	<code>for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aSi=aM(i);
	aBB.Add(aCmp, aSi);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 331-334</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 376-379[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSS1=aLS.First();
	const TopoDS_Shape& aSS2=aLS.Last();
	aCSS.SetShape1(aSS1);
	aCSS.SetShape2(aSS2);</code></td>
          <td>	<code>const TopoDS_Shape& aS1=aItDMSLS.Key(
	const TopTools_ListOfShape& aLS2=aItD
	aCS.SetShape1(aS1);
	aItLS.Initialize(aLS2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 577-581</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 653-658[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>const gp_Ax1& aAx1=aCyl.Axis();
	const gp_Dir& aDir=aAx1.Direction();
	const gp_Pnt& aPLoc=aAx1.Location();
	//
	aNbCE=0;
	</code></td>
          <td>	<code>const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();
	//
	// 1.
	bHasOnF=myShapesOn.IsBound(aF1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 56-60</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 196-200[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>anAxis.SetLocation(gp_Pnt(0.0, 0.0, 0
	
	float R = 2;
	float H = 10; // height z+ axis
	TopoDS_Shape aCylinder = BRepPrimAPI_</code></td>
          <td>	<code>anotherAxis.SetLocation(gp_Pnt(0.0, -
	float R = 3;
	float H = 5;
	
	TopoDS_Shape s = BRepPrimAPI_MakeCyli</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 534-541</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 161-167[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>CopySource (aV, aImages, aOriginals,
	//
	aVx.Orientation(aV.Orientation());
	BB.Add(aEx, aVx);
	}
	//
	aEx.Free(bFree);
	}</code></td>
          <td>	<code>CopySource (aSx, aMapSS, aSCx);
	//
	aSCx.Orientation(aSx.Orientation());
	BB.Add(aSC, aSCx);
	}
	aSC.Free(bFree);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 199-201</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 202-204  [32]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto logLevel = loguru::Verbosity_2;
	if (logConfig.contains("logLevel"))
	logLevel = logConfig["logLevel"].get<</code></td>
          <td>	<code>auto verbosity = loguru::Verbosity_IN
	if (logConfig.contains("verbosity"))
	verbosity = logConfig["verbosity"].ge</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 60-62</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 39-41[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<VectorType<Bnd_Box>>
	std::shared_ptr<VectorType<GeometryPr
	std::shared_ptr<VectorType<Bnd_OBB>></code></td>
          <td>	<code>std::shared_ptr<VectorType<Bnd_Box>>
	std::shared_ptr<VectorType<GeometryPr
	std::shared_ptr<VectorType<Bnd_OBB>></code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 39-41</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 60-62[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<VectorType<Bnd_Box>>
	std::shared_ptr<VectorType<GeometryPr
	std::shared_ptr<VectorType<Bnd_OBB>></code></td>
          <td>	<code>std::shared_ptr<VectorType<Bnd_Box>>
	std::shared_ptr<VectorType<GeometryPr
	std::shared_ptr<VectorType<Bnd_OBB>></code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 666-672</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 673-679[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType==TopAbs_FACE) {
	TopoDS_Face aNewFace;
	//
	const TopoDS_Face& aF1=TopoDS::Face(a
	MakeFace(aF1, aNewFace);
	aNewShape=aNewFace;
	}</code></td>
          <td>	<code>else if (aType==TopAbs_EDGE) {
	TopoDS_Edge aNewEdge;
	//
	const TopoDS_Edge& aE1=TopoDS::Edge(a
	MakeEdge(aE1, aNewEdge);
	aNewShape=aNewEdge;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 232-234</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 145-149[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(IntTools_Context) aCtx=myDSFil
	const BOPDS_IndexRange& aRange=pDS->R
	aRange.Indices(iBeg, iEnd);
	
	</code></td>
          <td>	<code>Handle(IntTools_Context) aCtx=myDSFil
	//BRepClass3d_SolidClassifier& aSC=aC
	//
	const BOPDS_IndexRange& aRange=pDS->R
	aRange.Indices(iBeg, iEnd);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 190-211</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.h: line 78-81      [32]</strong></td>
        </tr>
        <tr>
          <td>	<code>void processWire(const TopoDS_Shape &
	
	/**
	* \brief This method performs computa
	*
	* \param theFOrSo the modified face o
	*/
	void processFOrSo(const TopoDS_Shape
	
	/**
	* \brief This method performs computa
	*
	* \param theShOrCS the modified shell
	*/
	void processShOrCS(const TopoDS_Shape
	
	/**
	* \brief This method performs computa
	*
	* \param theCompound the modified com
	*/
	void processCompound(const TopoDS_Sha</code></td>
          <td>	<code>void setupAppInfo(const Config& confi
	void setupDataStorage(const Config& c
	void setupParallelism(const Config& c
	void setupLogger(const Config& config
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 981-985</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 725-728[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i = 1; i <= aNbS; i++) {
	const TopoDS_Shape& aS = aMS(i);
	
	if (aShapesInOn.IsBound(aS)) {
	const TopTools_MapOfShape& aMSx = aSh</code></td>
          <td>	<code>for (j=1; j<=aNbFS; ++j) {
	const TopoDS_Shape& aFS=aMFS(j);
	if (aMFR.Contains(aFS)) {
	const TopTools_ListOfShape& aLSx=aMFR
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 949-953</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1002-1006[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer iCur = 0;
	Standard_Integer iPrev = 1;
	
	for (; aMapIt.More(); aMapIt.Next())
	const TopoDS_Shape &aSubShape = aMapI</code></td>
          <td>	<code>TopAbs_Orientation aNewOri = TopAbs_F
	Standard_Boolean isComposedOri = Stan
	
	for (; aSubShIt.More(); aSubShIt.Next
	const TopoDS_Shape &aSubSh = aSubShIt</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 116-116</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 118-119   [32]</strong></td>
        </tr>
        <tr>
          <td>	<code>################################ geom a
	</code></td>
          <td>	<code># python wrap currently only Geom modul
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 72-83</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 130-141[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>void DetectShapes(const TopAbs_ShapeE
	
	Standard_EXPORT
	void EdgePassKey(const TopoDS_Edge& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void FacePassKey(const TopoDS_Face& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void CheckDetected();</code></td>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void FacePassKey(const TopoDS_Face& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void MakeVertex(const TopTools_ListOf
	TopoDS_Vertex& aNewV) ;
	
	Standard_EXPORT
	void MakeEdge(const TopoDS_Edge& aEdg</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 405-406</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 407-408[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>CollisionInfo info = {i, j, dist, Col
	myCollisionInfos[i].push_back(std::ma</code></td>
          <td>	<code>CollisionInfo info_j = {j, i, dist, C
	myCollisionInfos[j].push_back(std::ma</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 106-118</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 130-142[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean GEOMAlgo_BuilderShap
	{
	return myHasModified;
	}
	//=====================================
	//function : PrepareHistory
	//purpose :
	//=====================================
	void GEOMAlgo_BuilderShape::PrepareHi
	{
	myHistShapes.Clear();
	myMapShape.Clear();
	myHasDeleted=Standard_False;</code></td>
          <td>	<code>Standard_Integer GEOMAlgo_Splitter::Lim
	{
	return myLimitMode;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::Clear()
	{
	myTools.Clear();
	myMapTools.Clear();
	myLimit=TopAbs_SHAPE;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 216-227</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 228-239[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>break;
	case BRepCheck_NotClosed:
	error_msg << ";Not closed";
	break;
	case BRepCheck_NotConnected:
	error_msg << ";Not connected";
	break;
	case BRepCheck_SubshapeNotInShape:
	error_msg << ";Subshape not in shape"
	break;
	case BRepCheck_BadOrientation:
	error_msg << ";Bad orientation";</code></td>
          <td>	<code>break;
	case BRepCheck_BadOrientationOfSubsha
	error_msg << ";Bad orientation of sub
	break;
	case BRepCheck_InvalidToleranceValue:
	error_msg << ";Invalid tolerance valu
	break;
	case BRepCheck_EnclosedRegion:
	error_msg << ";Enclosed region";
	break;
	case BRepCheck_InvalidPolygonOnTriang
	error_msg << ";Invalid polygon on tri</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 749-752</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1061-1064[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient</code></td>
          <td>	<code>aBuilder.MakeCompound(aCompound);
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aModifShape = orie</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 246-251</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 436-442[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Builder cBuilder;
	
	cBuilder.MakeCompSolid(compSolid);
	cBuilder.Add(compSolid, box1);
	cBuilder.Add(compSolid, box2);
	cBuilder.Add(compSolid, box3);
	</code></td>
          <td>	<code>TopTools_ListOfShape aLS;
	//
	aLS.Append(aSolid);
	myImages.Bind(aNewSolid, aLS);
	myOrigins.Bind(aSolid, aNewSolid);
	//
	aBB.Add(theResult, aNewSolid);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 362-368</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 639-646[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//
	// UnBind old vertices
	aNbV=aMV.Extent();
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);
	</code></td>
          <td>	<code>}
	}
	//
	// Images/Origins
	//
	aNbF=aMPKLF.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopTools_ListOfShape& aLSDF=aMP</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 161-165</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 193-196[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapesAndAncestors(aShape,
	//
	aNbF=aMFS.Extent();
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Shape& aFx=aMFS.FindKey(</code></td>
          <td>	<code>TopExp::MapShapes(myShape, myLimit, a
	aNbS=aMx.Extent();
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape& aS=aMx(i);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 164-180</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 164-180[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIdN=NormalizedId(aId, myNbIds);
	mySum+=aIdN;
	}
	}
	//=====================================
	//function :NbIds
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKeyShap
	{
	return myNbIds;
	}
	//=====================================
	//function :IsEqual
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_PassKeyShap</code></td>
          <td>	<code>aIdN=NormalizedId(aId, myNbIds);
	mySum+=aIdN;
	}
	}
	//=====================================
	//function :NbIds
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Nb
	{
	return myNbIds;
	}
	//=====================================
	//function :Id
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_PassKey::Id</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 132-135</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 77-80  [32]</strong></td>
        </tr>
        <tr>
          <td>	<code>bool exportGeometry(const std::string
	{
	if (Utilities::hasFileExt(file_name,
	{</code></td>
          <td>	<code>void saveShape(const TopoDS_Shape& sh
	{
	if (Utilities::hasFileExt(file_name,
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 77-80</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 132-135[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>void saveShape(const TopoDS_Shape& sh
	{
	if (Utilities::hasFileExt(file_name,
	{</code></td>
          <td>	<code>bool exportGeometry(const std::string
	{
	if (Utilities::hasFileExt(file_name,
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 72-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.cxx: line 64-81[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ClsfBox::SetBox(const T
	{
	myBox=aBox;
	}
	//=====================================
	//function : Box
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ClsfBox:
	{
	return myBox;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfBox::CheckData()
	{</code></td>
          <td>	<code>void GEOMAlgo_ClsfSolid::SetShape(con
	{
	myShape=aS;
	}
	//=====================================
	//function : Shape
	//purpose :
	//=====================================
	const TopoDS_Shape& GEOMAlgo_ClsfSoli
	{
	return myShape;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSolid::CheckData()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 280-286</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 293-299[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>void setSerializable(const std::strin
	{
	if (contains(key))
	{
	myProperties.erase(key);
	}
	auto typeName = demangle(typeid(*pdat</code></td>
          <td>	<code>void setSerializable(const std::strin
	{
	if (contains(key))
	{
	myProperties.erase(key);
	}
	auto typeName = demangle(typeid(*pdat</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 74-75</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.cxx: line 52-52[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>myQuadNormal +=
	gp_Vec(myPoints[i], myPoints[i+1]) ^</code></td>
          <td>	<code>myQuadNormal += gp_Vec( myPoints[i],
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 62-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.cxx: line 35-53[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeInfoFiller::GEOMAlgo_Shap
	:
	GEOMAlgo_Algo()
	{
	myTolerance=0.0001;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeInfoFiller::~GEOMAlgo_Sha
	{
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetToler
	</code></td>
          <td>	<code>GEOMAlgo_ShapeAlgo::GEOMAlgo_ShapeAlgo(
	:
	GEOMAlgo_Algo()
	{
	myTolerance=0.0001;
	}
	
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeAlgo::~GEOMAlgo_ShapeAlgo
	{
	}
	//=====================================
	//function : SetContext
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeAlgo::SetContext(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 80-85</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 93-98[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbArgs;
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	const TopTools_ListOfShape& aLS=aDS.A
	aNbArgs=aLS.Extent();
	if (!aNbArgs) {</code></td>
          <td>	<code>TopTools_IndexedMapOfShape aM;
	//
	const BOPDS_DS& aDS=myDSFiller->DS();
	const TopTools_ListOfShape& aLS=aDS.A
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 818-822</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 577-581[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aSo1=aCS.Shape1()
	const TopoDS_Shape& aF2=aCS.Shape2();
	//
	bHasOnF=myShapesOn.IsBound(aSo1);</code></td>
          <td>	<code>const gp_Ax1& aAx1=aCyl.Axis();
	const gp_Dir& aDir=aAx1.Direction();
	const gp_Pnt& aPLoc=aAx1.Location();
	//
	aNbCE=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 105-113</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 113-121[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Pnt& aP3D) ;
	
	Standard_EXPORT
	static void PointOnEdge(const TopoDS_
	gp_Pnt& aP3D) ;
	
	Standard_EXPORT
	static void PointOnEdge(const TopoDS_
	const Standard_Real aT,gp_Pnt& aP3D)</code></td>
          <td>	<code>const Standard_Real aT,gp_Pnt& aP3D)
	
	Standard_EXPORT
	static void PointOnFace(const TopoDS_
	gp_Pnt& aP3D) ;
	
	Standard_EXPORT
	static void PointOnFace(const TopoDS_
	const Standard_Real aU,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 116-120</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 121-125[32]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	else if (aType2==TopAbs_EDGE) {
	const TopoDS_Edge& aE2=*((TopoDS_Edge
	iErr=PntInEdge(aE2, aP2);</code></td>
          <td>	<code>}
	//
	else if (aType2==TopAbs_FACE) {
	const TopoDS_Face& aF2=*((TopoDS_Face
	iErr=PntInFace(aF2, aP2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 113-115</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 377-379[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType2==TopAbs_VERTEX) {
	const TopoDS_Vertex& aV2=*((TopoDS_Ve
	aP2=BRep_Tool::Pnt(aV2);</code></td>
          <td>	<code>if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge
	bDegenerated=BRep_Tool::Degenerated(a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 283-294</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 300-311[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>void PerformVF() ;
	
	Standard_EXPORT
	void PerformEF() ;
	
	Standard_EXPORT
	void PerformFF() ;
	
	void PerformFF(const TopoDS_Shape &th
	
	Standard_EXPORT
	void FillEdgesOn(const TopoDS_Shape &</code></td>
          <td>	<code>void FillSolidsOn(const TopoDS_Shape
	
	Standard_EXPORT
	void PerformZF() ;
	
	Standard_EXPORT
	void PerformZZ() ;
	
	void PerformZZ(const TopoDS_Shape &th
	
	Standard_EXPORT
	void FillImages(const TopoDS_Shape &t</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 7-10</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 81-85[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>set(CMAKE_CXX_STANDARD_REQUIRED ON)
	
	
	#######################################
	</code></td>
          <td>	<code>parser # must return parser, otherwis
	)
	
	
	############################ input and</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 113-119</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 64-72[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	</code></td>
          <td>	<code>void SetShapes(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	const TopoDS_Shape& aS2) ;
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	const TopoDS_Shape& aS2,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 639-649</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 754-763[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfShape aKSE;
	GEOMAlgo_KindOfName aKNE;
	GEOMAlgo_KindOfClosed aKCE;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)</code></td>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbSE;
	TopoDS_Edge aE;
	TopExp_Explorer aExp;
	TopTools_MapOfShape aM;
	GEOMAlgo_KindOfShape aKS;
	//
	GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aKS=aInfo.KindOfShape();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 574-577</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 996-999[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (isToCreate = Standard_False; anI
	const TopoDS_Shape &aSubShape = anIte
	
	if (aSubShape.ShapeType() == aSubShap</code></td>
          <td>	<code>for (aMapIt.Initialize(aMapAncs[iCur]
	const TopoDS_Shape &aShape = aMapIt.K
	
	if (aShape.ShapeType() == aType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 152-152</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 152-152[31]</strong></td>
        </tr>
        <tr>
          <td>	<code># =====================================</code></td>
          <td>	<code># =====================================</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 161-163</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 565-567[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>for(i=1; i<=myNbIds; ++i) {
	const TopoDS_Shape& aS=myMap(i);
	aId=aS.HashCode(myUpper);</code></td>
          <td>	<code>for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	bIsConformState=myMSS.Contains(aF);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 18-18</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 61-64[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>######################### moved to test
	
	
	</code></td>
          <td>	<code>return self.value
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1002-1008</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1193-1199[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_Orientation aNewOri = TopAbs_F
	Standard_Boolean isComposedOri = Stan
	
	for (; aSubShIt.More(); aSubShIt.Next
	const TopoDS_Shape &aSubSh = aSubShIt
	
	if (!aMapSubShapes.Contains(aSubSh))</code></td>
          <td>	<code>TopTools_ListOfShape aListFaces;
	Standard_Boolean isModified = Standar
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aFace = anExp.Cur
	
	if (theMapFacesToRm.Contains(aFace))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.hxx: line 53-61</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 83-92[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>private:
	
	bool myConcaveQuad;
	std::vector<bool> myConcaveSide;
	std::vector<gp_Pnt> myPoints;
	std::vector<GeomAdaptor_Surface> myPl
	gp_Vec myQuadNormal;
	};
	#endif
	</code></td>
          <td>	<code>protected:
	
	bool myConcaveQuad;
	std::vector<bool> myConcaveSide;
	std::vector<gp_Pnt> myPoints;
	std::vector<GeomAdaptor_Surface> myPl
	gp_Vec myQuadNormal;
	
	};
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 183-190</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 194-201[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i;
	//
	bRet=Standard_False;
	//
	if (myNbIds!=aOther.myNbIds) {
	return bRet;
	}
	for (i=1; i<=myNbIds; ++i) {</code></td>
          <td>	<code>Standard_Integer i, aId;
	//
	bRet=Standard_False;
	//
	if (myNbIds!=aOther.myNbIds) {
	return bRet;
	}
	for (i=1; i<=myNbIds; ++i) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 458-460</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1050-1055[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShapesOn.IsBound(aE1)) {
	const TopTools_MapOfShape& aMSOn=mySh
	if (aMSOn.Contains(aV2)) {
	
	
	</code></td>
          <td>	<code>if (myShapesInclusive.IsBound(aShape)
	// This "what" shape is inclusive to
	// Get the other inclusive shapes.
	const TopoDS_Shape &aSWhere = myShape
	
	if (myImages.IsBound(aSWhere)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 672-677</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 745-750[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!bFound) {
	break;
	}
	}
	if (!bFound) {</code></td>
          <td>	<code>if (!bFound) {
	break;
	}
	}
	if (!bFound) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 527-535</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 537-545[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>int faceCount = 0;
	{
	TopExp_Explorer Ex(shape, TopAbs_FACE
	while (Ex.More())
	{
	faceCount++;
	Ex.Next();
	}
	}</code></td>
          <td>	<code>int solidCount = 0;
	{
	TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	solidCount++;
	Ex.Next();
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 120-123</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 276-278[31]</strong></td>
        </tr>
        <tr>
          <td>	<code># print(args.thread_count)
	
	
	#######################################</code></td>
          <td>	<code>ppp_start_pipeline(self.config_file_n
	
	######################### post proces
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 511-517</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 346-352[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}</code></td>
          <td>	<code>pSS->SetFiller(aPF);
	pSS->Perform();
	iErr=pSS->ErrorStatus();
	if (iErr) {
	myErrorStatus=32; // builder ShapeSol
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 99-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 172-177[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder9 = BRepPrimAPI
	// saveShape({aCylinder, aCylinder9},
	REQUIRE(CollisionDetector::detectColl
	}
	
	SECTION("test_gfa_modification")
	{</code></td>
          <td>	<code>TopoDS_Shape box3 = BRepPrimAPI_MakeB
	REQUIRE(CollisionDetector::detectColl
	}
	
	SECTION("curved_surface_contact_tests
	{
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 119-123</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 960-964[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRepTools::UVBounds(aFF, aUMin, aUMax
	//
	aBB.MakeFace (aFnew, aS, aLoc, aTol);
	//
	aItW.Initialize(aFF);</code></td>
          <td>	<code>BRepTools::UVBounds(aF, aUMin, aUMax,
	//
	aBB.MakeFace (newFace, aS, aLoc, aTol
	//
	aExpW.Init(aFFWD, TopAbs_WIRE);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 822-824</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 878-881[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>bHasOnF=myShapesOn.IsBound(aSo1);
	const TopTools_MapOfShape& aMSOnF=(bH
	bFound=aMSOnF.Contains(aF2);
	</code></td>
          <td>	<code>bHasOn=myShapesOn.IsBound(theSo1);
	const TopTools_MapOfShape& aMSOn=(bHa
	//
	bHasIn=myShapesIn.IsBound(theSo1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 163-165</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 172-174[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>void dealGeneralFuseException(const s
	const std::vector<ItemIndexType> item
	CollisionType solveErrorByDistanceChe</code></td>
          <td>	<code>const std::vector<TopoDS_Shape> origI
	const std::vector<Standard_Real> orig
	size_t countType(const ItemIndexType</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 324-333</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 553-563[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Pln& aPln)
	{
	Standard_Integer aNbV, aNbE, i, j;
	Standard_Real aDot, aD0, aD1, aLength
	</code></td>
          <td>	<code>}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Cylinder& aCyl)
	
	{
	Standard_Integer aNbV, aNbE, aNbCE, a
	Standard_Real aT0, aT1, aHeight;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 194-201</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 183-190[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aId;
	//
	bRet=Standard_False;
	//
	if (myNbIds!=aOther.myNbIds) {
	return bRet;
	}
	for (i=1; i<=myNbIds; ++i) {</code></td>
          <td>	<code>Standard_Integer i;
	//
	bRet=Standard_False;
	//
	if (myNbIds!=aOther.myNbIds) {
	return bRet;
	}
	for (i=1; i<=myNbIds; ++i) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 101-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 293-298[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//modified by NIZNHY-PKV Tue Mar 13 1
	//
	const TopTools_DataMapOfShapeListOfSh
	aItDMSLS.Initialize(aImages);
	for (; aItDMSLS.More(); aItDMSLS.Next</code></td>
          <td>	<code>}
	//
	const TColStd_ListOfInteger& aLI=aSel
	//
	aIt.Initialize(aLI);
	for (; aIt.More(); aIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 346-352</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 316-322[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>pSS->SetFiller(aPF);
	pSS->Perform();
	iErr=pSS->ErrorStatus();
	if (iErr) {
	myErrorStatus=32; // builder ShapeSol
	return;
	}</code></td>
          <td>	<code>myClsf->SetPnt(aP);
	myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.hxx: line 97-100</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 437-439[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT static Standard_Boole
	(const Handle(GEOM_Function) &theWher
	const TopoDS_Shape &theWhat,
	std::vector< std::vector< int > > &th</code></td>
          <td>	<code>GEOMAlgo_GetInPlaceAPI::GetInPlaceMap (
	const TopoDS_Shape & theWhat,
	std::vector< std::vector< int > > & t
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 151-156</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1160-1166[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if(aOr==TopAbs_INTERNAL) {
	aSF.Orientation(TopAbs_FORWARD);
	}
	}
	aIt.Initialize(aSF);
	for (; aIt.More(); aIt.Next()) {
	</code></td>
          <td>	<code>if (!bDegenerated) {
	aM.Add(aS);
	}
	}
	//
	aIt.Initialize(aS);
	for(; aIt.More(); aIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1035-1038</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1040-1043[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPTools_AlgoTools3D::GetNormalToFace
	if (aF.Orientation()==TopAbs_REVERSED
	aDNF.Reverse();
	}</code></td>
          <td>	<code>BOPTools_AlgoTools3D::GetNormalToFace
	if (aFR.Orientation()==TopAbs_REVERSE
	aDNFR.Reverse();
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppMonitorProgress.py: line 182-189</strong></td>
        <td style="text-align:center"><strong>src/python/pppMonitorProgress.py: line 192-199[31]</strong></td>
        </tr>
        <tr>
          <td>	<code># Allow only one process to hold an e
	if using_lock:
	try:
	import fcntl # POSIX only
	
	fcntl.flock(logf, fcntl.LOCK_EX)
	except IOError:
	print("failed to lock file")</code></td>
          <td>	<code>logf.flush() # do not forget this, ot
	if using_lock:
	try:
	import fcntl # POSIX only
	
	fcntl.flock(logf, fcntl.LOCK_UN)
	except IOError:
	print("failed to unlock file")</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 138-147</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 153-164[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>return any_cast<default_pointer_type<
	}
	else
	{
	throw std::runtime_error("no property
	}
	}
	
	/// get the data also erase it from t
	template <typename T, typename Ptr =
	
	</code></td>
          <td>	<code>return any_cast<default_pointer_type<
	}
	else
	{
	throw std::runtime_error("no property
	}
	}
	
	/** const version of get property dat
	* usage: `get<const std::string>()`,
	* */
	template <typename T, typename = std:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 229-234</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 933-939[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPTools_AlgoTools2D::BuildPCurveForE
	aC2D=BRep_Tool::CurveOnSurface(aEnew,
	if (aC2D.IsNull()){
	iRet=1;
	return iRet;
	}
	</code></td>
          <td>	<code>aOrE=aE.Orientation();
	//
	aC2D=BRep_Tool::CurveOnSurface (aE, a
	if (aC2D.IsNull() ) {
	iErr=1;
	return iErr;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 20-58</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 26-63[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_ShapeInfoFiller_Heade
	#define _GEOMAlgo_ShapeInfoFiller_Heade
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Real.hxx>
	
	#include <gp_Pln.hxx>
	#include <gp_Sphere.hxx>
	#include <gp_Cylinder.hxx>
	#include <gp_Cone.hxx>
	#include <gp_Torus.hxx>
	
	#include <GeomAbs_CurveType.hxx>
	#include <GeomAbs_SurfaceType.hxx>
	
	#include <TopoDS_Solid.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopoDS_Face.hxx>
	
	#include <GEOMAlgo_ShapeInfo.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_Algo.hxx>
	
	//=====================================
	//class : GEOMAlgo_ShapeInfoFiller
	//purpose :
	//=====================================
	class GEOMAlgo_ShapeInfoFiller : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)</code></td>
          <td>	<code>#ifndef _GEOMAlgo_Extractor_HeaderFile
	#define _GEOMAlgo_Extractor_HeaderFile
	
	
	#include <GEOMAlgo_Algo.hxx>
	
	#include <NCollection_List.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopTools_DataMapOfShapeListOf
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_MapOfShape.hxx>
	#include <TopTools_IndexedMapOfShape.hx
	
	
	/**
	* \brief This class encapsulates an al
	* from the main shape.
	*/
	class GEOMAlgo_Extractor : public GEOMA
	{
	public:
	
	/**
	* \brief Empty constructor.
	*/
	Standard_EXPORT GEOMAlgo_Extractor();
	
	/**
	* \brief Virtual destructor.
	*/
	Standard_EXPORT virtual ~GEOMAlgo_Ext
	
	/**
	* \brief This method sets the main sh
	*
	* \param theShape the main shape.
	*/
	Standard_EXPORT void SetShape(const T
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 329-334</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 361-366[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aST==GeomAbs_Plane) {
	gp_Pln aPln;
	//
	aPln=aGAS.Plane();
	aP0=aPln.Location();
	aAx3=aPln.Position();</code></td>
          <td>	<code>else if (aST==GeomAbs_Sphere) {
	gp_Sphere aSphere;
	//
	aSphere=aGAS.Sphere();
	aP0=aSphere.Location();
	aAx3=aSphere.Position();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 561-563</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 570-572[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLE.Initialize(*pLE);
	for (; aItLE.More(); aItLE.Next()) {
	const TopoDS_Shape& aE=aItLE.Value();</code></td>
          <td>	<code>aItLV.Initialize(*pLV);
	for (; aItLV.More(); aItLV.Next()) {
	const TopoDS_Shape& aV=aItLV.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1095-1098</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 509-513[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Integer aNbS = aMS.Ext
	
	for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape &aS = aMS(i);
	</code></td>
          <td>	<code>bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 437-439</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.hxx: line 97-100[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_GetInPlaceAPI::GetInPlaceMap (
	const TopoDS_Shape & theWhat,
	std::vector< std::vector< int > > & t
	</code></td>
          <td>	<code>Standard_EXPORT static Standard_Boole
	(const Handle(GEOM_Function) &theWher
	const TopoDS_Shape &theWhat,
	std::vector< std::vector< int > > &th</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 64-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 104-110[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetShapes(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	const TopoDS_Shape& aS2) ;
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	const TopoDS_Shape& aS2,</code></td>
          <td>	<code>void FillContainer(const TopoDS_Shape
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 668-671</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 683-686[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt.Initialize(aE);
	if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}</code></td>
          <td>	<code>aIt.Initialize(aE);
	if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 577-593</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 248-264[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>MakeShapes(TopAbs_FACE);
	}
	//=====================================
	//function : MakeEdges
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeEdges()
	{
	MakeShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : MakeShapes
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeShapes(const T
	{
	myErrorStatus=0;</code></td>
          <td>	<code>DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectEdg
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectSha
	{
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 592-598</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 675-681[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>++aNbCE;
	}
	else if (aKNE==GEOMAlgo_KN_SEGMENT) {
	if (BRep_Tool::IsClosed(aE, aF)) {
	++aNbSE;
	}
	}</code></td>
          <td>	<code>++aNbCE;
	}
	else if (aKNE==GEOMAlgo_KN_SEGMENT) {
	if (BRep_Tool::IsClosed(aE, aF)) {
	++aNbSE;
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 323-328</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 348-355[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	aLC.Clear();
	aIt.Initialize(aLC1);
	for (; aIt.More(); aIt.Next()) {
	const TopoDS_Shape& aSC=aIt.Value();
	
	</code></td>
          <td>	<code>}// for (i=1; i<=aNbV; ++i) {
	//------------------------------
	//
	// Make new vertices
	aMV.Clear();
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Vertex& aV=*((TopoDS_Ver</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1016-1022</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 393-398[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Dir aDNF, aDNFR;
	//
	bRet=Standard_False;
	//
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Edge& aE=TopoDS::Edge(aE</code></td>
          <td>	<code>myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_VERTEX,
	for (; myIterator.More(); myIterator.
	const GEOMAlgo_CoupleOfShapes& aCS=my
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 44-44</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/CMakeLists.txt: line 1-1[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>########################## main #######</code></td>
          <td>	<code>################################# help</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1284-1289</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 75-79[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	Standard_Integer i;
	
	for (; anIt.More(); anIt.Next()) {
	// Find a zone a sub-shape is connect
	const TopoDS_Shape &aSubShape = anIt.</code></td>
          <td>	<code>TopoDS_Iterator anIt(theS);
	TopTools_MapOfShape aMapInc;
	
	for(; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aS1x = anIt.Value
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 390-398</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 96-103[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>aMF.Init(mySurface, Standard_True, Pr
	
	aFErr=aMF.Error();
	if (aFErr!=BRepLib_FaceDone) {
	myErrorStatus=20; // can not build th
	return;
	}
	//
	const TopoDS_Shape& aF=aMF.Shape();</code></td>
          <td>	<code>const TopTools_ListOfShape& aLS=aDS.A
	aNbArgs=aLS.Extent();
	if (aNbArgs!=2) {
	myErrorStatus=14;
	return;
	}
	
	const TopoDS_Shape& aObj=aLS.First();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 85-85</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 22-24[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>############################ input and
	
	</code></td>
          <td>	<code># Suite 330, Boston, MA 02111-1307, USA
	# #
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 26-63</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 20-58[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_Extractor_HeaderFile
	#define _GEOMAlgo_Extractor_HeaderFile
	
	
	#include <GEOMAlgo_Algo.hxx>
	
	#include <NCollection_List.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopTools_DataMapOfShapeListOf
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_MapOfShape.hxx>
	#include <TopTools_IndexedMapOfShape.hx
	
	
	/**
	* \brief This class encapsulates an al
	* from the main shape.
	*/
	class GEOMAlgo_Extractor : public GEOMA
	{
	public:
	
	/**
	* \brief Empty constructor.
	*/
	Standard_EXPORT GEOMAlgo_Extractor();
	
	/**
	* \brief Virtual destructor.
	*/
	Standard_EXPORT virtual ~GEOMAlgo_Ext
	
	/**
	* \brief This method sets the main sh
	*
	* \param theShape the main shape.
	*/
	Standard_EXPORT void SetShape(const T
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ShapeInfoFiller_Heade
	#define _GEOMAlgo_ShapeInfoFiller_Heade
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Real.hxx>
	
	#include <gp_Pln.hxx>
	#include <gp_Sphere.hxx>
	#include <gp_Cylinder.hxx>
	#include <gp_Cone.hxx>
	#include <gp_Torus.hxx>
	
	#include <GeomAbs_CurveType.hxx>
	#include <GeomAbs_SurfaceType.hxx>
	
	#include <TopoDS_Solid.hxx>
	#include <TopoDS_Shape.hxx>
	#include <TopoDS_Face.hxx>
	
	#include <GEOMAlgo_ShapeInfo.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_Algo.hxx>
	
	//=====================================
	//class : GEOMAlgo_ShapeInfoFiller
	//purpose :
	//=====================================
	class GEOMAlgo_ShapeInfoFiller : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShapeInfoFiller();
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1160-1166</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 151-156[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!bDegenerated) {
	aM.Add(aS);
	}
	}
	//
	aIt.Initialize(aS);
	for(; aIt.More(); aIt.Next()) {</code></td>
          <td>	<code>if(aOr==TopAbs_INTERNAL) {
	aSF.Orientation(TopAbs_FORWARD);
	}
	}
	aIt.Initialize(aSF);
	for (; aIt.More(); aIt.Next()) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 290-300</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 726-736[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>myWarningStatus=0;
	//
	if (myArgument.IsNull()) {
	myErrorStatus=2;
	return;
	}
	//
	if (myShapeWhere.IsNull()) {
	myErrorStatus=3;
	return;
	}</code></td>
          <td>	<code>myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 119-124</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1030-1035[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	
	for (; aItS1x.More(); aItS1x.Next())
	const TopoDS_Shape &aS1x = aItS1x.Val
	
	if (!aMapInc.Remove(aS1x)) {</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSubSi = aItLS.Va
	
	if (aMSx.Add(aSubSi)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 149-153</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 148-152[31]</strong></td>
        </tr>
        <tr>
          <td>	<code>const BOPDS_IndexRange& aRange=aDS.Ra
	aRange.Indices(iBeg, iEnd);
	//
	for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=aDS.Shape(i);</code></td>
          <td>	<code>const BOPDS_IndexRange& aRange=pDS->R
	aRange.Indices(iBeg, iEnd);
	//
	for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 800-803</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 81-84[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (std::size_t i = 0; i < myInputDa
	{
	const auto& row = myCollisionInfos[i]
	if (row.size() == 0)</code></td>
          <td>	<code>for (size_t i = 0; i < myInputData->i
	{
	const auto& p = myGeometryProperties[
	if (p.volume > max_volume and p.volum</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 223-224</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 262-263[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>typename std::remove_reference<DType>
	set<decltype(realType)>(key, std::mak</code></td>
          <td>	<code>jsonizer = _jsonizer;
	setSerializable<decltype(realType)>(k</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 139-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 577-579[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLS=aDS.A
	const TopoDS_Shape& aObj=aLS.First();
	//
	const TopoDS_Shape& aTool=aLS.Last();</code></td>
          <td>	<code>const gp_Ax1& aAx1=aCyl.Axis();
	const gp_Dir& aDir=aAx1.Direction();
	const gp_Pnt& aPLoc=aAx1.Location();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 162-169</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 258-266[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	TopExp::MapShapes(myArgument, TopAbs_
	aNbV=aMV.Extent();
	if (!aNbV) {
	myErrorStatus=2; // no vertices in so
	return;
	}
	</code></td>
          <td>	<code>TopTools_IndexedMapOfShape aM;
	//
	TopExp::MapShapes(myArg2, myShapeType
	//
	aNb=aM.Extent();
	if (!aNb) {
	myWarningStatus=10; // No found sub-s
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 390-393</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 830-832[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSkey=myOriginsTo
	const TopTools_ListOfShape& aLSD=myIm
	//
	myImages.Bind(aEnew, aLSD);</code></td>
          <td>	<code>const TopoDS_Shape& aVR1=myOrigins.Fi
	const TopoDS_Shape& aVR2=myOrigins.Fi
	aPK.SetShapes(aVR1, aVR2);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 59-60</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 195-196[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>with open(config_file_name, "w", enco
	json.dump(config_file_content, jf, en</code></td>
          <td>	<code>with open(generated_config_file_name,
	json.dump(config_file_content, jf, en</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 108-110</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 48-50[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.Vector(-4.5, 5, 0), App.Rotation(
	)
	doc.recompute()</code></td>
          <td>	<code>App.Vector(x * length, 0, 0), App.Rot
	)
	doc.recompute()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ParallelAccessorTest.cpp: line 52-54</strong></td>
        <td style="text-align:center"><strong>src/PPP/ParallelAccessorTest.cpp: line 56-58[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	pa = std::make_shared<AsynchronousDis
	}</code></td>
          <td>	<code>{
	pa = std::make_shared<ParallelAccesso
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 155-157</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 256-258[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.spl
	case_name = inputFilename[: inputFile</code></td>
          <td>	<code>inputFile = ppp_parse_input(args)
	inputDir, inputFilename = os.path.spl
	case_name = inputFilename[: inputFile</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 108-114</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 123-132[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/// this dump only geometry propertie
	void dump(const std::string file_name
	{
	std::ofstream o(file_name);
	o << '[' << std::endl;
	
	
	</code></td>
          <td>	<code>}
	
	/// write meta data in json for solid
	/// suppressed Item will not have met
	/// if there is no name information,
	/// if there is no coloar or material
	void writeMetaData(const std::string
	{
	std::ofstream o(file_name);
	o << '[' << std::endl;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 165-168</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 476-480[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>this->readFreeCADFile(file_name);
	}
	else if (Utilities::hasFileExt(file_n
	{
	</code></td>
          <td>	<code>ret = aReader.Transfer(hDoc);
	// pi->EndScope();
	}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 423-425</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 719-721[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (TopExp_Explorer anExp(res->Shape
	{
	cBuilder.Add(compSolid, anExp.Current</code></td>
          <td>	<code>for (TopExp_Explorer anExp(mkGFA->Sha
	{
	res.push_back(anExp.Current());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 138-146</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 157-165[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Vertex& aNewV) ;
	
	Standard_EXPORT
	void MakeEdge(const TopoDS_Edge& aEdg
	TopoDS_Edge& aNewEdge) ;
	
	Standard_EXPORT
	void MakeFace(const TopoDS_Face& aFac
	TopoDS_Face& aNewEdge) ;</code></td>
          <td>	<code>Standard_Boolean HasImage(const TopoD
	
	Standard_EXPORT
	void MakeBRepShapes(const TopoDS_Shap
	TopoDS_Shape& theSnew) ;
	
	Standard_EXPORT
	void MakeEdge(const TopoDS_Edge& theE
	TopoDS_Edge& theEnew) ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 849-851</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 139-142[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_CoupleOfShapes& aCS=my
	const TopoDS_Shape& aSo1=aCS.Shape1()
	const TopoDS_Shape& aSo2=aCS.Shape2()
	</code></td>
          <td>	<code>const TopTools_ListOfShape& aLS=aDS.A
	const TopoDS_Shape& aObj=aLS.First();
	//
	const TopoDS_Shape& aTool=aLS.Last();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 186-190</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 191-195[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const UniqueIdType uid = myUniqueIds[
	matched[index] = matchUniqueId(s, uid
	}
	else if (myShapeSearchType == ShapeSe
	{</code></td>
          <td>	<code>const Bnd_Box& box = myBoundBoxes[r];
	matched[index] = matchBoundBox(index,
	}
	else if (myShapeSearchType == ShapeSe
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 195-196</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 59-60[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>with open(generated_config_file_name,
	json.dump(config_file_content, jf, en</code></td>
          <td>	<code>with open(config_file_name, "w", enco
	json.dump(config_file_content, jf, en</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 184-188</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 191-195  [30]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	logConfig["logFileName"] = "debug_inf
	logConfig["logLevel"] = "INFO";
	std::cout << "logger config is invali
	}</code></td>
          <td>	<code>{
	logConfig["logFileName"] = "debug_inf
	logConfig["logLevel"] = "INFO";
	std::cout << "no logger configuration
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 66-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 73-79[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>static
	Standard_Integer PntInEdge(const Topo
	gp_Pnt& aP);
	static
	Standard_Integer PntInEdge(const Topo
	gp_Pnt& aP,
	Standard_Real& aT);</code></td>
          <td>	<code>static
	Standard_Integer PntInFace(const Topo
	gp_Pnt& aP);
	static
	Standard_Integer PntInFace(const Topo
	gp_Pnt& aP,
	gp_Pnt2d& theP2D);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 196-198</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 243-245[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	const char* ns = p["name"].get<std::s
	LOG_F(INFO, "compound shape `%s` has</code></td>
          <td>	<code>{
	const char* ns = p["name"].get<std::s
	LOG_F(WARNING, "shape `%s` is not sol</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 98-107</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 291-300[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillFace(const TopoDS_Shape& aS)
	
	Standard_EXPORT
	void FillSolid(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void FillContainer(const TopoDS_Shape
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a</code></td>
          <td>	<code>void PerformFF(const TopoDS_Shape &th
	
	Standard_EXPORT
	void FillEdgesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillFacesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillSolidsOn(const TopoDS_Shape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 32-33</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 60-61[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder = BRepPrimAPI_
	TopoDS_Shape aCylinder2 = BRepPrimAPI</code></td>
          <td>	<code>TopoDS_Shape aCylinder = BRepPrimAPI_
	TopoDS_Shape aCylinder2 = BRepPrimAPI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 138-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 114-117[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{
	// LOG_F(INFO, "export Dataset pointe
	Handle(TDocStd_Document) aDoc = creat</code></td>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{
	readBrep(file_name);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 55-59</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 310-314[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>(const TopoDS_Shape &theWhere,
	const TopoDS_Shape &theWhat,
	GEOMAlgo_GetInPlace &theGIP)
	{</code></td>
          <td>	<code>const TopTools_IndexedMapOfShape &the
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 58-68</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.hxx: line 129-139[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	void SetShapesToGlue(const TopTools_D
	
	Standard_EXPORT
	const TopTools_DataMapOfShapeListOfSh
	
	Standard_EXPORT
	void SetKeepNonSolids(const Standard_
	
	Standard_EXPORT
	Standard_Boolean KeepNonSolids() cons</code></td>
          <td>	<code>Standard_EXPORT
	void SetPnt2(const gp_Pnt& aP) ;
	
	Standard_EXPORT
	const gp_Pnt& Pnt2() const;
	
	Standard_EXPORT
	void SetRadius1(const Standard_Real a
	
	Standard_EXPORT
	Standard_Real Radius1() const;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 415-420</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 236-241[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	//
	for (i=1; i<=aNbC; ++i) {
	const TopTools_ListOfShape& aLSx=aMPK
	const TopoDS_Shape& aSx1=aLSx.First()</code></td>
          <td>	<code>return;
	}
	//
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);
	const TopoDS_Vertex& aV=TopoDS::Verte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 874-879</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 93-98[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfName(GEOMAlgo_KN_SPHER
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
          <td>	<code>theGIP.SetTolerance(aTolConf);
	theGIP.SetTolMass(aMassTol);
	theGIP.SetTolCG(aTolConf);
	
	theGIP.SetArgument(theWhat);
	theGIP.SetShapeWhere(theWhere);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 81-84</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 800-803[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (size_t i = 0; i < myInputData->i
	{
	const auto& p = myGeometryProperties[
	if (p.volume > max_volume and p.volum</code></td>
          <td>	<code>for (std::size_t i = 0; i < myInputDa
	{
	const auto& row = myCollisionInfos[i]
	if (row.size() == 0)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 136-139</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 402-404[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>aShape=myShape;
	//
	aIt1.Initialize(myShape);
	for (aNbS=0; aIt1.More(); aIt1.Next()</code></td>
          <td>	<code>bIsConformState=Standard_True;
	aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 29-31</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 120-121[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>target_link_libraries(app_tests Catch2:
	
	####################### standalone app</code></td>
          <td>	<code>#target_link_libraries(parallel_tests C
	#######################################
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 713-718</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 818-823[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (j=1; j<aNbT; ++j) {
	aT=aT1+j*dT;
	aC3D->D0(aT, aP);
	aLP.Append(aP);
	}
	}</code></td>
          <td>	<code>for (j=1; j<=aNbPntsMin; ++j) {
	aT=aT1+j*dT;
	aC3D->D0(aT, aP);
	aLP.Append(aP);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 121-125</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 126-130[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	else if (aType2==TopAbs_FACE) {
	const TopoDS_Face& aF2=*((TopoDS_Face
	iErr=PntInFace(aF2, aP2);</code></td>
          <td>	<code>}
	//
	else if (aType2==TopAbs_SOLID) {
	const TopoDS_Solid& aZ2=*((TopoDS_Sol
	iErr=PntInSolid(aZ2, myTolerance, aP2</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 272-288</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 288-304[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetPnt1(const
	{
	myPnt1=aP;
	}
	//=====================================
	//function : Pnt1
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Pnt1(
	{
	return myPnt1;
	}
	//=====================================
	//function : SetPnt2
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetPnt2(const</code></td>
          <td>	<code>void GEOMAlgo_ShapeInfo::SetPnt2(const
	{
	myPnt2=aP;
	}
	//=====================================
	//function : Pnt2
	//purpose :
	//=====================================
	const gp_Pnt& GEOMAlgo_ShapeInfo::Pnt2(
	{
	return myPnt2;
	}
	//=====================================
	//function : SetRadius1
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::SetRadius1(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 129-137</strong></td>
        <td style="text-align:center"><strong>src/PPP/CommandLineProcessor.h: line 102-111[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace<decltype(myMatc
	}
	
	/**
	* \brief process single data item in
	* @param index: index to get/set by i
	*/
	virtual void processItem(const ItemIn
	{
	</code></td>
          <td>	<code>myOutputData->emplace<decltype(myItem
	}
	
	/**
	* \brief process data item in paralle
	*
	* @param index: index to get input da
	*/
	virtual void processItem(const ItemIn
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 747-751</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 751-753[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace("myCompounds",
	myOutputData->emplace("myOtherShapes"
	
	// STEP214 meta data
	myOutputData->emplace("myColorMap", s</code></td>
          <td>	<code>myOutputData->emplace("myColorMap", s
	myOutputData->emplace("myMaterialMap"
	myOutputData->emplace<MapType<ItemHas
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 370-371</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 493-495[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer imod, aModifLen = an
	for (imod = 1; imod <= aModifLen; imo
	</code></td>
          <td>	<code>Standard_Integer imod, aModifLen = an
	for ( imod = 1; imod <= aModifLen; im
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 48-50</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 116-118[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.Vector(x * length, 0, 0), App.Rot
	)
	doc.recompute()</code></td>
          <td>	<code>App.Vector(10, 10, 0), App.Rotation(A
	)
	doc.recompute()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 2-9</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 1-7[30]</strong></td>
        </tr>
        <tr>
          <td>	<code># -*- coding: utf-8 -*-
	
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path</code></td>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Clsf.hxx: line 51-61</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 58-68[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	void SetPnt(const gp_Pnt& aP) ;
	
	Standard_EXPORT
	const gp_Pnt& Pnt() const;
	
	Standard_EXPORT
	void SetTolerance(const Standard_Real
	
	Standard_EXPORT
	Standard_Real Tolerance() const;</code></td>
          <td>	<code>Standard_EXPORT
	void SetShapesToGlue(const TopTools_D
	
	Standard_EXPORT
	const TopTools_DataMapOfShapeListOfSh
	
	Standard_EXPORT
	void SetKeepNonSolids(const Standard_
	
	Standard_EXPORT
	Standard_Boolean KeepNonSolids() cons</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 521-531</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1166-1175[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>} else {
	// Get an edge as it is.
	aListEdges.Append(anEdge);
	}
	}
	
	if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	}
	
	if (!aListListEdges.IsEmpty()) {</code></td>
          <td>	<code>} else {
	aListEdges.Append(anEdge);
	}
	}
	
	if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	}
	
	if (isModified && !aListListEdges.IsE
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 391-395</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 465-469[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_CYLI
	aInfo.SetKindOfName(GEOMAlgo_KN_CYLIN
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_TORU
	aInfo.SetKindOfName(GEOMAlgo_KN_TORUS
	aInfo.SetLocation(aP0);
	aInfo.SetPosition(aAx3);
	aInfo.SetRadius1(aR1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 811-821</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 426-436[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLE.Append(aER);
	}
	aPK.SetShapes(aLE);
	}
	//=====================================
	//function : EdgePassKey
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::EdgePassKey(const
	GEOMAlgo_PassKeyShape& aPK)
	{</code></td>
          <td>	<code>aLE.Append(aER);
	}
	aPK.SetShapes(aLE);
	}
	//=====================================
	//function : EdgePassKey
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::EdgePassKey
	GEOMAlgo_PassKeyShape& aPK)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 243-244</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 315-316[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (anAncIt.Initialize(anAncWires);
	const TopoDS_Shape &anAncShape = anAn</code></td>
          <td>	<code>for (anIter.Initialize(mySubShapes);
	const TopoDS_Shape &aSubShape = anIte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 85-92</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOnQuad.hxx: line 55-61[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>bool myConcaveQuad;
	std::vector<bool> myConcaveSide;
	std::vector<gp_Pnt> myPoints;
	std::vector<GeomAdaptor_Surface> myPl
	gp_Vec myQuadNormal;
	
	};
	#endif</code></td>
          <td>	<code>bool myConcaveQuad;
	std::vector<bool> myConcaveSide;
	std::vector<gp_Pnt> myPoints;
	std::vector<GeomAdaptor_Surface> myPl
	gp_Vec myQuadNormal;
	};
	#endif
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 1-7</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 2-9[30]</strong></td>
        </tr>
        <tr>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path
	</code></td>
          <td>	<code># -*- coding: utf-8 -*-
	
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 818-823</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 713-718[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (j=1; j<=aNbPntsMin; ++j) {
	aT=aT1+j*dT;
	aC3D->D0(aT, aP);
	aLP.Append(aP);
	}
	}</code></td>
          <td>	<code>for (j=1; j<aNbT; ++j) {
	aT=aT1+j*dT;
	aC3D->D0(aT, aP);
	aLP.Append(aP);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1118-1122</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1152-1154[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=aS.ShapeType();</code></td>
          <td>	<code>aType=aS.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 133-143</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 163-174[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>myImages.Clear();
	myOrigins.Clear();
	}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::Perform()
	{
	if (myContext.IsNull()) {
	myContext=new IntTools_Context;
	</code></td>
          <td>	<code>myMapModified.Clear();
	myMapNewShapeAnc.Clear();
	}
	
	//=====================================
	//function : checkData
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::checkData()
	{
	if (myShape.IsNull()) {
	myErrorStatus = 10;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 842-848</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 530-534[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_GetInPlace::PerformZZ()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_SOLID, T
	for (; myIterator.More(); myIterator.</code></td>
          <td>	<code>if (aNbV==2 && aNbE==3) {
	aNbSE=0;
	aNbDE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 727-730</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 536-540[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aMFR.Contains(aFS)) {
	const TopTools_ListOfShape& aLSx=aMFR
	aNbSx=aLSx.Extent();
	if (aNbSx==2) {
	</code></td>
          <td>	<code>if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKSE=aInfoE.KindOfShape();
	//
	if (BRep_Tool::IsClosed(aE, aF)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 65-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 72-75[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(CollisionDetector::detectColl
	// if using detectCollisionType(), ju
	
	// "equal parameter shapes count as c
	REQUIRE(CollisionDetector::detectColl
	
	// radius + confusion()
	TopoDS_Shape aCylinder3 = BRepPrimAPI</code></td>
          <td>	<code>TopoDS_Shape aCylinder3 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl
	
	TopoDS_Shape aCylinder4 = BRepPrimAPI
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 32-35</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 37-40[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>fc_filename2 = "../../ppp_validation_
	meta_data_output_filename = fc_filena
	elif len(sys.argv) == 2:
	fc_filename = sys.argv[1]</code></td>
          <td>	<code>raise "Input file does not exist, exi
	meta_data_output_filename = fc_filena
	elif len(sys.argv) == 3:
	fc_filename = sys.argv[1]</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 120-121</strong></td>
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 29-31[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>#target_link_libraries(parallel_tests C
	#######################################
	</code></td>
          <td>	<code>target_link_libraries(app_tests Catch2:
	
	####################### standalone app</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 514-518</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1029-1033[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_DataMapOfShapeListOfSh
	TopTools_DataMapIteratorOfDataMapOfSh
	for ( ; imgIt.More(); imgIt.Next() )
	{
	const TopoDS_Shape& whatSub = imgIt.K</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSi = my
	TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSubSi = aItLS.Va</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 1-7</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 1-7[30]</strong></td>
        </tr>
        <tr>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path</code></td>
          <td>	<code># -*- coding: utf-8 -*-
	# copyright Qingfeng Xia
	# UKAEA internal usage only
	
	from __future__ import print_function,
	import sys
	import os.path</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 133-136</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 136-138[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>static bool hasCollision(const TopoDS
	/** using fusion volume to detect col
	static CollisionInfo detectCollision(
	std::vector<Standard_Real> volumes, d</code></td>
          <td>	<code>std::vector<Standard_Real> volumes, d
	static CollisionType detectCollisionT
	std::vector<Standard_Real> volumes, d
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 702-708</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 710-716[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNewShape.ShapeType() == aSubShap
	aNewSubShapes.Append(aNewShape);
	} else {
	aNewOtherShapes.Append(aNewShape);
	}
	}
	} else if (!myMapRemoved.Contains(aSu</code></td>
          <td>	<code>if (aSubShape.ShapeType() == aSubShap
	aNewSubShapes.Append(aSubShape);
	} else {
	aNewOtherShapes.Append(aSubShape);
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 57-61</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 455-458[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aF2=aCS.Shape2();
	//
	//
	if (aMCV.Contains(aF1)) {</code></td>
          <td>	<code>const TopoDS_Shape& aE1=aCS.Shape1();
	const TopoDS_Shape& aV2=aCS.Shape2();
	//
	if (myShapesOn.IsBound(aE1)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ProcessorTemplate.h: line 100-109</strong></td>
        <td style="text-align:center"><strong>src/PPP/CommandLineProcessor.h: line 102-112[30]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace(myResultName, s
	}
	
	/**
	* \brief process data item in paralle
	* @param index: index to get/set itea
	*/
	virtual void processItem(const ItemIn
	{
	myResultData[index] = myItemProcessor
	</code></td>
          <td>	<code>myOutputData->emplace<decltype(myItem
	}
	
	/**
	* \brief process data item in paralle
	*
	* @param index: index to get input da
	*/
	virtual void processItem(const ItemIn
	{
	myItemInputs[index] = prepareItemInpu</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 811-817</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 653-657[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapOfShape aMSX;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myIterator.Initialize(TopAbs_SOLID, T
	for (; myIterator.More(); myIterator.</code></td>
          <td>	<code>aNbCE=0;
	aNbSE=0;
	aNbDE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 375-378</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 350-352[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS1=aLSDF.First()
	//
	if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge</code></td>
          <td>	<code>const TopoDS_Shape aSx=aExp.Current()
	if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aEx=*((TopoDS_Edge
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 272-289</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 145-161[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillImages(myArgument, Standard_False
	
	if (myErrorStatus) {
	return;
	}
	//
	CheckGProps();
	if (myErrorStatus) {
	return;
	}
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::CheckData()
	{
	myErrorStatus=0;</code></td>
          <td>	<code>DetectFaces();
	if (myErrorStatus) {
	return;
	}
	//
	DetectSolids();
	if (myErrorStatus) {
	return;
	}
	}
	//=====================================
	//function : DetectVertices
	//purpose :
	//=====================================
	void GEOMAlgo_GlueAnalyser::DetectVer
	{
	myErrorStatus=0;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 249-250</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 139-140[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=0; aItLS.More(); aItLS.Next(),
	const TopoDS_Shape& aSG=aItLS.Value()</code></td>
          <td>	<code>for (aNbS=0; aIt1.More(); aIt1.Next()
	const TopoDS_Shape& aS=aIt1.Value();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/CMakeLists.txt: line 23-23</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 12-14[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>##################### standalone app ##
	
	</code></td>
          <td>	<code>import unittest
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 103-109</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 720-728[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>sout << "count of result solids is "
	
	LOG_F(INFO, "%s", sout.str().c_str())
	}
	
	/// can export floating shapes which
	void exportCompound(const std::string
	
	</code></td>
          <td>	<code>sout << " length of material map: " <
	LOG_F(INFO, "%s", sout.str().c_str())
	}
	
	/** only items of ShapeType::Solid wi
	* after move, private members such as
	* using the public property get and s
	*/
	void moveShapeIntoPropertyContainer()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfName.hxx: line 23-38</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfShape.hxx: line 23-37[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_KindOfName_HeaderFile
	#define _GEOMAlgo_KindOfName_HeaderFile
	
	
	enum GEOMAlgo_KindOfName {
	GEOMAlgo_KN_UNKNOWN,
	GEOMAlgo_KN_SPHERE,
	GEOMAlgo_KN_CYLINDER,
	GEOMAlgo_KN_TORUS,
	GEOMAlgo_KN_CONE,
	GEOMAlgo_KN_ELLIPSE,
	GEOMAlgo_KN_CIRCLE,
	GEOMAlgo_KN_PLANE,
	GEOMAlgo_KN_LINE,
	GEOMAlgo_KN_BOX,
	GEOMAlgo_KN_SEGMENT,</code></td>
          <td>	<code>#ifndef _GEOMAlgo_KindOfShape_HeaderFil
	#define _GEOMAlgo_KindOfShape_HeaderFil
	
	enum GEOMAlgo_KindOfShape {
	GEOMAlgo_KS_UNKNOWN,
	GEOMAlgo_KS_SPHERE,
	GEOMAlgo_KS_CYLINDER,
	GEOMAlgo_KS_BOX,
	GEOMAlgo_KS_TORUS,
	GEOMAlgo_KS_CONE,
	GEOMAlgo_KS_ELLIPSE,
	GEOMAlgo_KS_PLANE,
	GEOMAlgo_KS_CIRCLE,
	GEOMAlgo_KS_LINE,
	GEOMAlgo_KS_DEGENERATED,
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 280-285</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 291-295[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPCheck.SetShape1(BOPCopy);
	// all settings are false by default.
	BOPCheck.ArgumentTypeMode() = argumen
	BOPCheck.SelfInterMode() = selfInterM
	BOPCheck.SmallEdgeMode() = smallEdgeM
	BOPCheck.RebuildFaceMode() = rebuildF</code></td>
          <td>	<code>BOPCheck.SetRunParallel(!runSingleThr
	BOPCheck.TangentMode() = tangentMode;
	BOPCheck.MergeVertexMode() = mergeVer
	BOPCheck.MergeEdgeMode() = mergeEdgeM
	BOPCheck.CurveOnSurfaceMode() = curve
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 150-153</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 178-181[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	//
	GeomAPI_ProjectPointOnCurve& aPPC=myC
	aPPC.Perform(aP2);</code></td>
          <td>	<code>const TopoDS_Solid& aZ1=*((TopoDS_Sol
	//
	BRepClass3d_SolidClassifier& aSC=myCo
	aSC.Perform(aP2, myTolerance);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 263-280</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 288-293[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>setSerializable<decltype(realType)>(k
	}
	
	/**
	* \brief set property data using defa
	*
	* if user wants this container to own
	* using `setData<>` or `set(key, std:
	*
	* @param Ptr template parameter point
	* - std::shared_ptr<T>:
	* - std::decltype<T>: as the data typ
	* - std::unique_ptr<T>: emplace and e
	* @param key `std::string` or `const
	* if the key have existed, just repla
	*/
	template <typename T, typename Ptr =
	void setSerializable(const std::strin</code></td>
          <td>	<code>myProperties.emplace(key, std::move(p
	}
	
	/// if the key existed, erase first
	template <typename T, typename Ptr =
	void setSerializable(const std::strin
	
	
	
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 43-44</strong></td>
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 57-60[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif()
	########################## main #######
	
	</code></td>
          <td>	<code>endif()
	
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 73-82</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.hxx: line 55-64[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS3) ;
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	const TopoDS_Shape& aS2,
	const TopoDS_Shape& aS3,
	const TopoDS_Shape& aS4) ;
	
	Standard_EXPORT
	void SetShapes(const TopTools_ListOfS</code></td>
          <td>	<code>virtual ~GEOMAlgo_ClsfQuad();
	
	Standard_EXPORT
	void SetCorners(const gp_Pnt &theTopL
	const gp_Pnt &theTopRightPoint,
	const gp_Pnt &theBottomLeftPoint,
	const gp_Pnt &theBottomRightPoint);
	
	Standard_EXPORT
	void GetCorners(gp_Pnt &theTopLeftPoi</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 683-688</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 248-253[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aIt.Initialize(aE);
	if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}
	//
	aPD=BRep_Tool::Pnt(aVD);</code></td>
          <td>	<code>aExp.Init (aZ, TopAbs_FACE);
	if (aExp.More()) {
	aF=*((TopoDS_Face*)&aExp.Current());
	}
	//
	iErr=PntInFace(aF, aPx, aP2Dx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 312-313</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 45-46    [29]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<std::stringstream> sa
	const std::string& fileType)</code></td>
          <td>	<code>GeomExport std::shared_ptr<std::strin
	const std::string& fileType = "brep")</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 706-714</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 715-722[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (ctype == CollisionType::Inte
	{
	// the other has no other interferenc
	// if (myCollisionInfos[j].size() > 1
	if (not itemSuppressed(i))
	{
	suppressItemImpl(i, ctype);
	}</code></td>
          <td>	<code>}
	else if (ctype == CollisionType::Coin
	{
	// item i and j are both floating, on
	if (not itemSuppressed(i))
	{
	suppressItemImpl(i, ctype);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 528-532</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 649-653[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {
	aNbSE=0;
	aNbDE=0;</code></td>
          <td>	<code>aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {
	i=0;
	aNbCE=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/OperatorProxy.h: line 69-78</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryOperatorProxy.h: line 24-32[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/// report the content
	virtual void report(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->report(msg);
	}</code></td>
          <td>	<code>}
	
	virtual void display(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->display(msg);
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfShape.hxx: line 23-37</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfName.hxx: line 23-38[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_KindOfShape_HeaderFil
	#define _GEOMAlgo_KindOfShape_HeaderFil
	
	enum GEOMAlgo_KindOfShape {
	GEOMAlgo_KS_UNKNOWN,
	GEOMAlgo_KS_SPHERE,
	GEOMAlgo_KS_CYLINDER,
	GEOMAlgo_KS_BOX,
	GEOMAlgo_KS_TORUS,
	GEOMAlgo_KS_CONE,
	GEOMAlgo_KS_ELLIPSE,
	GEOMAlgo_KS_PLANE,
	GEOMAlgo_KS_CIRCLE,
	GEOMAlgo_KS_LINE,
	GEOMAlgo_KS_DEGENERATED,
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_KindOfName_HeaderFile
	#define _GEOMAlgo_KindOfName_HeaderFile
	
	
	enum GEOMAlgo_KindOfName {
	GEOMAlgo_KN_UNKNOWN,
	GEOMAlgo_KN_SPHERE,
	GEOMAlgo_KN_CYLINDER,
	GEOMAlgo_KN_TORUS,
	GEOMAlgo_KN_CONE,
	GEOMAlgo_KN_ELLIPSE,
	GEOMAlgo_KN_CIRCLE,
	GEOMAlgo_KN_PLANE,
	GEOMAlgo_KN_LINE,
	GEOMAlgo_KN_BOX,
	GEOMAlgo_KN_SEGMENT,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 827-830</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 996-999[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (anExp.Init(myShape, theType); an
	const TopoDS_Shape &aShape = anExp.Cu
	
	if (aMapFence.Add(aShape)) {</code></td>
          <td>	<code>for (aMapIt.Initialize(aMapAncs[iCur]
	const TopoDS_Shape &aShape = aMapIt.K
	
	if (aShape.ShapeType() == aType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 731-743</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 533-546[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}// for (i=1; i<aNb; ++i) {
	}// if (!aNb && myNbPntsMin) {
	}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	myErrorStatus=0;
	//
	Standard_Integer j, aNbNodes, aIndex,
	</code></td>
          <td>	<code>}
	}
	}
	//
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	myErrorStatus=0;
	//
	Standard_Integer j, j1, j2, k, n[4],</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 604-608</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 408-412[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aP3D.SetCoord(99.,99.,99.);
	aType=aS.ShapeType();
	switch(aType) {
	case TopAbs_EDGE: {
	const TopoDS_Edge& aE=TopoDS::Edge(aS</code></td>
          <td>	<code>const TopoDS_Shape& aS=aM(i);
	aType=aS.ShapeType();
	switch (aType) {
	case TopAbs_VERTEX: {
	const TopoDS_Vertex& aVx=TopoDS::Vert</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 653-657</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 446-453[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbCE=0;
	aNbSE=0;
	aNbDE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	
	
	</code></td>
          <td>	<code>Standard_Boolean bFound;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	// 2. Fill Shapes In
	myIterator.Initialize(TopAbs_EDGE, To
	for (; myIterator.More(); myIterator.</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 434-435</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 808-809[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aWExp.Init(aW, aF);
	for (i=0; aWExp.More(); aWExp.Next(),</code></td>
          <td>	<code>aExp.Init(aSd, TopAbs_FACE);
	for (j=0; aExp.More(); aExp.Next(), +</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 380-381</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 381-382[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>shapes.push_back(BRepPrimAPI_MakeBox(
	shapes.push_back(BRepPrimAPI_MakeBox(</code></td>
          <td>	<code>shapes.push_back(BRepPrimAPI_MakeBox(
	shapes.push_back(BRepPrimAPI_MakeBox(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 752-761</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 827-836[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//
	bFound=CheckCoincidence(theF1, theF2)
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(theF1, theF2);
	}
	}</code></td>
          <td>	<code>}
	//------------------------------
	bFound=CheckCoincidence(aSo1, aF2);
	if (myErrorStatus) {
	return;
	}
	if (bFound) {
	FillShapesIn(aSo1, aF2);
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1124-1127</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1245-1248[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator anIter(theShape);
	
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte</code></td>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	
	for (;anIter.More(); anIter.Next()) {
	const TopTools_ListOfShape &anEdges =</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 451-459</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 464-471[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aFlag=BOPTools_AlgoTools2D::EdgeTange
	
	if(!aFlag) {
	return Standard_False;
	}
	
	gp_Dir aDT1(aV1);
	//
	aFlag=aContext->ProjectPointOnEdge(aP</code></td>
          <td>	<code>aFlag=BOPTools_AlgoTools2D::EdgeTange
	if(!aFlag) {
	return Standard_False;
	}
	
	gp_Dir aDT2(aV2);
	
	aScPr=aDT1*aDT2;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 56-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 106-124[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>void Perform() ;
	
	Standard_EXPORT
	const TopTools_IndexedDataMapOfShapeL
	
	protected:
	Standard_EXPORT
	void DetectVertices() ;
	
	Standard_EXPORT
	void DetectEdges() ;
	
	Standard_EXPORT
	void DetectFaces() ;
	
	Standard_EXPORT
	void DetectShapes(const TopAbs_ShapeE
	
	</code></td>
          <td>	<code>TopTools_MapOfShape& theM) ;
	
	//modified by NIZNHY-PKV Tue Mar 13 12:
	Standard_EXPORT
	const TopTools_IndexedDataMapOfShapeL
	//modified by NIZNHY-PKV Tue Mar 13 12:
	//-------------------------------------
	protected:
	Standard_EXPORT
	void PerformShapesToWork() ;
	
	Standard_EXPORT
	void FillVertices() ;
	
	Standard_EXPORT
	void FillEdges() ;
	
	Standard_EXPORT
	void FillWires() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 319-323</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 518-522[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSurf=BRep_Tool::Surface(aF);
	GeomAdaptor_Surface aGAS(aSurf);
	aST=aGAS.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
          <td>	<code>aC3D=BRep_Tool::Curve(aE, aT1, aT2);
	GeomAdaptor_Curve aGAC(aC3D);
	aCT=aGAC.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 967-970</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 320-324[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Wire& aW=TopoDS::Wire(aE
	aExpE.Init(aW, TopAbs_EDGE);
	for (; aExpE.More(); aExpE.Next()) {
	const TopoDS_Edge& aE=TopoDS::Edge(aE
	</code></td>
          <td>	<code>const TopoDS_Edge& aE=TopoDS::Edge(aM
	//
	aExp.Init(aE, TopAbs_VERTEX);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aV=aExp.Current()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 45-46</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 312-313[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport std::shared_ptr<std::strin
	const std::string& fileType = "brep")</code></td>
          <td>	<code>std::shared_ptr<std::stringstream> sa
	const std::string& fileType)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 720-728</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 103-109[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>sout << " length of material map: " <
	LOG_F(INFO, "%s", sout.str().c_str())
	}
	
	/** only items of ShapeType::Solid wi
	* after move, private members such as
	* using the public property get and s
	*/
	void moveShapeIntoPropertyContainer()</code></td>
          <td>	<code>sout << "count of result solids is "
	
	LOG_F(INFO, "%s", sout.str().c_str())
	}
	
	/// can export floating shapes which
	void exportCompound(const std::string
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 320-324</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 967-970[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE=TopoDS::Edge(aM
	//
	aExp.Init(aE, TopAbs_VERTEX);
	for (; aExp.More(); aExp.Next()) {
	const TopoDS_Shape& aV=aExp.Current()</code></td>
          <td>	<code>const TopoDS_Wire& aW=TopoDS::Wire(aE
	aExpE.Init(aW, TopAbs_EDGE);
	for (; aExpE.More(); aExpE.Next()) {
	const TopoDS_Edge& aE=TopoDS::Edge(aE
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 695-701</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 211-216[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	//
	if (aMProcessed.Contains(aS)) {
	continue;
	}
	//
	aType=aS.ShapeType();</code></td>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	if (myMapTools.Contains(aS)) {
	continue;
	}
	//
	aType=aS.ShapeType();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 54-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 47-64[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_Extractor::GEOMAlgo_Extractor(
	{
	}
	
	//=====================================
	//function : ~GEOMAlgo_Extractor
	//purpose :
	//=====================================
	GEOMAlgo_Extractor::~GEOMAlgo_Extractor
	{
	}
	
	//=====================================
	//function : SetShape
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::SetShape(const
	{
	myShape = theShape;</code></td>
          <td>	<code>:
	GEOMAlgo_ShellSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_SolidSolid::~GEOMAlgo_SolidSol
	{
	}
	//=====================================
	// function: SetShape2
	// purpose:
	//=====================================
	void GEOMAlgo_SolidSolid::SetShape2(con
	{
	myS2=aS2;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 318-324</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 402-409[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Builder cBuilder;
	TopoDS_Compound merged;
	cBuilder.MakeCompound(merged);
	for (const auto& item : shapes)
	{
	cBuilder.Add(merged, item);
	}
	</code></td>
          <td>	<code>TopoDS_Builder cBuilder;
	// to do compound
	TopoDS_Compound merged;
	cBuilder.MakeCompound(merged);
	for (const auto& item : shapes)
	{
	cBuilder.Add(merged, item);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 39-49</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 93-103[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_IndexedDataMapOfShapeI
	TopTools_IndexedMapOfShape& aProcesse
	TopTools_IndexedMapOfShape& aChain);
	
	//=====================================
	// function: FindChains
	// purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::FindChains(con
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	{</code></td>
          <td>	<code>void CopySource(const TopoDS_Shape& a
	TopTools_IndexedDataMapOfShapeShape&
	TopoDS_Shape& aSC);
	
	//=====================================
	//function : CopyShape
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::CopyShape(cons
	TopoDS_Shape& aSC)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 264-278</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 109-124[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	const TopoDS_Shape &Result();
	
	protected:
	Standard_EXPORT
	void Intersect() ;
	
	Standard_EXPORT
	void PerformVV() ;
	
	Standard_EXPORT
	void PerformVE() ;
	
	Standard_EXPORT
	void PerformEE() ;
	</code></td>
          <td>	<code>Standard_EXPORT
	const TopTools_IndexedDataMapOfShapeL
	//modified by NIZNHY-PKV Tue Mar 13 12:
	//-------------------------------------
	protected:
	Standard_EXPORT
	void PerformShapesToWork() ;
	
	Standard_EXPORT
	void FillVertices() ;
	
	Standard_EXPORT
	void FillEdges() ;
	
	Standard_EXPORT
	void FillWires() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 510-512</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 514-516[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto tp = fs::temp_directory_path() /
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(unifyFaces(loa</code></td>
          <td>	<code>tp = fs::temp_directory_path() / "_tm
	saveShape(glueFaces(compSolid), tp.st
	REQUIRE(countSubShapes(loadShape(tp.s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 164-181</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 49-66[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShellSolid::GEOMAlgo_ShellSoli
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShellSolid::~GEOMAlgo_ShellSol
	{
	}
	//=====================================
	// function:
	// purpose:
	//=====================================
	void GEOMAlgo_ShellSolid::Perform()
	{</code></td>
          <td>	<code>GEOMAlgo_RemoverWebs::GEOMAlgo_RemoverW
	:
	GEOMAlgo_ShapeAlgo()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_RemoverWebs::~GEOMAlgo_Remover
	{
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::CheckData()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 677-687</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 696-707[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" number of faces : %d\n", aNb
	aKC=KindOfClosed();
	DumpKindOfClosed(aKC);
	printf("\n");
	}
	//=====================================
	//function : DumpWire
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::DumpWire()cons
	{
	</code></td>
          <td>	<code>printf(" number of edges : %d\n", aNb
	
	aKC=KindOfClosed();
	DumpKindOfClosed(aKC);
	printf("\n");
	}
	//=====================================
	//function : DumpEdge
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfo::DumpEdge()cons
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 560-566</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 567-573[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	Standard_Real area(const TopoDS_Shape
	{
	GProp_GProps s_props;
	BRepGProp::SurfaceProperties(s, s_pro
	return s_props.Mass();</code></td>
          <td>	<code>}
	
	Standard_Real perimeter(const TopoDS_
	{
	GProp_GProps l_props;
	BRepGProp::LinearProperties(s, l_prop
	return l_props.Mass();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 658-661</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 726-729[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aE=TopoDS::Edge(aExp.Current());
	if(aM.Add(aE)) {
	const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();</code></td>
          <td>	<code>const TopoDS_Shape& aFS=aMFS(j);
	if (aMFR.Contains(aFS)) {
	const TopTools_ListOfShape& aLSx=aMFR
	aNbSx=aLSx.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 757-761</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 763-767[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>else if (aKN==GEOMAlgo_KN_ELLIPSE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius</code></td>
          <td>	<code>else if (aKN==GEOMAlgo_KN_ARCELLIPSE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius
	printf(" Radius2 : %.3lf\n", myRadius</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 169-176</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 346-353[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aMV, aMVPr
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBox aMS
	//
	TopExp::MapShapes(myShape, TopAbs_VER
	aNbV=aMV.Extent();</code></td>
          <td>	<code>Standard_Integer i, aNb, iCnt, iErr;
	TopAbs_State aSt;
	TopTools_IndexedMapOfShape aM;
	TopExp_Explorer aExp;
	GEOMAlgo_ListIteratorOfListOfPnt aIt;
	//
	TopExp::MapShapes(myShape, TopAbs_EDG
	aNb=aM.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1133-1144</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1181-1192[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	//=====================================
	//function : removeCommonEdges
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Extractor::re
	(const TopoDS_Shape &theWire,
	const TopTools_IndexedMapOfShape &the
	TopTools_ListOfShape &theNewWires)
	{
	TopExp_Explorer anExp(theWire, TopAbs</code></td>
          <td>	<code>}
	
	//=====================================
	//function : removeCommonFaces
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Extractor::re
	(const TopoDS_Shape &theShell,
	const TopTools_IndexedMapOfShape &the
	TopTools_ListOfShape &theNewShells)
	{
	TopExp_Explorer anExp(theShell, TopAb</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 273-275</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 195-198[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.MakeCompound(aCmp);
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aSi=aM(i);
	</code></td>
          <td>	<code>aBSB.Initialize(aHAB);
	//
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 350-352</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 375-378[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape aSx=aExp.Current()
	if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aEx=*((TopoDS_Edge
	</code></td>
          <td>	<code>const TopoDS_Shape& aS1=aLSDF.First()
	//
	if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE1=*((TopoDS_Edge</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 170-172</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 465-467[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::vector<TopoDS_Shape> solveWeakIn
	std::vector<Standard_Real> resultsVol
	const std::vector<TopoDS_Shape> origI</code></td>
          <td>	<code>std::vector<TopoDS_Shape> CollisionDe
	std::vector<Standard_Real> resultsVol
	const std::vector<TopoDS_Shape>, // o</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 276-278</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 145-147[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>ppp_start_pipeline(self.config_file_n
	
	######################### post proces</code></td>
          <td>	<code>print("action on the geometry is ", a
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryOperatorProxy.h: line 24-32</strong></td>
        <td style="text-align:center"><strong>src/PPP/OperatorProxy.h: line 59-68[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	virtual void display(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->display(msg);
	}
	</code></td>
          <td>	<code>}
	
	/// display the content
	virtual void display(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->display(msg);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 605-611</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 552-558[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	aLP.Clear();
	//
	aTRF=BRep_Tool::Triangulation(aF, aLo
	if (aTRF.IsNull()) {
	if (!BuildTriangulation(aF)) {</code></td>
          <td>	<code>gp_Pnt aP, aP1, aP2;
	//
	aLP.Clear();
	//
	aTRF=BRep_Tool::Triangulation(aF, aLo
	if (aTRF.IsNull()) {
	if (!GEOMAlgo_AlgoTools::BuildTriangu</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 138-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 271-275[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(compSolid.ShapeType() == TopA
	
	REQUIRE(countSubShapes(compSolid, Top
	REQUIRE(countSubShapes(compSolid, Top
	}</code></td>
          <td>	<code>REQUIRE(info["compsolids"] == 1);
	
	REQUIRE(countSubShapes(compSolid, Top
	REQUIRE(countSubShapes(compSolid, Top
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 996-999</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 360-362[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (aMapIt.Initialize(aMapAncs[iCur]
	const TopoDS_Shape &aShape = aMapIt.K
	
	if (aShape.ShapeType() == aType) {</code></td>
          <td>	<code>for (; aItIm.More(); aItIm.Next()) {
	const TopoDS_Shape& aIm=aItIm.Key();
	if (aIm.ShapeType()!=TopAbs_FACE) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 523-529</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 588-594[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	printf(" number of faces : %d\n", aNb
	DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);</code></td>
          <td>	<code>printf(" *FACE\n");
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	DumpKindOfShape (aKS);
	DumpKindOfName (aKN);
	DumpKindOfBounds(aKB);
	DumpKindOfClosed(aKC);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 465-467</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 170-172[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::vector<TopoDS_Shape> CollisionDe
	std::vector<Standard_Real> resultsVol
	const std::vector<TopoDS_Shape>, // o</code></td>
          <td>	<code>std::vector<TopoDS_Shape> solveWeakIn
	std::vector<Standard_Real> resultsVol
	const std::vector<TopoDS_Shape> origI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/OperatorProxy.h: line 59-68</strong></td>
        <td style="text-align:center"><strong>src/PPP/OperatorProxy.h: line 69-78[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/// display the content
	virtual void display(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->display(msg);
	}</code></td>
          <td>	<code>}
	
	/// report the content
	virtual void report(const json& msg)
	{
	for (auto& op : myOperators)
	{
	// send request to show, then send fi
	op->report(msg);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 49-66</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 50-67[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_RemoverWebs::GEOMAlgo_RemoverW
	:
	GEOMAlgo_ShapeAlgo()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_RemoverWebs::~GEOMAlgo_Remover
	{
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::CheckData()
	{</code></td>
          <td>	<code>GEOMAlgo_WireSolid::GEOMAlgo_WireSolid(
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_WireSolid::~GEOMAlgo_WireSolid
	{
	}
	//=====================================
	// function: Perform
	// purpose:
	//=====================================
	void GEOMAlgo_WireSolid::Perform()
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 809-812</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 996-999[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!aNewShapes.IsEmpty()) {
	const TopoDS_Shape &aNewShape = aNewS
	
	if (aNewShape.ShapeType() == theType)</code></td>
          <td>	<code>for (aMapIt.Initialize(aMapAncs[iCur]
	const TopoDS_Shape &aShape = aMapIt.K
	
	if (aShape.ShapeType() == aType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 93-103</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 39-49[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>void CopySource(const TopoDS_Shape& a
	TopTools_IndexedDataMapOfShapeShape&
	TopoDS_Shape& aSC);
	
	//=====================================
	//function : CopyShape
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::CopyShape(cons
	TopoDS_Shape& aSC)
	{</code></td>
          <td>	<code>const GEOMAlgo_IndexedDataMapOfShapeI
	TopTools_IndexedMapOfShape& aProcesse
	TopTools_IndexedMapOfShape& aChain);
	
	//=====================================
	// function: FindChains
	// purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::FindChains(con
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 173-175</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 403-405[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLS2.Initialize(aLSG);
	for (j=0; aItLS2.More(); aItLS2.Next(
	if (j>i) {</code></td>
          <td>	<code>aIt.Initialize(aLP);
	for (iCnt=0; aIt.More(); aIt.Next(),
	if (myNbPntsMax) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 109-124</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 264-278[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	const TopTools_IndexedDataMapOfShapeL
	//modified by NIZNHY-PKV Tue Mar 13 12:
	//-------------------------------------
	protected:
	Standard_EXPORT
	void PerformShapesToWork() ;
	
	Standard_EXPORT
	void FillVertices() ;
	
	Standard_EXPORT
	void FillEdges() ;
	
	Standard_EXPORT
	void FillWires() ;</code></td>
          <td>	<code>Standard_EXPORT
	const TopoDS_Shape &Result();
	
	protected:
	Standard_EXPORT
	void Intersect() ;
	
	Standard_EXPORT
	void PerformVV() ;
	
	Standard_EXPORT
	void PerformVE() ;
	
	Standard_EXPORT
	void PerformEE() ;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 119-123</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.cxx: line 94-98[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aOr=aF.Orientation();
	myErrorStatus=12; // unallowed orient
	return;
	}</code></td>
          <td>	<code>aType=myShape.ShapeType();
	myErrorStatus=12;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 248-253</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 683-688[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>aExp.Init (aZ, TopAbs_FACE);
	if (aExp.More()) {
	aF=*((TopoDS_Face*)&aExp.Current());
	}
	//
	iErr=PntInFace(aF, aPx, aP2Dx);</code></td>
          <td>	<code>aIt.Initialize(aE);
	if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}
	//
	aPD=BRep_Tool::Pnt(aVD);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.hxx: line 66-80</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 61-75[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>protected:
	Standard_EXPORT
	void DetectVertices() ;
	
	Standard_EXPORT
	void DetectEdges() ;
	
	Standard_EXPORT
	void DetectFaces() ;
	
	Standard_EXPORT
	void DetectShapes(const TopAbs_ShapeE
	
	Standard_EXPORT
	void DetectSolids() ;</code></td>
          <td>	<code>protected:
	Standard_EXPORT
	void DetectVertices() ;
	
	Standard_EXPORT
	void DetectEdges() ;
	
	Standard_EXPORT
	void DetectFaces() ;
	
	Standard_EXPORT
	void DetectShapes(const TopAbs_ShapeE
	
	Standard_EXPORT
	void EdgePassKey(const TopoDS_Edge& a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 552-558</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 605-611[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Pnt aP, aP1, aP2;
	//
	aLP.Clear();
	//
	aTRF=BRep_Tool::Triangulation(aF, aLo
	if (aTRF.IsNull()) {
	if (!GEOMAlgo_AlgoTools::BuildTriangu</code></td>
          <td>	<code>myErrorStatus=0;
	//
	aLP.Clear();
	//
	aTRF=BRep_Tool::Triangulation(aF, aLo
	if (aTRF.IsNull()) {
	if (!BuildTriangulation(aF)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 350-351</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 352-353[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>CollisionInfo info = {i, j, tolerance
	myCollisionInfos[i].push_back(std::ma</code></td>
          <td>	<code>CollisionInfo info_j = {j, i, toleran
	myCollisionInfos[j].push_back(std::ma</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1058-1061</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 305-309[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	
	for (; aItLS.More(); aItLS.Next()) {
	const TopoDS_Shape &aSWhat = aItLS.Va
	</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	// Mark sub-shapes as removed.
	for (; anIter.More(); anIter.Next())
	const TopoDS_Shape &aSubShape = anIte</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 231-239</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 288-293[29]</strong></td>
        </tr>
        <tr>
          <td>	<code>set<T>(key, std::make_shared<T>(data)
	}
	
	
	/** data must be the smart pointer ty
	* NOTE: do not make a shared_ptr from
	* by default data is NOT serializable
	*/
	template <typename T, typename Ptr =</code></td>
          <td>	<code>myProperties.emplace(key, std::move(p
	}
	
	/// if the key existed, erase first
	template <typename T, typename Ptr =
	void setSerializable(const std::strin
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 221-228</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 206-213[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>CommandLineProcessor = {
	"className": "PPP::CommandLineProcess
	"doc": "run command line on each item
	"commandLinePattern": {
	"type": "string",
	"value": "echo {}",
	"doc": "C++20 or python format, 1st a
	},</code></td>
          <td>	<code>GeometryPropertyBuilder = {
	"className": "Geom::GeometryPropertyB
	"doc": "build meta data for the solid
	"output": {
	"type": "filename",
	"value": "shape_properties.json",
	"doc": "this may used as meta data su
	},</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 213-216</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 136-139[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListOfShape aLVSD;
	//
	aIt.Initialize(aLI);
	for (j=0; aIt.More(); aIt.Next(), ++j</code></td>
          <td>	<code>aShape=myShape;
	//
	aIt1.Initialize(myShape);
	for (aNbS=0; aIt1.More(); aIt1.Next()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 266-268</strong></td>
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 45-47[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (const auto& p : metadata)
	{
	gpMap.insert_or_assign(p["uniqueId"].</code></td>
          <td>	<code>for (const auto& p : j)
	{
	gpMap.insert_or_assign(p["uniqueId"].</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 111-114</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 131-134[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>d.set<B>("B", std::make_shared<B>(len
	auto b = d.get<B>("B"); // second tem
	// std::cout<< "size of std container
	REQUIRE(b->size() == length);</code></td>
          <td>	<code>d.emplace<B>("B", std::move(b));
	auto bp = d.extract<B>("B"); // secon
	// std::cout<< "size of std container
	REQUIRE(bp->size() == length);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Algo.cxx: line 36-51</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeSolid.cxx: line 39-55[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus(1),
	myWarningStatus(0),
	myComputeInternalShapes(Standard_True
	{}
	//=====================================
	// function: ~
	// purpose:
	//=====================================
	GEOMAlgo_Algo::~GEOMAlgo_Algo()
	{
	}
	//=====================================
	// function: CheckData
	// purpose:
	//=====================================
	void GEOMAlgo_Algo::CheckData()
	</code></td>
          <td>	<code>GEOMAlgo_Algo(),
	myRank(0),
	myDSFiller(NULL)
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeSolid::~GEOMAlgo_ShapeSol
	{
	}
	//=====================================
	//function : SetFiller
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeSolid::SetFiller(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 25-32</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 32-40[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<Processor> myTargetPr
	
	public:
	CouplingMatrixBuilder()
	{
	myCharacteristics["coupled"] = false;
	myCharacteristics["indexPattern"] = I
	myCharacteristics["producedProperties
	</code></td>
          <td>	<code>std::shared_ptr<MapType<ItemHashType,
	
	public:
	/// consider: disable copy but enable
	GeometryProcessor()
	{
	myCharacteristics["modified"] = false
	myCharacteristics["indexPattern"] = I
	myCharacteristics["indexDimension"] =</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 131-136</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 222-227[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>pattern = "tessellationError"
	flist = glob.glob(case_folder + "dump
	
	for f in flist:
	print(f)
	s = load_shape(f)</code></td>
          <td>	<code>pattern = "relatedShape"
	flist = glob.glob(case_folder + "dump
	
	for f in flist:
	print(f)
	document_name = "Unnamed"</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 91-92</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 94-95[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aCylinder7 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl</code></td>
          <td>	<code>TopoDS_Shape aCylinder8 = BRepPrimAPI
	REQUIRE(CollisionDetector::detectColl</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.hxx: line 27-52</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.hxx: line 28-49[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_GlueAnalyser_HeaderFi
	#define _GEOMAlgo_GlueAnalyser_HeaderFi
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ListOfCoupleOfShapes
	#include <TopTools_ListOfShape.hxx>
	#include <GEOMAlgo_Gluer.hxx>
	#include <Standard_Boolean.hxx>
	#include <TopAbs_ShapeEnum.hxx>
	
	//=====================================
	//function : GEOMAlgo_GlueAnalyser
	//purpose :
	//=====================================
	class GEOMAlgo_GlueAnalyser : public GE
	{
	public:
	Standard_EXPORT
	GEOMAlgo_GlueAnalyser();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_GlueAnalyser();
	
	Standard_EXPORT
	virtual void Perform() ;</code></td>
          <td>	<code>#ifndef _GEOMAlgo_ShellSolid_HeaderFile
	#define _GEOMAlgo_ShellSolid_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <GEOMAlgo_ShapeSolid.hxx>
	
	//=====================================
	//class : GEOMAlgo_ShellSolid
	//purpose :
	//=====================================
	class GEOMAlgo_ShellSolid : public GEOM
	{
	public:
	Standard_EXPORT
	GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_ShellSolid();
	
	Standard_EXPORT
	virtual void Perform() ;
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 627-632</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 97-101[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer GEOMAlgo_AlgoTools::Fi
	(const TopoDS_Shape& aE1,
	const TopTools_ListOfShape& aLE,
	const Standard_Real aTol,
	TopTools_ListOfShape& aLESD,
	const Handle(IntTools_Context)& aCtx)</code></td>
          <td>	<code>static Standard_Integer FindSDShapes(
	const TopTools_ListOfShape& aLE,
	const Standard_Real aTol,
	TopTools_ListOfShape& aLESD,
	const Handle(IntTools_Context)& aCtx)
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 347-354</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 244-249[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>myImages.Bind(aVF, aLVSD);
	}// for (i=1; i<=aNbV; ++i) {
	//------------------------------
	//
	// Make new vertices
	aMV.Clear();
	aItIm.Initialize(myImages);
	for (; aItIm.More(); aItIm.Next()) {</code></td>
          <td>	<code>aMIPC.Add(aIP);
	}
	//
	aMIP.Clear();
	aIt1.Initialize(aMIP1);
	for(; aIt1.More(); aIt1.Next()) {
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 241-248</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 216-223[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aSSB.PerformWithFiller(*myDSFiller);
	iErr=aSSB.HasErrors();
	if (iErr) {
	myErrorStatus=15;
	return;
	}
	//
	const TopTools_DataMapOfShapeListOfSh</code></td>
          <td>	<code>aSB.Perform();
	iErr=aSB.HasErrors();
	if (iErr) {
	myErrorStatus=20; // SolidBuilder fai
	return;
	}
	//
	const TopTools_ListOfShape& aLSR=aSB.</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 662-664</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 118-121[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aKCE=aInfoE.KindOfClosed();
	aKSE=aInfoE.KindOfShape();
	if (aKNE==GEOMAlgo_KN_CIRCLE && aKCE=
	</code></td>
          <td>	<code>aCT=aGAC.GetType();
	//
	aST=myGAS.GetType();
	if (aCT==GeomAbs_Line && aST==GeomAbs</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 134-140</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 229-233[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>myLSON.Clear();
	myLSOUT.Clear();
	//
	// 3. fill states for solids
	TopExp::MapShapes(myS2, TopAbs_SOLID,
	//
	aNbS=aMS.Extent();</code></td>
          <td>	<code>aOr=aF.Orientation();
	//
	aM.Clear();
	TopExp::MapShapes(myShape, myShapeTyp
	aNb=aM.Extent();
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 515-520</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 580-585[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();</code></td>
          <td>	<code>aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 205-209</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 209-213[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>PointProperties(aComp2, aG2);
	}
	else if (iDim == 1) {
	BRepGProp::LinearProperties(theShape1
	BRepGProp::LinearProperties(aComp2, a</code></td>
          <td>	<code>BRepGProp::LinearProperties(aComp2, a
	}
	else if (iDim == 2) {
	BRepGProp::SurfaceProperties(theShape
	BRepGProp::SurfaceProperties(aComp2,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 491-496</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 605-608[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType = aS.ShapeType();
	switch (aType)
	{
	case TopAbs_EDGE:
	{
	const TopoDS_Edge& aE2 = TopoDS::Edge</code></td>
          <td>	<code>aType=aS.ShapeType();
	switch(aType) {
	case TopAbs_EDGE: {
	const TopoDS_Edge& aE=TopoDS::Edge(aS
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 334-341</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 54-61    [28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& theS2) ;
	
	Standard_EXPORT
	Standard_Boolean CheckCoincidence(con
	const TopoDS_Shape& theS2);
	
	Standard_EXPORT
	Standard_Integer CheckGProps(const To</code></td>
          <td>	<code>GeomExport std::map<std::string, int>
	
	/// based on axis-aligned boundbox ma
	GeomExport Standard_Boolean isCoincid
	
	/// two-step unifying: first unify ed
	/// deprecated: use glueFaces() inste
	GeomExport TopoDS_Shape unifyFaces(co</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 74-96</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 158-180[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>};
	
	//=====================================
	//function : GEOMAlgo_ShellSolidBuilder
	//purpose :
	//=====================================
	GEOMAlgo_ShellSolidBuilder::GEOMAlgo_Sh
	:
	BOPAlgo_Builder()
	{
	}
	//=====================================
	//function : ~GEOMAlgo_ShellSolidBuilde
	//purpose :
	//=====================================
	GEOMAlgo_ShellSolidBuilder::~GEOMAlgo_S
	{
	}
	//=====================================
	//function : PerformInternal
	//purpose :
	//=====================================
	void GEOMAlgo_ShellSolidBuilder::Perfor</code></td>
          <td>	<code>}
	///////////////////////////////////////
	//=====================================
	//function : GEOMAlgo_ShellSolid
	//purpose :
	//=====================================
	GEOMAlgo_ShellSolid::GEOMAlgo_ShellSoli
	:
	GEOMAlgo_ShapeSolid()
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShellSolid::~GEOMAlgo_ShellSol
	{
	}
	//=====================================
	// function:
	// purpose:
	//=====================================
	void GEOMAlgo_ShellSolid::Perform()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 85-94</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 577-586[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::FindChains(aMCV,
	}
	//=====================================
	// function: FindChains
	// purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::FindChains(con
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	{
	Standard_Integer i, j, aNbCV, aNbV;</code></td>
          <td>	<code>aS->D0(aU, aV, aP3D);
	}
	//=====================================
	//function : PointOnFace
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::PointOnFace(co
	gp_Pnt& aP3D)
	{
	Standard_Real aU, aV, aUMin, aUMax, a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 360-363</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 728-731[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	if (aKNE==GEOMAlgo_KN_CIRCLE) {
	aKN=GEOMAlgo_KN_DISKCIRCLE;</code></td>
          <td>	<code>const TopTools_ListOfShape& aLSx=aMFR
	aNbSx=aLSx.Extent();
	if (aNbSx==2) {
	bFound=!bFound;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 278-278</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 12-14[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>######################### post proces
	
	</code></td>
          <td>	<code>import unittest
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 264-265</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 296-297[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>LOG_F(ERROR, "general fuse has error
	itemName(i).c_str(), j, itemName(j).c</code></td>
          <td>	<code>LOG_F(INFO, "weak interference fixed
	itemName(i).c_str(), j, itemName(j).c</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 13-14</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 430-431[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Real xmin, ymin, zmin, xmax,
	b.Get(xmin, ymin, zmin, xmax, ymax, z</code></td>
          <td>	<code>Standard_Real oXmin, oYmin, oZmin, oX
	thisBox.Get(tXmin, tYmin, tZmin, tXma</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeSolid.cxx: line 39-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Algo.cxx: line 36-51[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_Algo(),
	myRank(0),
	myDSFiller(NULL)
	{
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeSolid::~GEOMAlgo_ShapeSol
	{
	}
	//=====================================
	//function : SetFiller
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeSolid::SetFiller(con</code></td>
          <td>	<code>myErrorStatus(1),
	myWarningStatus(0),
	myComputeInternalShapes(Standard_True
	{}
	//=====================================
	// function: ~
	// purpose:
	//=====================================
	GEOMAlgo_Algo::~GEOMAlgo_Algo()
	{
	}
	//=====================================
	// function: CheckData
	// purpose:
	//=====================================
	void GEOMAlgo_Algo::CheckData()
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 325-335</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeSolid.cxx: line 65-75[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>pSS=NULL;
	//
	switch (myShapeType) {
	case TopAbs_VERTEX:
	pSS=&aVXS;
	break;
	case TopAbs_EDGE:
	pSS=&aWRS;
	break;
	case TopAbs_FACE:
	pSS=&aSHS;</code></td>
          <td>	<code>const TopTools_ListOfShape *pL;
	//
	switch (aState) {
	case TopAbs_IN:
	pL=&myLSIN;
	break;
	case TopAbs_OUT:
	pL=&myLSOUT;
	break;
	case TopAbs_ON:
	pL=&myLSON;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UniqueIdValidator.cpp: line 45-47</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 266-268[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (const auto& p : j)
	{
	gpMap.insert_or_assign(p["uniqueId"].</code></td>
          <td>	<code>for (const auto& p : metadata)
	{
	gpMap.insert_or_assign(p["uniqueId"].</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 116-121</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 131-136[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>pattern = "bndboxOriginal"
	flist = glob.glob(case_folder + "dump
	
	for f in flist:
	print(f)
	f1 = f.replace("Original", "Changed")</code></td>
          <td>	<code>pattern = "tessellationError"
	flist = glob.glob(case_folder + "dump
	
	for f in flist:
	print(f)
	s = load_shape(f)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 173-177</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.hxx: line 54-59[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Handle(IntTools_Context)& theCt
	Standard_EXPORT
	static Standard_Integer BuildPCurveFo
	const TopoDS_Edge& aEnew,
	const TopoDS_Face& aF,
	</code></td>
          <td>	<code>static Standard_Boolean IsAnalytic(co
	
	Standard_EXPORT
	static Standard_Boolean IsCoaxial(con
	const gp_Pnt& aP2,
	const gp_Cylinder& aCyl,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 303-309</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1149-1154[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();
	aType==TopAbs_FACE) {</code></td>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 87-88</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 98-99[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>anAxis.SetLocation(gp_Pnt(0.0, 0.0, H
	TopoDS_Shape aCylinder6 = BRepPrimAPI</code></td>
          <td>	<code>anotherAxis.SetLocation(gp_Pnt(0.0, 0
	TopoDS_Shape aCylinder9 = BRepPrimAPI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 174-178</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 331-334[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>bOk=myContext->IsValidPointForFace(aP
	}
	//
	else if (aType1==TopAbs_SOLID) {
	const TopoDS_Solid& aZ1=*((TopoDS_Sol</code></td>
          <td>	<code>FacePassKey(aF, aPKF);
	}
	else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1292-1296</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 75-79[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp_Explorer anExp(aSubShape, aBou
	Standard_Integer j;
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aSubSubShape = an</code></td>
          <td>	<code>TopoDS_Iterator anIt(theS);
	TopTools_MapOfShape aMapInc;
	
	for(; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aS1x = anIt.Value</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 335-337</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 172-174[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>else { // SD vertices founded [ aMIPC
	aIt1.Initialize(aMIPC);
	for(j=0; aIt1.More(); aIt1.Next(), ++</code></td>
          <td>	<code>for (i=0; aItLS1.More(); aItLS1.Next(
	aItLS2.Initialize(aLSG);
	for (j=0; aItLS2.More(); aItLS2.Next(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 174-175</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 120-122[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; Exp_aWhere.More(); Exp_aWhere.
	if (!map_aWhere.Add(Exp_aWhere.Curren
	</code></td>
          <td>	<code>for (; it.More(); it.Next())
	{
	if (!aChecker.IsValid(it.Value()))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 254-262</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 795-802[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_FinderShapeOn::Find()
	{
	Standard_Integer i, aNb;
	Standard_Boolean bICS;
	TopTools_IndexedMapOfShape aM;
	//
	TopExp::MapShapes(myArg2, myShapeType
	//
	aNb=aM.Extent();</code></td>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK)
	{
	Standard_Integer i, aNbE;
	TopTools_ListOfShape aLE;
	TopTools_IndexedMapOfShape aME;
	//
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	aNbE=aME.Extent();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 311-316</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 318-323[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillImages(const TopoDS_Shape &t
	const Standard_Boolean IsWhere);
	
	void FillImgSimple(const TopoDS_Shape
	const TopAbs_ShapeEnum theSubShapeTyp
	const Standard_Boolean IsWhere);</code></td>
          <td>	<code>void FillImgComplex(const TopoDS_Shap
	const Standard_Boolean IsWhere);
	
	void FillImgComplex(const TopoDS_Shap
	const TopAbs_ShapeEnum theSubShapeTyp
	const Standard_Boolean IsWhere);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 113-120</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 183-190[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Real aT,gp_Pnt& aP3D)
	
	Standard_EXPORT
	static void PointOnFace(const TopoDS_
	gp_Pnt& aP3D) ;
	
	Standard_EXPORT
	static void PointOnFace(const TopoDS_</code></td>
          <td>	<code>GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void FindChains(const GEOMAlgo
	GEOMAlgo_IndexedDataMapOfShapeIndexed
	
	Standard_EXPORT
	static void CopyShape(const TopoDS_Sh</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 32-40</strong></td>
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 25-32[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<MapType<ItemHashType,
	
	public:
	/// consider: disable copy but enable
	GeometryProcessor()
	{
	myCharacteristics["modified"] = false
	myCharacteristics["indexPattern"] = I
	myCharacteristics["indexDimension"] =</code></td>
          <td>	<code>std::shared_ptr<Processor> myTargetPr
	
	public:
	CouplingMatrixBuilder()
	{
	myCharacteristics["coupled"] = false;
	myCharacteristics["indexPattern"] = I
	myCharacteristics["producedProperties
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 98-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 128-139[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Config PipelineController::conf
	{
	return myConfig;
	}
	
	void PipelineController::setConfig(co
	{
	myConfig = config;
	}
	
	
	</code></td>
          <td>	<code>Standard_Boolean GEOMAlgo_GetInPlace::I
	{
	return myFound;
	}
	//=====================================
	//function : SetShapeWhere
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::SetShapeWhere
	{
	myShapeWhere=theShape;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 120-122</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 174-175[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; it.More(); it.Next())
	{
	if (!aChecker.IsValid(it.Value()))</code></td>
          <td>	<code>for (; Exp_aWhere.More(); Exp_aWhere.
	if (!map_aWhere.Add(Exp_aWhere.Curren
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 541-546</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 663-667[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_BSPL
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	//
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aInfo.SetKindOfName(GEOMAlgo_KN_SEGME
	aGAC.D0(aT1, aP1);</code></td>
          <td>	<code>aInfo.SetKindOfShape(GEOMAlgo_KS_ELLI
	aInfo.SetLocation(aP);
	aInfo.SetPosition(aAx2);
	aInfo.SetRadius1(aR1);
	aInfo.SetRadius2(aR2);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 107-113</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 113-119[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a</code></td>
          <td>	<code>void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a
	
	Standard_EXPORT
	void FillDetails(const TopoDS_Face& a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 101-102</strong></td>
        <td style="text-align:center"><strong>src/PPP/ParallelAccessorTest.cpp: line 53-53[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::shared_ptr<ParallelAccessor> pa
	std::make_shared<AsynchronousDispatch</code></td>
          <td>	<code>pa = std::make_shared<AsynchronousDis
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeSolid.cxx: line 65-75</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 325-335[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape *pL;
	//
	switch (aState) {
	case TopAbs_IN:
	pL=&myLSIN;
	break;
	case TopAbs_OUT:
	pL=&myLSOUT;
	break;
	case TopAbs_ON:
	pL=&myLSON;</code></td>
          <td>	<code>pSS=NULL;
	//
	switch (myShapeType) {
	case TopAbs_VERTEX:
	pSS=&aVXS;
	break;
	case TopAbs_EDGE:
	pSS=&aWRS;
	break;
	case TopAbs_FACE:
	pSS=&aSHS;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfQuad.cxx: line 51-60</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 127-136[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : SetCorners
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfQuad::SetCorners(cons
	const gp_Pnt &theTopRightPoint,
	const gp_Pnt &theBottomLeftPoint,
	const gp_Pnt &theBottomRightPoint)
	{</code></td>
          <td>	<code>}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes
	const TopoDS_Shape& aS2,
	const TopoDS_Shape& aS3,
	const TopoDS_Shape& aS4)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 199-202</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 243-246[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (j.contains("name"))
	{
	j.at("name").get_to(p.name);
	j.at("density").get_to(p.density);</code></td>
          <td>	<code>inline void from_json(const json& j,
	{
	j.at("volume").get_to(p.volume);
	j.at("area").get_to(p.area);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 97-104</strong></td>
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 75-82[28]</strong></td>
        </tr>
        <tr>
          <td>	<code># todo: face count needs to be furthe
	
	def test(self):
	self.validate()
	
	
	class StrongInterferenceTest(GeomTestBa
	def build_geometry(self, doc):</code></td>
          <td>	<code># 2 cubes shares 1 face, total 11 fac
	
	def test(self):
	self.validate()
	
	
	class AlignedBoxesTest(GeomTestBase):
	def build_geometry(self, doc):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 255-268</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 130-143[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillSolidsOn(myShapeWhere);
	if (myErrorStatus) {
	return;
	}
	//
	PerformZF();
	if (myErrorStatus) {
	return;
	}
	//
	PerformZZ();
	if (myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>InnerTolerance();
	if (myErrorStatus) {
	return;
	}
	//
	DetectVertices();
	if (myErrorStatus) {
	return;
	}
	//
	DetectEdges();
	if (myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 94-96</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 334-341[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport Standard_Real tolerance(co
	GeomExport Standard_Real distance(con
	GeomExport UniqueIdType uniqueId(cons
	
	
	
	
	</code></td>
          <td>	<code>const TopoDS_Shape& theS2) ;
	
	Standard_EXPORT
	Standard_Boolean CheckCoincidence(con
	const TopoDS_Shape& theS2);
	
	Standard_EXPORT
	Standard_Integer CheckGProps(const To</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 409-412</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 491-496[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=aS.ShapeType();
	switch (aType) {
	case TopAbs_VERTEX: {
	const TopoDS_Vertex& aVx=TopoDS::Vert
	
	</code></td>
          <td>	<code>aType = aS.ShapeType();
	switch (aType)
	{
	case TopAbs_EDGE:
	{
	const TopoDS_Edge& aE2 = TopoDS::Edge</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 235-240</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 805-810[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS2=aCS.Shape2();
	if (!myOriginsDetected.IsBound(aS2))
	myErrorStatus=30;
	return;
	}
	const TopoDS_Shape& aSkey2=myOriginsD</code></td>
          <td>	<code>const TopoDS_Shape& aE=aME(i);
	if (!myOrigins.IsBound(aE)) {
	myErrorStatus=102;
	return;
	}
	const TopoDS_Shape& aER=myOrigins.Fin</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 559-565</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 568-572[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPCheck.SetShape1(BOPCopy);
	
	// BOPCheck.SetShape1(shape);
	BOPCheck.ArgumentTypeMode() = true;
	BOPCheck.SelfInterMode() = true;
	BOPCheck.SmallEdgeMode() = true;
	BOPCheck.RebuildFaceMode() = true;</code></td>
          <td>	<code>BOPCheck.SetRunParallel(false);
	BOPCheck.TangentMode() = true;
	BOPCheck.MergeVertexMode() = true;
	BOPCheck.MergeEdgeMode() = true;
	BOPCheck.CurveOnSurfaceMode() = false
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 262-265</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 164-168[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//else { // SD vertices founded [ aMI
	aIt1.Initialize(aMIPC);
	for(j=0; aIt1.More(); aIt1.Next(), ++
	</code></td>
          <td>	<code>}// if (!aNbSG) {
	//
	// 1. Make pairs
	aItDMSLS.Initialize(myShapesToGlue);
	for (k=0; aItDMSLS.More(); aItDMSLS.N</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 164-168</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 262-265[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>}// if (!aNbSG) {
	//
	// 1. Make pairs
	aItDMSLS.Initialize(myShapesToGlue);
	for (k=0; aItDMSLS.More(); aItDMSLS.N</code></td>
          <td>	<code>}
	//else { // SD vertices founded [ aMI
	aIt1.Initialize(aMIPC);
	for(j=0; aIt1.More(); aIt1.Next(), ++
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 75-82</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 97-104[28]</strong></td>
        </tr>
        <tr>
          <td>	<code># 2 cubes shares 1 face, total 11 fac
	
	def test(self):
	self.validate()
	
	
	class AlignedBoxesTest(GeomTestBase):
	def build_geometry(self, doc):</code></td>
          <td>	<code># todo: face count needs to be furthe
	
	def test(self):
	self.validate()
	
	
	class StrongInterferenceTest(GeomTestBa
	def build_geometry(self, doc):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 173-181</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 467-475[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myShape.IsNull()) {
	myErrorStatus = 10;
	return;
	}
	
	if (mySubShapes.IsEmpty()) {
	myWarningStatus = 10;
	return;
	}</code></td>
          <td>	<code>if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	if (myShape.IsNull()) {
	myErrorStatus=11; // myShape=NULL
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 808-810</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 248-250[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aExp.Init(aSd, TopAbs_FACE);
	for (j=0; aExp.More(); aExp.Next(), +
	const TopoDS_Face& aF=*((TopoDS_Face*</code></td>
          <td>	<code>aItLS.Initialize(aLSG);
	for (i=0; aItLS.More(); aItLS.Next(),
	const TopoDS_Shape& aSG=aItLS.Value()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 106-118</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 105-117[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Integer aId2)
	{
	TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	SetIds(aLI);
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const S</code></td>
          <td>	<code>const TopoDS_Shape& aS2)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);
	SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.hxx: line 54-59</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 173-177[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>static Standard_Boolean IsAnalytic(co
	
	Standard_EXPORT
	static Standard_Boolean IsCoaxial(con
	const gp_Pnt& aP2,
	const gp_Cylinder& aCyl,</code></td>
          <td>	<code>const Handle(IntTools_Context)& theCt
	Standard_EXPORT
	static Standard_Integer BuildPCurveFo
	const TopoDS_Edge& aEnew,
	const TopoDS_Face& aF,
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 253-254</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 264-265[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>LOG_F(ERROR, "Error during merge and
	itemName(i).c_str(), j, itemName(j).c</code></td>
          <td>	<code>LOG_F(ERROR, "general fuse has error
	itemName(i).c_str(), j, itemName(j).c</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 102-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 105-106    [28]</strong></td>
        </tr>
        <tr>
          <td>	<code>myProcessors.push_back(std::make_shar
	// setConfig()
	myProcessors.push_back(std::make_shar</code></td>
          <td>	<code>myProcessors.push_back(std::make_shar
	myProcessors.push_back(std::make_shar
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 519-524</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 150-155[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Face& aF2 = TopoDS::Face
	GeomAPI_ProjectPointOnSurf& aProj = a
	//
	aProj.Perform(aP1);
	bIsDone = aProj.IsDone();
	if (!bIsDone) {</code></td>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	//
	GeomAPI_ProjectPointOnCurve& aPPC=myC
	aPPC.Perform(aP2);
	aNbPoints=aPPC.NbPoints();
	if (aNbPoints) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 70-82</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 65-77[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetState(const GEOMAlgo_State aS
	
	Standard_EXPORT
	void SetNbPntsMin(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer NbPntsMin() const;
	
	Standard_EXPORT
	void SetNbPntsMax(const Standard_Inte
	
	Standard_EXPORT
	Standard_Integer NbPntsMax() const;</code></td>
          <td>	<code>virtual ~GEOMAlgo_Gluer();
	
	Standard_EXPORT
	void SetCheckGeometry(const Standard_
	
	Standard_EXPORT
	Standard_Boolean CheckGeometry() cons
	
	Standard_EXPORT
	void SetKeepNonSolids(const Standard_
	
	Standard_EXPORT
	Standard_Boolean KeepNonSolids() cons</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 112-115</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 126-130[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>#######################################
	
	def checkBoundboxError():
	# boundbox change check
	</code></td>
          <td>	<code>#######################################
	
	
	def checkTessellationError():
	#</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 795-802</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 254-262[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_PassKeyShape& aPK)
	{
	Standard_Integer i, aNbE;
	TopTools_ListOfShape aLE;
	TopTools_IndexedMapOfShape aME;
	//
	TopExp::MapShapes(aF, TopAbs_EDGE, aM
	aNbE=aME.Extent();
	</code></td>
          <td>	<code>void GEOMAlgo_FinderShapeOn::Find()
	{
	Standard_Integer i, aNb;
	Standard_Boolean bICS;
	TopTools_IndexedMapOfShape aM;
	//
	TopExp::MapShapes(myArg2, myShapeType
	//
	aNb=aM.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 592-595</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 633-636[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);</code></td>
          <td>	<code>aGAC.D0(aT1, aP1);
	aGAC.D0(aT2, aP2);
	aInfo.SetPnt1(aP1);
	aInfo.SetPnt2(aP2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 864-872</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 299-307[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GetCount(const TopoDS_Shape& aS,
	Standard_Integer& iCnt)
	{
	TopoDS_Iterator aIt;
	TopAbs_ShapeEnum aTS;
	//
	aTS=aS.ShapeType();
	//</code></td>
          <td>	<code>void GEOMAlgo_Gluer2::MapBRepShapes(con
	TopTools_MapOfShape& aM)
	{
	//Standard_Boolean bHasBRep;
	TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 91-95</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 346-351[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>os.remove(outfile)
	App.newDocument(document_name)
	doc = App.getDocument(document_name)
	
	__objs__ = self.build_geometry(doc)
	</code></td>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	//
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 588-591</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 899-902[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRepTools::UVBounds(aF, aUMin, aUMax,
	//
	aU=IntTools_Tools::IntermediatePoint(
	aV=IntTools_Tools::IntermediatePoint(</code></td>
          <td>	<code>TopExp::Vertices(aEx, aV1, aV2);
	//
	aT1=BRep_Tool::Parameter(aV1, aEx);
	aT2=BRep_Tool::Parameter(aV2, aEx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 198-205</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 71-78[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
          <td>	<code>if (myDSFiller==NULL) {
	myErrorStatus=10;
	return;
	}
	if(myDSFiller->HasErrors()) {
	myErrorStatus=11;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 600-603</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 630-633[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (anIter.Initialize(aModifSubShape
	const TopoDS_Shape aNewShape = orient
	</code></td>
          <td>	<code>for (; anIter.More(); anIter.Next())
	const TopoDS_Shape aNewShape = orient
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 162-164</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 260-262[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>tol = 0.0
	pieces, map = solids[0].generalFuse(s
	result_fragments = pieces.Solids</code></td>
          <td>	<code>tol = 0.0
	pieces, map = solids[0].generalFuse(s
	result_fragments = pieces.Solids</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Utilities.h: line 73-75</strong></td>
        <td style="text-align:center"><strong>src/PPP/Utilities.h: line 84-86    [28]</strong></td>
        </tr>
        <tr>
          <td>	<code>};
	
	template <class T, class... Args> typ</code></td>
          <td>	<code>}
	
	template <class T, class... Args> typ</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ParallelAccessorTest.cpp: line 57-57</strong></td>
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 101-102[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>pa = std::make_shared<ParallelAccesso
	</code></td>
          <td>	<code>std::shared_ptr<ParallelAccessor> pa
	std::make_shared<AsynchronousDispatch</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 684-687</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 924-927[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>Geom2dHatch_Hatcher& aHatcher=myConte
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax</code></td>
          <td>	<code>aFF.Orientation (TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFF);
	BRepTools::UVBounds(aFF, aUMin, aUMax</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 430-431</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 837-838[28]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Real oXmin, oYmin, oZmin, oX
	thisBox.Get(tXmin, tYmin, tZmin, tXma</code></td>
          <td>	<code>Standard_Real aXmin, aYmin, aZmin, aX
	B.Get(aXmin, aYmin, aZmin, aXmax, aYm</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 738-741</strong></td>
        <td style="text-align:center"><strong>src/PPP/Reader.h: line 35-37       [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->setValue<ShapeType>("my
	myOutputData->setItemCount(mySolids.s
	// emplace equal to the two step abov
	myOutputData->emplace("mySolids", std</code></td>
          <td>	<code>myOutputData = std::make_shared<DataO
	myOutputData->setItemCount(myFilePath
	myOutputData->emplace("myFilePaths",
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.hxx: line 42-50</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 61-68[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	void SetContext(const Handle(IntTools
	
	//! Returns cashed geometrical tools
	Standard_EXPORT
	const Handle(IntTools_Context)& Conte
	
	Standard_EXPORT
	void SetShape(const TopoDS_Shape& aS)</code></td>
          <td>	<code>Standard_EXPORT
	void SetClsf(const Handle(GEOMAlgo_Cl
	
	Standard_EXPORT
	const Handle(GEOMAlgo_Clsf)& Clsf() c
	
	Standard_EXPORT
	void SetShapeType(const TopAbs_ShapeE
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 172-177</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 186-193[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape box3 = BRepPrimAPI_MakeB
	REQUIRE(CollisionDetector::detectColl
	}
	
	SECTION("curved_surface_contact_tests
	{
	
	</code></td>
          <td>	<code>TopoDS_Shape s2 = BRepAlgoAPI_Cut(box
	
	REQUIRE(CollisionDetector::detectColl
	CollisionType::FaceContact); // conta
	}
	
	SECTION("boundbox_tests")
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 551-562</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 623-633[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Cylinder& aCyl)
	
	{
	Standard_Integer aNbV, aNbE, aNbCE, a</code></td>
          <td>	<code>}//if (aNbCE==2 && aNbSE==1) {
	}//if (aNbV==2 && aNbE==3) {
	}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Cone& aCone)
	{
	Standard_Integer aNbV, aNbE, aNbCE, a
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 521-521</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 522-522[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto b1 = BRepPrimAPI_MakeBox(gp_Pnt(</code></td>
          <td>	<code>auto b2 = BRepPrimAPI_MakeBox(gp_Pnt(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_2.cxx: line 75-79</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 84-88[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myHistShapes.Clear();
	//</code></td>
          <td>	<code>myGAS.Load(myS);
	aType=myGAS.GetType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 136-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1097-1100[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (j=1; j<=aNbV; ++j) {
	const TopoDS_Shape& aFx=aMV(j);
	ProcessBlock(aFx, aMCV, aProcessed, a
	</code></td>
          <td>	<code>for (i=1; i<=aNbS; ++i) {
	const TopoDS_Shape &aS = aMS(i);
	
	FillImgComplex(aS, IsWhere);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 78-93</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 74-89[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function :Clear
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::Clear()
	{
	myNbIds=0;
	mySum=0;
	myMap.Clear();
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const S</code></td>
          <td>	<code>}
	//=====================================
	//function :Clear
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::Clear()
	{
	myNbIds=0;
	mySum=0;
	myMap.Clear();
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1317-1322</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1338-1343[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapOfShape &aLastZoneBound =
	
	for (; anExp.More(); anExp.Next()) {
	aLastZoneBound.Add(anExp.Current());
	}
	} else {</code></td>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aMap
	
	for (; aMapIt.More(); aMapIt.Next())
	aZoneBounds.Add(aMapIt.Key());
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/setup.py: line 59-64</strong></td>
        <td style="text-align:center"><strong>src/python/setup.py: line 82-87    [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if platform.system == "Windows":
	ext_suffix = "pyd"
	elif platform.system == "Macos":
	ext_suffix = "dylib"
	else:
	ext_suffix = "so"</code></td>
          <td>	<code>if platform.system == "Windows":
	so_suffix = "dll"
	elif platform.system == "Macos":
	so_suffix = "dylib"
	else:
	so_suffix = "so"</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryTypes.h: line 251-253</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 215-218[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>j.at("edgeCount").get_to(p.edgeCount)
	j.at("centerOfMass").get_to(p.centerO
	}
	</code></td>
          <td>	<code>j.at("type").get_to(p.type);
	// j.at("data").get_to(p.data);
	j.at("flag").get_to(p.flag); // enum
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 263-268</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 324-329[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbS1=aMS1.Extent();
	aNbS2=aMS2.Extent();
	if (aNbS1!=aNbS2) {
	myErrorStatus=31;
	return;
	}</code></td>
          <td>	<code>const TopTools_ListOfShape& aLS=aItDM
	aNbS=aLS.Extent();
	if (aNbS!=2) {
	myErrorStatus=32;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 339-341</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 190-194[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>MapBRepShapes(myShapeWhere, aMS2);
	aNbS2=aMS2.Extent();
	for (j=1; j<=aNbS2; ++j) {
	
	</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::FindChains(aLCS,
	//
	// 3. myImagesToWork, myOriginsToWork
	aNbC=aMC.Extent();
	for (i=1; i<=aNbC; ++i) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 319-330</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 356-366[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	
	//=====================================
	//function : markRemoved
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::markRemoved(co
	{
	if (myMapRemoved.Add(theShape)) {
	// Check sub-shapes.
	TopoDS_Iterator anIter(theShape);</code></td>
          <td>	<code>}
	}
	
	//=====================================
	//function : markAncestorsModified
	//purpose :
	//=====================================
	void GEOMAlgo_Extractor::markAncestorsM
	{
	if (myMapShapeAnc.IsBound(theShape))
	TopTools_ListIteratorOfListOfShape an
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 154-156</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 168-170[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>d["filename"] = p.find("Part").attrib
	elif p.attrib["name"] == "Placement":
	d["translation"] = "" # Todo</code></td>
          <td>	<code>d["label"] = p.find("String").attrib[
	elif p.attrib["name"] == "Visibility"
	d["visible"] = p.find("Bool").attrib[</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 776-780</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 505-509[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSD1=aMS(i);
	//
	aMF.Clear();
	TopExp::MapShapes(aSD1, TopAbs_FACE,
	aNbF=aMF.Extent();</code></td>
          <td>	<code>const TopoDS_Shape& aSd=aM(i);
	aMF.Clear();
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	bIsConformState=Standard_False;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 216-221</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 231-236[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=aS.ShapeType();
	iType=(Standard_Integer)aType;
	//
	if (iType>iLimit) {
	aLSP.Append(aS);
	}</code></td>
          <td>	<code>aTypeX=aSX.ShapeType();
	iTypeX=(Standard_Integer)aTypeX;
	//
	if (iTypeX>iLimit) {
	aLSP.Append(aSX);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 128-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 457-470[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>return myEmptyInfo;
	}
	
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::CheckDat
	{
	myErrorStatus=0;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10;
	return;
	}</code></td>
          <td>	<code>myArg2=aSC;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::CheckData(
	{
	myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 424-428</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 539-543[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>void CollisionDetector::dealGeneralFu
	const std::vector<ItemIndexType> item
	{
	ItemIndexType it = 0;
	for (const auto& s : twoShapes)</code></td>
          <td>	<code>size_t CollisionDetector::shapeMatch(
	const std::vector<Standard_Real> vols
	{
	size_t matched_index = 0;
	for (size_t i = 0; i < shapes.size();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 492-496</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1016-1020[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	TopTools_ListOfShape aListEdges;
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Edge &anEdge = anExp.Cur</code></td>
          <td>	<code>TopTools_ListOfShape aLSx;
	TopTools_MapOfShape aMSx;
	
	for(; aIt.More(); aIt.Next()) {
	const TopoDS_Shape &aSubS = aIt.Value</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 742-755</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 717-731[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::CheckData()
	{
	myErrorStatus=0;
	//
	if (myShape.IsNull()) {
	myErrorStatus=5;
	return;
	}
	</code></td>
          <td>	<code>}
	}
	
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::CheckData
	{
	myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Reader.h: line 35-37</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 738-741[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData = std::make_shared<DataO
	myOutputData->setItemCount(myFilePath
	myOutputData->emplace("myFilePaths",
	</code></td>
          <td>	<code>myOutputData->setValue<ShapeType>("my
	myOutputData->setItemCount(mySolids.s
	// emplace equal to the two step abov
	myOutputData->emplace("mySolids", std</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 586-591</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 639-644[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfBounds(GEOMAlgo_KB_INF
	aInfo.SetKindOfName(GEOMAlgo_KN_LINE)
	}
	else {
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	aInfo.SetKindOfName(GEOMAlgo_KN_SEGME</code></td>
          <td>	<code>aInfo.SetKindOfClosed(GEOMAlgo_KC_CLO
	aInfo.SetKindOfName(GEOMAlgo_KN_CIRCL
	}
	else {
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT
	aInfo.SetKindOfName(GEOMAlgo_KN_ARCCI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 271-275</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 325-329[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(info["compsolids"] == 1);
	
	REQUIRE(countSubShapes(compSolid, Top
	REQUIRE(countSubShapes(compSolid, Top
	}</code></td>
          <td>	<code>fs::remove(tf); // after usage, clean
	
	REQUIRE(countSubShapes(readback, TopA
	REQUIRE(countSubShapes(readback, TopA
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 488-492</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 542-547[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if ( !aHistoryLabel.IsNull() )
	{
	Handle(TDataStd_IntegerArray) anInteg
	if (aHistoryLabel.FindAttribute(TData
	{
	</code></td>
          <td>	<code>void extractXCAFMetadata(const TDF_La
	{
	// getting material
	Handle(XCAFDoc_Material) MatAttr;
	if (label.FindAttribute(XCAFDoc_Mater
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1332-1335</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 254-257[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapOfShape &aZoneBounds = aB
	
	for (j = i + 1; j <= aNbZones; ++j) {
	if (aMapIndices.Contains(j)) {</code></td>
          <td>	<code>const gp_Dir& aDNi=aIFi.Position().Di
	//
	for (j=i+1; j<=aNbF; ++j) {
	if (aMp.Contains(j)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 457-470</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 128-142[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myArg2=aSC;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn::CheckData(
	{
	myErrorStatus=0;
	//
	if(mySurface.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	</code></td>
          <td>	<code>return myEmptyInfo;
	}
	
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::CheckDat
	{
	myErrorStatus=0;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 88-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 104-105[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto df = generateDumpName("dump_BOPC
	OccUtils::saveShape({item(i)}, df);</code></td>
          <td>	<code>auto df = generateDumpName("dump_smal
	OccUtils::saveShape({item(i)}, df);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 34-35</strong></td>
        <td style="text-align:center"><strong>src/PPP/Parameter.h: line 36-37    [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>p.doc = j["doc"].get<std::string>();
	if (j.contains("unit"))</code></td>
          <td>	<code>p.unit = j["unit"].get<std::string>()
	if (j.contains("range"))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.hxx: line 76-87</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.hxx: line 88-98[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>(const TopoDS_Shape &theWhere,
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac
	
	
	/**
	* \brief GetInPlaceByHistory method i
	* Returns Standard_True if something
	* list is not cleared at first.
	*/
	Standard_EXPORT static Standard_Boole
	(const Handle(GEOM_Function) &theWher</code></td>
          <td>	<code>const TopTools_IndexedMapOfShape &the
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac
	
	/**
	* \brief GetInPlaceMap method impleme
	* For each sub-shape ID in theWhat fi
	* sub-shape IDs in theWhere
	*/
	Standard_EXPORT static Standard_Boole
	(const Handle(GEOM_Function) &theWher
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 85-88</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 110-113[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::cout << "Step file writing error
	}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
          <td>	<code>return shape;
	}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 329-332</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 333-336[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType==TopAbs_FACE) {
	const TopoDS_Face& aF=*((TopoDS_Face*
	FacePassKey(aF, aPKF);
	}</code></td>
          <td>	<code>else if (aType==TopAbs_EDGE) {
	const TopoDS_Edge& aE=*((TopoDS_Edge*
	EdgePassKey(aE, aPKF);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 89-92</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 92-95    [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport bool floatEqual(double a,
	GeomExport GeometryProperty geometryP
	GeomExport Standard_Real area(const T
	GeomExport Standard_Real perimeter(co</code></td>
          <td>	<code>GeomExport Standard_Real perimeter(co
	GeomExport Standard_Real volume(const
	GeomExport Standard_Real tolerance(co
	GeomExport Standard_Real distance(con</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.hxx: line 95-109</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.hxx: line 100-114[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void MakeArgument1() ;
	
	Standard_EXPORT
	void MakeArgument2() ;
	
	Standard_EXPORT
	void Find() ;
	
	Standard_EXPORT
	void Find(const TopoDS_Shape& aS) ;</code></td>
          <td>	<code>protected:
	Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 74-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 78-93[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function :Clear
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::Clear()
	{
	myNbIds=0;
	mySum=0;
	myMap.Clear();
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes</code></td>
          <td>	<code>}
	//=====================================
	//function :Clear
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::Clear()
	{
	myNbIds=0;
	mySum=0;
	myMap.Clear();
	}
	//=====================================
	//function :SetIds
	//purpose :
	//=====================================
	void GEOMAlgo_PassKey::SetIds(const S</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 133-137</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 147-151[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>template <typename T> default_pointer
	{
	if (contains(key))
	{
	any an = myProperties[key].data;</code></td>
          <td>	<code>template <typename T, typename Ptr =
	{
	if (contains(key))
	{
	any an = myProperties[key].data;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphere.lxx: line 37-48</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphere.lxx: line 53-64[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline const gp_Pnt& GEOMAlgo_BndSphe
	{
	return myCenter;
	}
	//=====================================
	//function : SetRadius
	//purpose :
	//=====================================
	inline void GEOMAlgo_BndSphere::SetRa
	{
	myRadius=theR;
	}</code></td>
          <td>	<code>inline Standard_Real GEOMAlgo_BndSphe
	{
	return myRadius;
	}
	//=====================================
	//function : SetGap
	//purpose :
	//=====================================
	inline void GEOMAlgo_BndSphere::SetGa
	{
	myGap=theGap;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1401-1406</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 119-124[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	for (; anIt.More(); anIt.Next()) {
	const TopoDS_Shape &aSubShape = anIt.
	</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	
	for (; aItS1x.More(); aItS1x.Next())
	const TopoDS_Shape &aS1x = aItS1x.Val
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 302-307</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 806-810[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!myOriginsDetected.IsBound(aSS2))
	myErrorStatus=30;
	return;
	}
	//
	const TopoDS_Shape& aSkey=myOriginsDe</code></td>
          <td>	<code>if (!myOrigins.IsBound(aE)) {
	myErrorStatus=102;
	return;
	}
	const TopoDS_Shape& aER=myOrigins.Fin
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 94-98</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 162-167[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedDataMapOfShapeListOfS
	const Handle(IntTools_Context)& aCtx)
	Standard_EXPORT
	static Standard_Integer FindSDShapes(
	const TopTools_ListOfShape& aLE,
	</code></td>
          <td>	<code>const TopoDS_Edge& theEdge,
	const Handle(IntTools_Context)& theCt
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Face& theFSr,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 202-211</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 245-254[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>"doc": "whether disable/ suppress thi
	},
	}
	
	GeometryPropertyBuilder = {
	"className": "Geom::GeometryPropertyB
	"doc": "build meta data for the solid
	"output": {
	"type": "filename",
	"value": "shape_properties.json",</code></td>
          <td>	<code>"doc": " search criteria values depen
	},
	}
	
	CollisionDetector = {
	"className": "Geom::CollisionDetector
	"doc": "detect contact or collision,
	"tolerance": {
	"type": "quantity",
	"value": 0.001,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 542-547</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 488-492[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>void extractXCAFMetadata(const TDF_La
	{
	// getting material
	Handle(XCAFDoc_Material) MatAttr;
	if (label.FindAttribute(XCAFDoc_Mater
	{</code></td>
          <td>	<code>if ( !aHistoryLabel.IsNull() )
	{
	Handle(TDataStd_IntegerArray) anInteg
	if (aHistoryLabel.FindAttribute(TData
	{
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 190-194</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 325-327[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::FindChains(aLCS,
	//
	// 3. myImagesToWork, myOriginsToWork
	aNbC=aMC.Extent();
	for (i=1; i<=aNbC; ++i) {</code></td>
          <td>	<code>MapBRepShapes(myArgument, aMS1);
	aNbS1=aMS1.Extent();
	for (i=1; i<=aNbS1; ++i) {
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 420-423</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 176-179[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSx1=aLSx.First()
	const TopoDS_Shape& aSx2=aLSx.Last();
	aCS.SetShape1(aSx1);
	aCS.SetShape2(aSx2);</code></td>
          <td>	<code>const TopoDS_Shape& aSG1=aItLS1.Value
	const TopoDS_Shape& aSG2=aItLS2.Value
	aCS.SetShape1(aSG1);
	aCS.SetShape2(aSG2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 415-418</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 352-355[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aEE=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aEE)) {
	continue;
	}</code></td>
          <td>	<code>const TopoDS_Edge& aEx=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aEx)) {
	continue;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 547-552</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 768-774[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopoDS_Iterator aItC;
	//
	bRet=Standard_False;
	aItC.Initialize(aC);
	for (; aItC.More(); aItC.Next()) {
	</code></td>
          <td>	<code>Standard_Integer iCnt;
	TopoDS_Iterator aIt;
	//
	iCnt=0;
	//
	aIt.Initialize(aSd);
	for (; aIt.More(); aIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 104-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 88-89[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto df = generateDumpName("dump_smal
	OccUtils::saveShape({item(i)}, df);</code></td>
          <td>	<code>auto df = generateDumpName("dump_BOPC
	OccUtils::saveShape({item(i)}, df);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 97-97</strong></td>
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 98-98[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>a = [b1.XMin, b1.YMin, b1.ZMin, b1.XM</code></td>
          <td>	<code>b = [b2.XMin, b2.YMin, b2.ZMin, b2.XM</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 751-752</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 62-63[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace("myColorMap", s
	myOutputData->emplace("myMaterialMap"</code></td>
          <td>	<code>myOutputData->emplace("myGeometryProp
	myOutputData->emplace("myGeometryUniq</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/setup.py: line 68-69</strong></td>
        <td style="text-align:center"><strong>src/python/setup.py: line 87-89    [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>occt_include_dir = "/usr/include/openca
	ppp_include_dir = os.path.dirname(os.pa
	</code></td>
          <td>	<code>so_suffix = "so"
	
	app_output_path = os.path.dirname(os.</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 190-195</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 182-188[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>aHAB->SetValue(i, aBox);
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aBSB.Initialize(aHAB);
	</code></td>
          <td>	<code>aTreeFiller.Add(i, aBox);
	//
	aMIS.Add(i, aV);
	aMSB.Add(aV, aBox);
	}
	//
	aTreeFiller.Fill();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 53-53</strong></td>
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 54-54[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::vector<double> data1 = {221426.1</code></td>
          <td>	<code>std::vector<double> data2 = {221426.6</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 73-84</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 65-76[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_ClsfSurf::CheckData()
	{
	GeomAbs_SurfaceType aType;
	//
	myErrorStatus=0;
	//
	if(myS.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	myGAS.Load(myS);</code></td>
          <td>	<code>void GEOMAlgo_RemoverWebs::CheckData()
	{
	TopoDS_Iterator aIt;
	//
	myErrorStatus=0;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10;
	return;
	}
	//
	aIt.Initialize(myShape);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 626-628</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 120-123[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGAS.Load(aS);
	aType=aGAS.GetType();
	</code></td>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName(); // mb: sphe
	aKNF==GEOMAlgo_KN_TORUS) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/CMakeLists.txt: line 26-28</strong></td>
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 32-34[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>add_executable(OccBVHdemo "OccBVHdemo
	target_link_libraries(OccBVHdemo ${OC
	target_link_libraries(OccBVHdemo ${OC</code></td>
          <td>	<code>add_executable(UniqueIdValidator "Uniqu
	target_link_libraries(UniqueIdValidator
	install(TARGETS UniqueIdValidator</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryData.h: line 34-38</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryData.h: line 39-43[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (contains("myShapes"))
	{
	auto shapes = getConst<ItemContainerT
	size = shapes->size();
	}</code></td>
          <td>	<code>else if (contains("mySolids")) // als
	{
	auto shapes = getConst<ItemContainerT
	size = shapes->size();
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 95-99</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 562-566[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aProcessed
	//
	aNbCV=aMCV.Extent();
	for (i=1; i<=aNbCV; ++i) {
	const TopoDS_Shape& aF=aMCV.FindKey(i</code></td>
          <td>	<code>bIsConformState=Standard_False;
	//
	aNbF=aMF.Extent();
	for (j=1; j<=aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_imprint.py: line 95-101</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 99-105[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>def test(self):
	self.validate()
	
	
	class StackedCurvedTest(GeomTestBase):
	def build_geometry(self, doc):
	objs = [doc.addObject("Part::Box", "B</code></td>
          <td>	<code>def test(self):
	self.validate()
	
	
	class StrongInterferenceTest(GeomTestBa
	def build_geometry(self, doc):
	objs = solid_interference_maker(doc)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 366-370</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 334-338[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopTools_ListOfShape& aLF=aItIm
	aNbF=aLF.Extent();
	if (aNbF!=2) {
	continue;
	}</code></td>
          <td>	<code>const TopoDS_Shape& aSkey=aItDMSLS.Ke
	aType=aSkey.ShapeType();
	if (aType!=TopAbs_VERTEX) {
	continue;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 399-412</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 415-428[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>case TopAbs_VERTEX:
	DumpVertex();
	break;
	//
	case TopAbs_EDGE:
	DumpEdge();
	break;
	//
	case TopAbs_WIRE:
	DumpWire();
	break;
	//
	case TopAbs_FACE:
	DumpFace();</code></td>
          <td>	<code>case TopAbs_SHELL:
	DumpShell();
	break;
	//
	case TopAbs_SOLID:
	DumpSolid();
	break;
	//
	case TopAbs_COMPSOLID:
	DumpCompSolid();
	break;
	//
	case TopAbs_COMPOUND:
	DumpCompound();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 80-84</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 85-89    [27]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport bool isBndBoxOverlapped(co
	/** gap can control overlapping, near
	GeomExport bool isBndBoxOverlapped(co
	/** detect if two shapes taking up th
	GeomExport bool isBndBoxCoincident(co</code></td>
          <td>	<code>Standard_Real reltolerance = 1e-2);
	GeomExport bool isBndBoxCoincident(co
	Standard_Real reltolerance = 1e-2);
	
	GeomExport bool floatEqual(double a,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 422-428</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 622-628[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Geom_Surface) aS;
	GeomAdaptor_Surface aGAS;
	//
	aS=BRep_Tool::Surface(aF);
	aGAS.Load(aS);
	aType2=aGAS.GetType();</code></td>
          <td>	<code>GeomAdaptor_Surface aGAS;
	GeomAbs_SurfaceType aType;
	//
	aS=BRep_Tool::Surface(aF);
	aGAS.Load(aS);
	aType=aGAS.GetType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 831-840</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 721-730[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aVR2=myOrigins.Fi
	aPK.SetShapes(aVR1, aVR2);
	}
	//=====================================
	//function : MakeVertex
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeVertex(const T
	TopoDS_Vertex& aNewVertex)
	{</code></td>
          <td>	<code>aInfo.SetLocation(aP);
	myMapInfo.Add(aS, aInfo);
	}
	//=====================================
	//function : FillNbSubshapes
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillNbSu
	GEOMAlgo_ShapeInfo& aInfo)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 153-156</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 360-363[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfoF=myMapInfo.
	aKNF=aInfoF.KindOfName();
	if (aKNF==GEOMAlgo_KN_CYLINDER) {
	aFCyl=aF;</code></td>
          <td>	<code>const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	if (aKNE==GEOMAlgo_KN_CIRCLE) {
	aKN=GEOMAlgo_KN_DISKCIRCLE;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 62-63</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 741-742[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>myOutputData->emplace("myGeometryProp
	myOutputData->emplace("myGeometryUniq</code></td>
          <td>	<code>myOutputData->emplace("mySolids", std
	myOutputData->emplace("mySolidIDs", s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1082-1094</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1139-1152[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : GetSubShapes
	//purpose :
	//=====================================
	void GetSubShapes(const TopoDS_Shape& a
	TopTools_IndexedMapOfShape& aMSS)
	{
	Standard_Integer aR;
	TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();
	</code></td>
          <td>	<code>}
	
	//=====================================
	//function : MapBRepShapes
	//purpose :
	//=====================================
	void MapBRepShapes(const TopoDS_Shape&
	TopTools_IndexedMapOfShape& aM)
	{
	Standard_Boolean bDegenerated;
	TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 786-792</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 547-552[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer iCnt;
	TopoDS_Iterator aIt;
	//
	iCnt=0;
	//
	aIt.Initialize(aF);
	for (; aIt.More(); aIt.Next()) {</code></td>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopoDS_Iterator aItC;
	//
	bRet=Standard_False;
	aItC.Initialize(aC);
	for (; aItC.More(); aItC.Next()) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 522-522</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 528-528[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto b2 = BRepPrimAPI_MakeBox(gp_Pnt(</code></td>
          <td>	<code>auto b3 = BRepPrimAPI_MakeBox(gp_Pnt(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 260-262</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 285-288[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aM.Add(aS)) {
	if (!aMx.Contains(aS)) {
	aBB.Add(aC, aS);
	</code></td>
          <td>	<code>if (aMapFence.Add(aSubShape)) {
	// Add theShape as an ancestor shape.
	if (!myMapShapeAnc.IsBound(aSubShape)
	myMapShapeAnc.Bind(aSubShape, TopTool</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 46-50</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 98-101[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(CollisionDetector::hasCollisi
	
	// contact by planer surface,
	TopoDS_Shape aCylinder5 = BRepPrimAPI
	REQUIRE(CollisionDetector::hasCollisi</code></td>
          <td>	<code>anotherAxis.SetLocation(gp_Pnt(0.0, 0
	TopoDS_Shape aCylinder9 = BRepPrimAPI
	// saveShape({aCylinder, aCylinder9},
	REQUIRE(CollisionDetector::detectColl
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/BoundBoxBuilder.h: line 52-58</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 184-189[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>{
	const TopoDS_Shape& s = item(index);
	
	Bnd_Box boundingBox;
	/// default zero gap, here a global t
	boundingBox.SetGap(toleranceThreshold
	BRepBndLib::Add(s, boundingBox); // w</code></td>
          <td>	<code>for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);
	Bnd_Box aBox;
	//
	aBox.SetGap(myTol);
	BRepBndLib::Add(aV, aBox);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1370-1373</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 98-100[27]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i = 1; i <= aNbGroups; ++i) {
	const TopTools_ListOfShape &aListSubS
	
	if (!isShell && aListSubShapes.Extent</code></td>
          <td>	<code>for (i=1; i<=aNbCV; ++i) {
	const TopoDS_Shape& aF=aMCV.FindKey(i
	if (aProcessed.Contains(aF)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 97-110</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 164-174[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>checkData();
	
	if(myErrorStatus) {
	return;
	}
	
	if (myWarningStatus == 10) {
	// The result is the same shape. Noth
	myResult = myShape;
	return;
	}
	
	// Mark sub-shapes as removed and mod
	markShapes();</code></td>
          <td>	<code>PerformShapesToWork();
	if (myErrorStatus) {
	return;
	}
	if (myWarningStatus==1) {
	// no shapes to glue
	myShape=myArgument;
	return;
	}
	//
	FillVertices();
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 671-673</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 895-897[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bIsDone, bHasFirstPo
	Standard_Integer i, aNb, aIx, /*iErr,
	Standard_Real aUMin, aUMax, aVMin, aV</code></td>
          <td>	<code>Standard_Integer iErr, aIx, aNbDomain
	Standard_Real aUMin, aUMax, aVMin, aV
	Standard_Real aVx, aUx, aV1, aV2, aU1</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 256-257</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1334-1335[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (j=i+1; j<=aNbF; ++j) {
	if (aMp.Contains(j)) {</code></td>
          <td>	<code>for (j = i + 1; j <= aNbZones; ++j) {
	if (aMapIndices.Contains(j)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 581-585</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 715-719[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbE=NbSubShapes(TopAbs_EDGE);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();</code></td>
          <td>	<code>aNbV=NbSubShapes(TopAbs_VERTEX);
	aKS=KindOfShape();
	aKN=KindOfName();
	aKB=KindOfBounds();
	aKC=KindOfClosed();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 185-190</strong></td>
        <td style="text-align:center"><strong>src/PPP/AsynchronousDispatcher.h: line 72-77[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (unsigned int t = 0; t < myWorker
	{
	std::vector<ItemIndexType> ids;
	for (ItemIndexType i = 0; i < NItems;
	{
	if ((*myPartitionIds)[i] == t)</code></td>
          <td>	<code>const indexers consume(const ItemInde
	{
	std::vector<indexer> a;
	for (ItemIndexType i = 0; i < nProduc
	{
	if (myQueue.size() > 0)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 234-242</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 326-334[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>"value": True,
	"doc": "matched suppressed from downs
	},
	"searchType": {
	"type": "enum",
	"value": "BoundBox",
	"doc": "all possible enums: GeometryF
	},
	"searchValues": {</code></td>
          <td>	<code>"value": "../data/test_geometry/enclo
	"doc": "input geometry define a space
	},
	"output": {
	"type": "filename",
	"value": "enclosureResult.brep",
	"doc": "result void space/vacuum spac
	},
	"doc": "this doc may be extracted fro</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 637-638</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 655-656[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (xp.Init(aShape, TopAbs_SOLID); x
	{</code></td>
          <td>	<code>for (xp.Init(aShape, TopAbs_COMPOUND)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 891-894</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 197-200[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbS2; ++i) {
	const TopoDS_Shape& aF2=aMS2(i);
	//
	if (aMSIn.Contains(aF2)) {</code></td>
          <td>	<code>for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);
	//
	if (aMVProcessed.Contains(aV)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 30-46</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 34-49[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>static
	Standard_Integer TypeToInteger(const
	const TopAbs_ShapeEnum aType2);
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlaceIterator::GEOMAlgo_G
	{
	myDim=10;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlaceIterator::~GEOMAlgo_</code></td>
          <td>	<code>static
	Standard_Integer NormalizedId(const S
	const Standard_Integer aDiv);
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_PassKeyShape::GEOMAlgo_PassK
	{
	myUpper=432123;
	}
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_PassKeyShape::GEOMAlgo_PassK
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 426-429</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 430-433[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!aMx.Contains(aSx1)) {
	aBB.Add(aCmp, aSx1);
	aMx.Add(aSx1);
	}</code></td>
          <td>	<code>if (!aMx.Contains(aSx2)) {
	aBB.Add(aCmp, aSx2);
	aMx.Add(aSx2);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 413-417</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 418-422[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.UpdateVertex(aVx, myTolerance);
	}
	break;
	case TopAbs_EDGE: {
	const TopoDS_Edge& aEx=TopoDS::Edge(a</code></td>
          <td>	<code>aBB.UpdateEdge(aEx, myTolerance);
	}
	break;
	case TopAbs_FACE: {
	const TopoDS_Face& aFx=TopoDS::Face(a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 229-231</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 110-112[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(aSd, TopAbs_VERTEX,
	aNbV=aMV.Extent();
	if (aNbV!=8) {</code></td>
          <td>	<code>TopExp::MapShapes(myBox, TopAbs_FACE,
	aNbF=aMF.Extent();
	if (aNbF!=6) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CommandLineProcessor.h: line 87-93</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 75-78[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>blocking = parameter<bool>("blocking"
	// input and output preparation
	
	/// prepare private properties like `
	/// therefore accessing item will not
	myItemInputs.resize(myInputData->item
	myItemOutputs.resize(myInputData->ite</code></td>
          <td>	<code>myGeometryProperties = myInputData->g
	// resize() avoid reallocate memeroy
	myAdjacencyMatrix.resize(myInputData-
	myCollisionInfos.resize(myInputData->
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 475-476</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 710-711[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Lin aL0(aPx[0], aDx[0]);
	gp_Lin aL1(aPx[1], aDx[1]);</code></td>
          <td>	<code>gp_Vec aVz(aPC[0], aPC[1]);
	gp_Vec aVx(aPC[0], aPX[0]);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 306-322</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 296-312[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Gluer2::FillSolids()
	{
	FillContainers(TopAbs_SOLID);
	}
	//=====================================
	//function : FillCompSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillCompSolids()
	{
	FillContainers(TopAbs_COMPSOLID);
	}
	//=====================================
	//function : FillVertices
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillVertices()</code></td>
          <td>	<code>void GEOMAlgo_GlueDetector::DetectFaces
	{
	DetectShapes(TopAbs_FACE);
	}
	//=====================================
	//function : DetectEdges
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectEdges
	{
	DetectShapes(TopAbs_EDGE);
	}
	//=====================================
	//function : DetectShapes
	//purpose :
	//=====================================
	void GEOMAlgo_GlueDetector::DetectShape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 154-157</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 168-171[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>d.set<Data>("CP", std::make_shared<Da
	REQUIRE(d.get<Data>("CP")->size() ==
	
	data.resize(length, 1); // refill the</code></td>
          <td>	<code>d.setSerializable("C_S", std::move(da
	REQUIRE(d.get<Data>("C_S")->size() ==
	
	d.setSerializable<const Data>("CP_S",</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 380-385</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 340-345[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (BRep_Tool::Degenerated(aE)) {
	myMSS.Add(aE, aSt);
	continue;
	}
	//
	if (myState==GEOMAlgo_ST_ON) {</code></td>
          <td>	<code>if (BRep_Tool::Degenerated(aE)) {
	myMSS.Add(aE, aSt);
	continue;
	}
	//
	if (myState==GEOMAlgo_ST_ON && aType1</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 812-815</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 320-323[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGAS.Load(aS);
	aST=aGAS.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
          <td>	<code>GeomAdaptor_Surface aGAS(aSurf);
	aST=aGAS.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 72-87</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 36-51[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>myLimit=TopAbs_SHAPE;
	myLimitMode=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_Splitter::~GEOMAlgo_Splitter()
	{
	}
	//=====================================
	//function : AddTool
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::AddTool(const T
	{</code></td>
          <td>	<code>myTolerance=0.0001;
	myCheckGeometry=Standard_True;
	}
	//=====================================
	//function : ~GEOMAlgo_GluerAlgo
	//purpose :
	//=====================================
	GEOMAlgo_GluerAlgo::~GEOMAlgo_GluerAlgo
	{
	}
	//=====================================
	//function : SetArgument
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetArgument(co
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 34-49</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 30-46[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>static
	Standard_Integer NormalizedId(const S
	const Standard_Integer aDiv);
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_PassKeyShape::GEOMAlgo_PassK
	{
	myUpper=432123;
	}
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_PassKeyShape::GEOMAlgo_PassK
	</code></td>
          <td>	<code>static
	Standard_Integer TypeToInteger(const
	const TopAbs_ShapeEnum aType2);
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlaceIterator::GEOMAlgo_G
	{
	myDim=10;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlaceIterator::~GEOMAlgo_</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 519-522</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 812-815[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomAdaptor_Curve aGAC(aC3D);
	aCT=aGAC.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
          <td>	<code>aGAS.Load(aS);
	aST=aGAS.GetType();
	bIsAllowedType=GEOMAlgo_ShapeInfoFill
	if (!bIsAllowedType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SolidSolid.cxx: line 153-156</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 441-443[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for(j=1; j<aNbF; ++j) {
	const TopoDS_Shape& aF=aMF(j);
	//
	if (!aMFS.Contains(aF)) {// the face</code></td>
          <td>	<code>for (i=1; i<=aNbX; ++i) {
	const TopoDS_Shape& aSx=aMx(i);
	if (!aMS.Contains(aSx)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 170-174</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 90-97[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aFi=aFx;
	aFi.Orientation(TopAbs_FORWARD);
	aSFS.Append(aFi);
	aFi.Orientation(TopAbs_REVERSED);
	aSFS.Append(aFi);
	
	
	</code></td>
          <td>	<code>aMassTol *= aTolConf;
	
	// Searching for the sub-shapes insid
	theGIP.SetTolerance(aTolConf);
	theGIP.SetTolMass(aMassTol);
	theGIP.SetTolCG(aTolConf);
	
	theGIP.SetArgument(theWhat);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 187-189</strong></td>
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 16-18[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>sys.path.append(cmod_path)
	pymod_path = os.path.dirname(cmod_pat
	if os.path.exists(pymod_path):</code></td>
          <td>	<code>this_file_folder = os.path.dirname(os
	built_module_dir = os.path.dirname(th
	if os.path.exists(os.path.abspath(bui</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 478-480</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 86-88  [26]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 510-516</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1158-1163[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>// This edge is not created.
	if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	aListEdges.Clear();
	}
	} else {</code></td>
          <td>	<code>if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	aListEdges.Clear();
	}
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 53-58</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 26-31[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(XCAFDoc_ShapeTool) myShapeTool
	Handle(XCAFDoc_ColorTool) myColorTool
	Handle(XCAFDoc_MaterialTool) myMateri
	
	std::vector<TDF_Label> myShapeLabels;
	std::set<ItemHashType> myRefShapes;</code></td>
          <td>	<code>Handle(XCAFDoc_ShapeTool) myShapeTool
	Handle(XCAFDoc_ColorTool) myColorTool
	Handle(XCAFDoc_MaterialTool) myMateri
	
	std::vector<TDF_Label> myShapeLabels;
	std::set<Standard_Integer> myRefShape</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 389-391</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 153-155[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	if (aKNE!=GEOMAlgo_KN_SEGMENT) {</code></td>
          <td>	<code>const TopoDS_Shape& aS=aDS.Shape(i);
	aType=aS.ShapeType();
	if (aType!=TopAbs_VERTEX) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 603-609</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1067-1074[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNewShapes.Append(aNewShape);
	}
	}
	} else {
	aClosedSubShapes.Append(anOuterSubSha
	}
	</code></td>
          <td>	<code>aLSx.Append(aSWhere);
	}
	}
	} else {
	// This "what" shape is not inclusive
	aMapRemaining.Remove(aShape);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/AsynchronousDispatcher.h: line 72-77</strong></td>
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 185-190[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>const indexers consume(const ItemInde
	{
	std::vector<indexer> a;
	for (ItemIndexType i = 0; i < nProduc
	{
	if (myQueue.size() > 0)</code></td>
          <td>	<code>for (unsigned int t = 0; t < myWorker
	{
	std::vector<ItemIndexType> ids;
	for (ItemIndexType i = 0; i < NItems;
	{
	if ((*myPartitionIds)[i] == t)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 404-410</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 466-473[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aE);
	myImages.Bind(aEnew, aLSD);
	myOrigins.Bind(aE, aEnew);
	}
	}//for (i=1; i<=aNbF; ++i) {
	</code></td>
          <td>	<code>TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aW);
	myImages.Bind(aWnew, aLSD);
	myOrigins.Bind(aW, aWnew);
	//
	}//for (i=1; i<=aNbE; ++i) {
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 84-101</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 145-162[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>return bRet;
	}
	//=====================================
	//function : HasDeleted
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BuilderShap
	{
	return myHasDeleted;
	}
	//=====================================
	//function : HasGenerated
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_BuilderShap
	{
	return myHasGenerated;
	}</code></td>
          <td>	<code>myKeepNonSolids=aFlag;
	}
	//=====================================
	//function : KeepNonSolids
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Gluer::KeepNo
	{
	return myKeepNonSolids;
	}
	//=====================================
	//function : AloneShapes
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_Gluer::AloneS
	{
	return myNbAlone;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1067-1074</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 603-609[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLSx.Append(aSWhere);
	}
	}
	} else {
	// This "what" shape is not inclusive
	aMapRemaining.Remove(aShape);
	}</code></td>
          <td>	<code>aNewShapes.Append(aNewShape);
	}
	}
	} else {
	aClosedSubShapes.Append(anOuterSubSha
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 220-223</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 254-257[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>void set(const std::string& key, DTyp
	{
	std::cout << "DEBUG info: set() with
	typename std::remove_reference<DType></code></td>
          <td>	<code>void setSerializable(const std::strin
	{
	std::cout << "set() with std::enable_
	typename std::remove_reference<T>::ty</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 65-77</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 44-55[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>static
	void MapBRepShapes(const TopoDS_Shape
	TopTools_IndexedMapOfShape& aM);
	
	
	//=====================================
	//function : GEOMAlgo_GetInPlace
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlace::GEOMAlgo_GetInPlac
	:
	GEOMAlgo_GluerAlgo(),
	GEOMAlgo_Algo()</code></td>
          <td>	<code>static
	void TreatCompound(const TopoDS_Shape
	TopTools_ListOfShape& aLSX);
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_Splitter::GEOMAlgo_Splitter()
	:
	BOPAlgo_Builder(),
	myTools(myAllocator),
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1057-1063</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 438-443[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRep_Builder aBuilder;
	TopoDS_Compound aCompound;
	TopTools_MapOfShape aMapFence;
	
	aBuilder.MakeCompound(aCompound);
	
	for (; anIter.More(); anIter.Next())</code></td>
          <td>	<code>TopoDS_Shape aVR;
	TopoDS_Iterator aIt;
	TopTools_ListOfShape aLV;
	//
	aIt.Initialize(aE);
	for (; aIt.More(); aIt.Next()) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 228-231</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 544-547[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Face& aF=TopoDS::Face(aM
	aOr=aF.Orientation();
	//
	aM.Clear();</code></td>
          <td>	<code>const TopoDS_Shell& aShell=TopoDS::Sh
	anOr=aShell.Orientation();
	//
	aBB.MakeShell(aNewShell);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 36-51</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 72-87[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>myTolerance=0.0001;
	myCheckGeometry=Standard_True;
	}
	//=====================================
	//function : ~GEOMAlgo_GluerAlgo
	//purpose :
	//=====================================
	GEOMAlgo_GluerAlgo::~GEOMAlgo_GluerAlgo
	{
	}
	//=====================================
	//function : SetArgument
	//purpose :
	//=====================================
	void GEOMAlgo_GluerAlgo::SetArgument(co
	{</code></td>
          <td>	<code>myLimit=TopAbs_SHAPE;
	myLimitMode=0;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_Splitter::~GEOMAlgo_Splitter()
	{
	}
	//=====================================
	//function : AddTool
	//purpose :
	//=====================================
	void GEOMAlgo_Splitter::AddTool(const T
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 549-559</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 684-694[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::PointOnEdge(aE, a
	}
	//=====================================
	//function : PointOnEdge
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::PointOnEdge(co
	const Standard_Real aT,
	gp_Pnt& aP3D)
	{
	Standard_Real aT1, aT2;</code></td>
          <td>	<code>InnerPoints(aE, aNbPntsMin, aLP);
	}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn1::InnerPoin
	const Standard_Integer aNbPntsMin,
	GEOMAlgo_ListOfPnt& aLP)
	{
	Standard_Boolean bInf1, bInf2;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 622-633</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 498-509[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>return; // conventional cylinder
	}//if (aNbCE==2 && aNbSE==1) {
	}//if (aNbV==2 && aNbE==3) {
	}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Cone& aCone)
	{
	Standard_Integer aNbV, aNbE, aNbCE, a</code></td>
          <td>	<code>return;
	}
	}
	}
	//=====================================
	//function : PerformEE
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformEE(con
	const TopoDS_Shape &theE2)
	{
	Standard_Boolean bHasOn, bHasIn, bFou</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 110-112</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 229-231[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(myBox, TopAbs_FACE,
	aNbF=aMF.Extent();
	if (aNbF!=6) {</code></td>
          <td>	<code>TopExp::MapShapes(aSd, TopAbs_VERTEX,
	aNbV=aMV.Extent();
	if (aNbV!=8) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1145-1152</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1087-1094[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>void MapBRepShapes(const TopoDS_Shape&
	TopTools_IndexedMapOfShape& aM)
	{
	Standard_Boolean bDegenerated;
	TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();</code></td>
          <td>	<code>void GetSubShapes(const TopoDS_Shape& a
	TopTools_IndexedMapOfShape& aMSS)
	{
	Standard_Integer aR;
	TopAbs_ShapeEnum aType;
	TopoDS_Iterator aIt;
	//
	aType=aS.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 132-134</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/Property.h: line 134-136[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>: name(std::move(a.name))
	, data(std::move(a.data))
	, type(std::move(a.type))</code></td>
          <td>	<code>, type(std::move(a.type))
	, flag(std::move(a.flag))
	, jsonizer(std::move(a.jsonizer)){</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 29-68</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 27-64[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_Gluer_HeaderFile
	#define _GEOMAlgo_Gluer_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <Standard_Boolean.hxx>
	#include <Standard_Real.hxx>
	#include <Standard_Integer.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopoDS_Shape.hxx>
	#include <TopoDS_Edge.hxx>
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Vertex.hxx>
	#include <TopoDS_Compound.hxx>
	
	#include <TopTools_MapOfShape.hxx>
	#include <TopTools_DataMapOfShapeListOf
	#include <TopTools_DataMapOfShapeShape.
	#include <TopTools_ListOfShape.hxx>
	
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_PassKeyShape.hxx>
	
	//=====================================
	//class : GEOMAlgo_Gluer
	//purpose :
	//=====================================
	class GEOMAlgo_Gluer : public GEOMAlgo_
	public:
	Standard_EXPORT
	GEOMAlgo_Gluer();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_Gluer();
	
	Standard_EXPORT
	void SetCheckGeometry(const Standard_</code></td>
          <td>	<code>#ifndef _GEOMAlgo_FinderShapeOn1_Header
	#define _GEOMAlgo_FinderShapeOn1_Header
	
	#include <GEOMAlgo_State.hxx>
	#include <GEOMAlgo_IndexedDataMapOfShap
	#include <GEOMAlgo_ShapeAlgo.hxx>
	#include <GEOMAlgo_ListOfPnt.hxx>
	
	#include <TopAbs_State.hxx>
	#include <TopAbs_ShapeEnum.hxx>
	#include <TopoDS_Face.hxx>
	#include <TopoDS_Edge.hxx>
	#include <TopTools_ListOfShape.hxx>
	
	#include <Geom_Surface.hxx>
	#include <GeomAdaptor_Surface.hxx>
	
	#include <gp_Pnt.hxx>
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Integer.hxx>
	
	//=====================================
	//function : GEOMAlgo_FinderShapeOn1
	//purpose :
	//=====================================
	class GEOMAlgo_FinderShapeOn1 : public
	{
	public:
	Standard_EXPORT
	GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_FinderShapeOn1();
	
	Standard_EXPORT
	void SetSurface(const Handle(Geom_Sur
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 179-182</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 183-186[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (TopExp_Explorer anExp(aShape, To
	{
	Nb_solids += 1;
	}</code></td>
          <td>	<code>for (TopExp_Explorer anExp(aShape, To
	{
	Nb_faces += 1;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 140-145</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 277-281[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS=aIt1.Value();
	aMFence.Add(aS);
	}
	//
	aNbR=aMFence.Extent();
	if (aNbS!=aNbR) {</code></td>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	aLS.Append(aS);
	}
	aNbS=aLS.Extent();
	if (aNbS==1) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 290-306</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 306-322[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Gluer2::FillWires()
	{
	FillContainers(TopAbs_WIRE);
	}
	//=====================================
	//function : FillShells
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillShells()
	{
	FillContainers(TopAbs_SHELL);
	}
	//=====================================
	//function : FillSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillSolids()</code></td>
          <td>	<code>void GEOMAlgo_Gluer2::FillSolids()
	{
	FillContainers(TopAbs_SOLID);
	}
	//=====================================
	//function : FillCompSolids
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillCompSolids()
	{
	FillContainers(TopAbs_COMPSOLID);
	}
	//=====================================
	//function : FillVertices
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::FillVertices()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 31-32</strong></td>
        <td style="text-align:center"><strong>src/Geom/CMakeLists.txt: line 44-45[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>####################### standalone app
	add_executable(UniqueIdValidator "Uniqu</code></td>
          <td>	<code>########################## main #######
	add_executable(MyGeomMain "GeometryMain</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 269-277</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 226-234[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>"range": [1e-5, 0.5],
	"doc": "ratio of common volume to tha
	},
	"suppressFloating": {
	"type": "bool",
	"value": False,
	"doc": "part without contact with oth
	},
	"suppressErroneous": {</code></td>
          <td>	<code>"value": "echo {}",
	"doc": "C++20 or python format, 1st a
	},
	"blocking": {
	"type": "bool",
	"value": True,
	"doc": "blocking the calling thread u
	},
	"usingPipeStream": False, # must be t</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 73-75</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 361-363[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aMCV.Contains(aF2)) {
	TopTools_IndexedMapOfShape& aMV=aMCV.
	aMV.Add(aF1);</code></td>
          <td>	<code>if (aDMSLS.IsBound(aS1)) {
	TopTools_ListOfShape& aLS=aDMSLS.Chan
	aLS.Append(aS2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 125-129</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 174-178[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>iErr=PntInFace(aF2, aP2);
	}
	//
	else if (aType2==TopAbs_SOLID) {
	const TopoDS_Solid& aZ2=*((TopoDS_Sol</code></td>
          <td>	<code>bOk=myContext->IsValidPointForFace(aP
	}
	//
	else if (aType1==TopAbs_SOLID) {
	const TopoDS_Solid& aZ1=*((TopoDS_Sol</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 979-985</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 451-456[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPTools_AlgoTools2D::BuildPCurveForE
	
	// orient image
	bIsToReverse=GEOMAlgo_AlgoTools::IsSp
	if (bIsToReverse) {
	aER.Reverse();
	}</code></td>
          <td>	<code>aEnew=myOrigins.Find(aE);
	//
	bToReverse=BOPTools_AlgoTools::IsSpli
	if (bToReverse) {
	aEnew.Reverse();
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 44-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 65-77[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>static
	void TreatCompound(const TopoDS_Shape
	TopTools_ListOfShape& aLSX);
	
	//=====================================
	//function :
	//purpose :
	//=====================================
	GEOMAlgo_Splitter::GEOMAlgo_Splitter()
	:
	BOPAlgo_Builder(),
	myTools(myAllocator),
	</code></td>
          <td>	<code>static
	void MapBRepShapes(const TopoDS_Shape
	TopTools_IndexedMapOfShape& aM);
	
	
	//=====================================
	//function : GEOMAlgo_GetInPlace
	//purpose :
	//=====================================
	GEOMAlgo_GetInPlace::GEOMAlgo_GetInPlac
	:
	GEOMAlgo_GluerAlgo(),
	GEOMAlgo_Algo()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 640-646</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 704-710[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>} else {
	aNewShapes.Append(aNewShape);
	}
	}
	} else if (!myMapRemoved.Contains(aSu
	// The shape is not modified.
	if (isToCreate) {</code></td>
          <td>	<code>} else {
	aNewOtherShapes.Append(aNewShape);
	}
	}
	} else if (!myMapRemoved.Contains(aSu
	// Shape is neither removed nor modif
	if (aSubShape.ShapeType() == aSubShap</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 65-76</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 322-332[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_Gluer2::Detect()
	{
	Standard_Boolean bCheckGeometry;
	Standard_Integer iErr;
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	//GEOMAlgo_GlueDetector aDetector;
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	myImagesDetected.Clear();</code></td>
          <td>	<code>void GEOMAlgo_Gluer2::FillVertices()
	{
	TopAbs_ShapeEnum aType;
	TopoDS_Vertex aVnew;
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	//
	myErrorStatus=0;
	myWarningStatus=0;
	//
	aItDMSLS.Initialize(myImagesToWork);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 140-160</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 45-56[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>class GEOMAlgo_GetInPlace : public GEOM
	public GEOMAlgo_Algo
	{
	public:
	/**
	* Constructor.
	*/
	Standard_EXPORT
	GEOMAlgo_GetInPlace();
	/**
	* Destructor.
	*/
	Standard_EXPORT
	virtual ~GEOMAlgo_GetInPlace();
	/**
	* Modifier. Sets the shape where the
	* @param theShape
	* The shape where the search is inten
	*/
	Standard_EXPORT
	virtual void SetShapeWhere(const Topo</code></td>
          <td>	<code>class GEOMAlgo_GlueDetector : public GE
	public GEOMAlgo_Algo
	{
	public:
	Standard_EXPORT
	GEOMAlgo_GlueDetector();
	
	Standard_EXPORT virtual
	~GEOMAlgo_GlueDetector();
	
	Standard_EXPORT virtual
	void Perform() ;
	
	
	
	
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 22-26</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 121-127[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>A() = default;
	// A() {std::cout<< "A constructed wi
	A(A&& a)
	: name(std::move(a.name))
	{
	
	</code></td>
          <td>	<code>virtual ~PropertyContainer() = defaul
	
	/// NOTE: copy constructor will be di
	
	PropertyContainer(PropertyContainer&&
	: myProperties(std::move(pc.myPropert
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 71-76</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 542-547[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer CheckAncesstors
	(const TopoDS_Shape& aVSD,
	const TopTools_MapOfShape& aMVSD,
	const TopTools_IndexedDataMapOfShapeL
	const TopTools_IndexedDataMapOfShapeL
	TopTools_IndexedDataMapOfShapeListOfS</code></td>
          <td>	<code>Standard_Integer CheckAncesstors
	(const TopoDS_Shape& aVSD,
	const TopTools_MapOfShape& aMVSD,
	const TopTools_IndexedDataMapOfShapeL
	const TopTools_IndexedDataMapOfShapeL
	TopTools_IndexedDataMapOfShapeListOfS</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1173-1181</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1204-1212[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	if (isModified && !aListListEdges.IsE
	// Make wires.
	makeWires(theWire, aListListEdges, th
	}
	
	return isModified;
	}</code></td>
          <td>	<code>}
	
	if (isModified && !aListFaces.IsEmpty
	// Create new shells.
	groupViaBounds(theShell, aListFaces,
	}
	
	return isModified;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 36-38</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 38-38[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>) # todo: fix the tmp folder for window
	
	######################### utilities ###</code></td>
          <td>	<code>######################### utilities ###
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 498-504</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 510-516[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (myMapRemoved.Contains(anEdge)) {
	// This edge is removed.
	if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	aListEdges.Clear();
	}
	} else if (myMapModified.IsBound(anEd</code></td>
          <td>	<code>if (aModifEdges.IsEmpty()) {
	// This edge is not created.
	if (!aListEdges.IsEmpty()) {
	aListListEdges.Append(aListEdges);
	aListEdges.Clear();
	}
	} else {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 862-873</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 622-633[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>return;
	}
	}// for (; myIterator.More(); myItera
	}
	//=====================================
	//function : PerformZZ
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::PerformZZ(con
	const TopoDS_Shape &theSo2)
	{
	Standard_Boolean bFound, bHasOn, bHas</code></td>
          <td>	<code>return; // conventional cylinder
	}//if (aNbCE==2 && aNbSE==1) {
	}//if (aNbV==2 && aNbE==3) {
	}
	//=====================================
	//function : FillDetails
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillDeta
	const gp_Cone& aCone)
	{
	Standard_Integer aNbV, aNbE, aNbCE, a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 324-331</strong></td>
        <td style="text-align:center"><strong>src/python/pppPipelineController.py: line 224-231[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>"enclosureGeometry": {
	"type": "filename",
	"value": "../data/test_geometry/enclo
	"doc": "input geometry define a space
	},
	"output": {
	"type": "filename",
	"value": "enclosureResult.brep",</code></td>
          <td>	<code>"commandLinePattern": {
	"type": "string",
	"value": "echo {}",
	"doc": "C++20 or python format, 1st a
	},
	"blocking": {
	"type": "bool",
	"value": True,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 649-652</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 768-772[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	if (aNbV==2 && aNbE==3) {
	i=0;
	</code></td>
          <td>	<code>aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	aNbE=aInfo.NbSubShapes(TopAbs_EDGE);
	
	if (aNbV==1 && aNbE==2) {
	aNbSE=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 746-751</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 755-760[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>printf(" Radius1 : %.3lf\n", myRadius
	}
	else if (aKN==GEOMAlgo_KN_ARCCIRCLE)
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius</code></td>
          <td>	<code>printf(" Pnt2 : %.3lf %.3lf %.3lf\n",
	}
	else if (aKN==GEOMAlgo_KN_ELLIPSE) {
	DumpLocation (myLocation);
	DumpPosition (myPosition);
	printf(" Radius1 : %.3lf\n", myRadius</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 111-113</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 138-140[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
          <td>	<code>}
	else if (Utilities::hasFileExt(file_n
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 70-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 654-658[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS1=theCS.Shape1(
	const TopoDS_Shape& aS2=theCS.Shape2(
	aType1=aS1.ShapeType();
	
	</code></td>
          <td>	<code>const TopoDS_Shape& aF1=aCS.Shape1();
	const TopoDS_Shape& aE2=aCS.Shape2();
	//
	// 1.
	bHasOnF=myShapesOn.IsBound(aF1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 121-127</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 22-26[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual ~PropertyContainer() = defaul
	
	/// NOTE: copy constructor will be di
	
	PropertyContainer(PropertyContainer&&
	: myProperties(std::move(pc.myPropert
	{</code></td>
          <td>	<code>A() = default;
	// A() {std::cout<< "A constructed wi
	A(A&& a)
	: name(std::move(a.name))
	{
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 50-52</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 85-87[26]</strong></td>
        </tr>
        <tr>
          <td>	<code>App.Vector(10.5, 10.5, 0.5), App.Rota
	)
	doc.recompute()</code></td>
          <td>	<code>App.Vector(-9.9, -5, 0), App.Rotation
	)
	doc.recompute()</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 711-717</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 751-757[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>iErr=GEOMAlgo_AlgoTools::FindSDShapes
	if (iErr) {
	return 2; // Err
	}
	//
	aNbESD=aLESD.Extent();
	if (!aNbESD) {</code></td>
          <td>	<code>iErr=GEOMAlgo_AlgoTools::FindSDShapes
	if (iErr) {
	return iErr;
	}
	//
	aNbEE=aMEE.Extent();
	if (aNbEE==1) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1053-1057</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 726-728[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape &aSWhere = myShape
	
	if (myImages.IsBound(aSWhere)) {
	// Remove inclusive shapes from aMapR
	const TopTools_ListOfShape& aLWhat =</code></td>
          <td>	<code>const TopoDS_Shape& aFS=aMFS(j);
	if (aMFR.Contains(aFS)) {
	const TopTools_ListOfShape& aLSx=aMFR
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Writer.h: line 24-26</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 59-61[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!fs::path(file_name).is_absolute(
	file_name = dataStoragePath(file_name
	if (file_name.size() && myOutputData-</code></td>
          <td>	<code>if (not fs::path(file_name).is_absolu
	file_name = dataStoragePath(file_name
	if (file_name.size())</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 393-396</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 445-448[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Shape aShape = anExp.Current()
	
	if (aMapFence.Add(aShape)) {</code></td>
          <td>	<code>const TopoDS_Shape &aShapeVertex = an
	
	if (aMapFence.Add(aShapeVertex)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 577-585</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 878-886[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aS->D0(aU, aV, aP3D);
	}
	//=====================================
	//function : PointOnFace
	//purpose :
	//=====================================
	void GEOMAlgo_AlgoTools::PointOnFace(co
	gp_Pnt& aP3D)
	{</code></td>
          <td>	<code>aBB.MakeVertex (aNewVertex, aPGC, aDm
	}
	//=====================================
	//function : MakeEdge
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeEdge(const Top
	TopoDS_Edge& aNewEdge)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 90-97</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 170-174[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aMassTol *= aTolConf;
	
	// Searching for the sub-shapes insid
	theGIP.SetTolerance(aTolConf);
	theGIP.SetTolMass(aMassTol);
	theGIP.SetTolCG(aTolConf);
	
	theGIP.SetArgument(theWhat);</code></td>
          <td>	<code>aFi=aFx;
	aFi.Orientation(TopAbs_FORWARD);
	aSFS.Append(aFi);
	aFi.Orientation(TopAbs_REVERSED);
	aSFS.Append(aFi);
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.hxx: line 83-92</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 85-94[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetIds(const TColStd_ListOfInteg
	
	Standard_EXPORT
	Standard_Integer NbIds() const;
	
	Standard_EXPORT
	Standard_Boolean IsEqual(const GEOMAl
	
	Standard_EXPORT
	Standard_Integer HashCode(const Stand</code></td>
          <td>	<code>void Clear() ;
	
	Standard_EXPORT
	Standard_Integer NbIds() const;
	
	Standard_EXPORT
	Standard_Boolean IsEqual(const GEOMAl
	
	Standard_EXPORT
	Standard_Integer HashCode(const Stand</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 539-540</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 182-183[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>size_t CollisionDetector::shapeMatch(
	const std::vector<Standard_Real> vols</code></td>
          <td>	<code>size_t shapeMatch(Standard_Real volum
	const std::vector<Standard_Real> vols</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.h: line 27-30</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.h: line 43-46      [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline static const std::string worki
	{
	return Context::singleton()->myConfig
	}</code></td>
          <td>	<code>inline static std::size_t threadCount
	{
	return Context::singleton()->myConfig
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 84-98</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 146-159[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	// 1.
	CheckData();
	if(myErrorStatus) {
	return;
	}</code></td>
          <td>	<code>}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 336-338</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 65-67[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (TopExp_Explorer anExp(loaded_sha
	{
	shapes.push_back(anExp.Current());</code></td>
          <td>	<code>for (TopExp_Explorer i(aShape, TopAbs
	{
	aFaceList.Append(TopoDS::Face(i.Curre</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 66-70</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 73-78[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>allVol += v;
	}
	
	auto min_result_volume = *std::min_el
	if (min_result_volume < 0)
	</code></td>
          <td>	<code>return CollisionType::Error;
	}
	auto max_original_volume = *std::max_
	// auto min_original_volume = *std::m
	
	if (resultShapes.size() > originalSha</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 236-243</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 214-218[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (tolerance > 0.0)
	gluer.SetTolerance(tolerance);
	
	// 2. Detect interfered shapes, it ca
	gluer.Detect();
	iErr = gluer.ErrorStatus();
	if (iErr)
	{</code></td>
          <td>	<code>aSB.SetContext(myContext);
	aSB.SetShapes(aSFS);
	aSB.Perform();
	iErr=aSB.HasErrors();
	if (iErr) {
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 168-173</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_3.cxx: line 174-179[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType2==TopAbs_VERTEX) {
	iRet=6;
	}
	else if (aType2==TopAbs_EDGE) {
	iRet=7;
	}</code></td>
          <td>	<code>else if (aType2==TopAbs_FACE) {
	iRet=8;
	}
	else if (aType2==TopAbs_SOLID) {
	iRet=9;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 553-556</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 309-311[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aCx=aItC.Value();
	aType=aCx.ShapeType();
	//
	if (aType==TopAbs_COMPOUND) {</code></td>
          <td>	<code>const TopoDS_Shape& aS=aItC.Value();
	aType=aS.ShapeType();
	if (aType==TopAbs_COMPOUND) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 182-185</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_WireSolid.cxx: line 149-152[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aHAB=new Bnd_HArray1OfBox(1, aNbV);
	//
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
          <td>	<code>aRange.Indices(iBeg, iEnd);
	//
	for (i=iBeg; i<=iEnd; ++i) {
	const TopoDS_Shape& aS=pDS->Shape(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 221-227</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 183-189[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean bRet;
	GeomAbs_SurfaceType aST1;
	GeomAdaptor_Surface aGAS1;
	//
	aGAS1.Load(aS1);
	aST1=aGAS1.GetType();</code></td>
          <td>	<code>Standard_Boolean bRet;
	GeomAbs_SurfaceType aType;
	GeomAdaptor_Surface aGAS;
	//
	aGAS.Load(aSurf);
	aType=aGAS.GetType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 970-973</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 996-999[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (aMapAncs[iCur].Clear(); anAncIt.
	const TopoDS_Shape &anAncestor = anAn
	
	if (aMapAncs[iPrev].Contains(anAncest</code></td>
          <td>	<code>for (aMapIt.Initialize(aMapAncs[iCur]
	const TopoDS_Shape &aShape = aMapIt.K
	
	if (aShape.ShapeType() == aType) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 32-39</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 17-25[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>```python
	from detectFreeCAD import append_freeca
	append_freecad_mod_path()
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)
	</code></td>
          <td>	<code>from pppStartPipeline import ppp_start_
	from detectFreeCAD import append_freeca
	
	append_freecad_mod_path()
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 241-247</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 106-111[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aTol=1.e-7;
	//
	// 1. bUClosed - direction of closene
	//
	aES=aEold;
	aES.Orientation(TopAbs_FORWARD);
	aC2DS1=BRep_Tool::CurveOnSurface(aES,</code></td>
          <td>	<code>GeomAdaptor_Surface aGAS;
	//
	aState=TopAbs_UNKNOWN;
	aGAS.Load(aSurf);
	//
	iErr=GEOMAlgo_SurfaceTools::GetState(
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 669-674</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 701-707[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbV=aInfo.NbSubShapes(TopAbs_VERTEX)
	if (!aNbV) {
	myErrorStatus=11; // ellipse edge wit
	return;
	}
	aInfo.SetKindOfBounds(GEOMAlgo_KB_TRI
	</code></td>
          <td>	<code>bIsDone=aHatcher.TrimDone(aIx);
	if (!bIsDone) {
	myErrorStatus=42;
	return;
	}
	//
	aHatcher.ComputeDomains(aIx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 281-285</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 188-191[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNb=1;
	}
	//
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aS=aM(i);</code></td>
          <td>	<code>return bRet;
	}
	for (i=1; i<=myNbIds; ++i) {
	const TopoDS_Shape& aS=myMap(i);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 110-112</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 109-110[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>return cinfo[id]
	
	#######################################</code></td>
          <td>	<code>case_name = inputFilename[: inputFilena
	######################## module specifi
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 140-146</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 158-163[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Real aMaxTol=0.0001);
	
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Edge& aEF2,
	const Handle(IntTools_Context)& aCtx)</code></td>
          <td>	<code>TopoDS_Shape& theC);
	
	Standard_EXPORT
	static Standard_Boolean IsSplitToReve
	const TopoDS_Edge& theEdge,
	const Handle(IntTools_Context)& theCt
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.h: line 182-183</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 539-540[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>size_t shapeMatch(Standard_Real volum
	const std::vector<Standard_Real> vols</code></td>
          <td>	<code>size_t CollisionDetector::shapeMatch(
	const std::vector<Standard_Real> vols</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 285-291</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 343-346[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>"range": [True, False],
	"doc": "ignore solids with BOP check
	},
	"output": {
	"type": "filename",
	"value": "myCollisionInfos.json",
	"doc": "collision type info dump, imp</code></td>
          <td>	<code>"range": [1e-3, 10],
	"doc": "length resolution or mesh siz
	},
	"output": {"type": "filename", "value
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 205-211</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 215-221[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>case GEOMAlgo_ST_IN:
	if (aST1==TopAbs_IN) {
	bRet=!bRet;
	}
	break;
	case GEOMAlgo_ST_OUT:</code></td>
          <td>	<code>case GEOMAlgo_ST_ON:
	if (aST1==TopAbs_ON) {
	bRet=!bRet;
	}
	break;
	case GEOMAlgo_ST_ONIN:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 713-715</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 195-198[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbDomains=aHatcher.NbDomains(aIx);
	for (j=1; j<=aNbDomains; ++j) {
	const HatchGen_Domain& aDomain=aHatch
	</code></td>
          <td>	<code>aBSB.Initialize(aHAB);
	//
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 992-998</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 463-470[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	// xf
	TopTools_ListOfShape aLW;
	//
	aLW.Append(aW);
	myImages.Bind(newWire, aLW);
	myOrigins.Bind(aW, newWire);
	</code></td>
          <td>	<code>}
	//
	//myImages / myOrigins
	TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aW);
	myImages.Bind(aWnew, aLSD);
	myOrigins.Bind(aW, aWnew);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 194-205</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 214-224[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Clear();
	if (myErrorStatus) {
	return;
	}
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	//
	// Initialize the context
	GEOMAlgo_GluerAlgo::Perform();</code></td>
          <td>	<code>BuildResult();
	if (myErrorStatus) {
	return;
	}
	//
	PrepareHistory();
	if (myErrorStatus) {
	return;
	}
	//
	BRepLib::SameParameter(myShape, myTol
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 66-71</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.h: line 71-74    [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomExport TopoDS_Shape glueFaces(con
	
	
	GeomExport TopoDS_Compound
	createCompound(const ItemContainerTyp
	std::shared_ptr<const MapType<ItemHas</code></td>
          <td>	<code>std::shared_ptr<const MapType<ItemHas
	GeomExport TopoDS_CompSolid
	createCompSolid(const ItemContainerTy
	std::shared_ptr<const MapType<ItemHas
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 187-190</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 185-188[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp::MapShapes(myShape, anIndices)
	
	while (anIter.More()) {
	const TopoDS_Shape &aSubShape = anIte</code></td>
          <td>	<code>TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 467-471</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 485-489[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Bnd_Box calcBndBox(const TopoDS_Shape
	{
	Bnd_Box thisBox;
	thisBox.SetGap(0.0);
	BRepBndLib::Add(s, thisBox);</code></td>
          <td>	<code>Standard_Boolean isCoincidentDomain(c
	{
	Bnd_Box boundingBox;
	boundingBox.SetGap(0.0); // todo: set
	BRepBndLib::Add(s1, boundingBox);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 689-694</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 237-242[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbEProcessed==aNbE) {
	break;
	}
	//
	aIt.Initialize(aLE);
	for (; aIt.More(); aIt.Next()) {</code></td>
          <td>	<code>if (!aNbIP1) {
	break;
	}
	//
	aIt1.Initialize(aMIP);
	for(; aIt1.More(); aIt1.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 87-95</strong></td>
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 112-120  [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>setConfig(Context::config()); // appl
	}
	else
	{
	std::cout << "configuration json file
	<< config_filename << "\n , program t
	std::terminate();
	}
	}</code></td>
          <td>	<code>setupLogger(myConfig);
	}
	else
	{
	std::cout << "configuration json file
	<< "` does not exists, terminate chec
	std::terminate();
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 261-266</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 354-359[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!aImages.IsBound(aS)) {
	iErr=GEOMAlgo_AlgoTools::PntInFace(aF
	if (iErr) {
	myErrorStatus=16;
	return;
	}</code></td>
          <td>	<code>if (myCheckGeometry) {
	iErr=GEOMAlgo_AlgoTools::RefineSDShap
	if (iErr) {
	myErrorStatus=200;
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 570-572</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 655-659[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>bHasOn=myShapesOn.IsBound(aE1);
	bHasIn=myShapesIn.IsBound(aE1);
	const TopTools_MapOfShape& aMSOn=(bHa
	
	</code></td>
          <td>	<code>const TopoDS_Shape& aE2=aCS.Shape2();
	//
	// 1.
	bHasOnF=myShapesOn.IsBound(aF1);
	const TopTools_MapOfShape& aMSOnF=(bH</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfPassKeyInteger.hxx: line 25-41</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfShapePnt.hxx: line 25-44[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfPassKeyIntege
	#define GEOMAlgo_DataMapOfPassKeyIntege
	
	#include <GEOMAlgo_PassKey.hxx>
	#include <Standard_Integer.hxx>
	#include <GEOMAlgo_PassKeyMapHasher.hxx
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	
	typedef NCollection_DataMap<GEOMAlgo_Pa
	typedef GEOMAlgo_DataMapOfPassKeyIntege
	
	#undef _NCollection_MapHasher
	
	
	#endif
	
	
	</code></td>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfShapePnt_Head
	#define GEOMAlgo_DataMapOfShapePnt_Head
	
	
	#include <TopoDS_Shape.hxx>
	#include <gp_Pnt.hxx>
	#include <TopTools_ShapeMapHasher.hxx>
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	#include <gp_Pnt.hxx>
	
	typedef NCollection_DataMap<TopoDS_Shap
	typedef GEOMAlgo_DataMapOfShapePnt::Ite
	
	#undef _NCollection_MapHasher
	
	
	
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 195-198</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 273-275[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBSB.Initialize(aHAB);
	//
	for (i=1; i<=aNbV; ++i) {
	const TopoDS_Shape& aV=aMV(i);</code></td>
          <td>	<code>aBB.MakeCompound(aCmp);
	for (i=1; i<=aNb; ++i) {
	const TopoDS_Shape& aSi=aM(i);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 30-32</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 543-546[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (size_t j = 0; j < extension.leng
	{
	if (std::tolower(ext[j]) != std::tolo
	</code></td>
          <td>	<code>for (size_t i = 0; i < shapes.size();
	{
	// TODO: should also compare boundbox
	if (OccUtils::floatEqual(volume, vols</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 176-178</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 188-190[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>"dataFileName": outputFile,
	"mergeResultShapes": { # this corresp
	"type": "bool",</code></td>
          <td>	<code>"doc": "some config entry in processo
	"output": { # this corresponding to P
	"type": "filename", # renamed to `pat</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1194-1197</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1285-1289[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean isModified = Standar
	
	for (; anExp.More(); anExp.Next()) {
	const TopoDS_Shape &aFace = anExp.Cur
	</code></td>
          <td>	<code>Standard_Integer i;
	
	for (; anIt.More(); anIt.Next()) {
	// Find a zone a sub-shape is connect
	const TopoDS_Shape &aSubShape = anIt.</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 612-618</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 421-428[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aHeight=aPC[0].Distance(aPC[1]);
	//
	gp_Ax3 aAx3=aCyl.Position();
	aAx3.SetLocation(aPc);
	//
	aInfo.SetPosition(aAx3);
	aInfo.SetLocation(aPc);
	</code></td>
          <td>	<code>const TopoDS_Solid& aSolid = TopoDS::
	//
	TopAbs_Orientation anOr = aSolid.Orie
	//
	aBB.MakeSolid(aNewSolid);
	aNewSolid.Orientation(anOr);
	//
	aExp.Init(aSolid, TopAbs_SHELL);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 672-676</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 691-696[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	aNbF=NbSubShapes(TopAbs_FACE);
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb
	</code></td>
          <td>	<code>printf(" *WIRE\n");
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);
	printf(" number of vertices: %d\n", a
	printf(" number of edges : %d\n", aNb</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 504-509</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 582-586[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>theOtherShape = OccUtils::fuseShape(r
	}
	catch (const Standard_Failure& fail)
	{
	VLOG_F(LOGLEVEL_DEBUG, "OCCT Standard
	fail.GetMessageString());</code></td>
          <td>	<code>df = dumpRelatedItems(i);
	}
	catch (const Standard_Failure& fail)
	{
	VLOG_F(LOGLEVEL_DEBUG, "OCCT Standard
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 876-879</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 879-882[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aMS2;
	//
	bHasOn=myShapesOn.IsBound(theSo1);
	const TopTools_MapOfShape& aMSOn=(bHa</code></td>
          <td>	<code>const TopTools_MapOfShape& aMSOn=(bHa
	//
	bHasIn=myShapesIn.IsBound(theSo1);
	const TopTools_MapOfShape& aMSIn=(bHa</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 67-76</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 75-84[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Iterator aIt;
	//
	myErrorStatus=0;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10;
	return;
	}
	//
	aIt.Initialize(myShape);</code></td>
          <td>	<code>GeomAbs_SurfaceType aType;
	//
	myErrorStatus=0;
	//
	if(myS.IsNull()) {
	myErrorStatus=10; // mySurface=NULL
	return;
	}
	//
	myGAS.Load(myS);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 110-112</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 134-136[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>def register_objects(self, objects):
	for o in objects.findall("Object"):
	if o.attrib["type"].find("App::Part")</code></td>
          <td>	<code>def process_object_data(self, objectD
	for o in objectData.findall("Object")
	if o.attrib["name"] in self.shapes.ke</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 523-525</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 553-555[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for ( ; whereIt.More(); whereIt.Next(
	{
	int whereID = whereIndices.FindIndex(</code></td>
          <td>	<code>for ( TopExp_Explorer subIt( whatSubS
	{
	int whatID = whatIndices.FindIndex( s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfShapeMapOfShape.hxx: line 25-44</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfPassKeyInteger.hxx: line 25-41[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfShapeMapOfSha
	#define GEOMAlgo_DataMapOfShapeMapOfSha
	
	
	#include <TopoDS_Shape.hxx>
	#include <TopTools_MapOfShape.hxx>
	#include <TopTools_ShapeMapHasher.hxx>
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	
	
	typedef NCollection_DataMap<TopoDS_Shap
	typedef GEOMAlgo_DataMapOfShapeMapOfSha
	
	#undef _NCollection_MapHasher
	
	
	
	#endif</code></td>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfPassKeyIntege
	#define GEOMAlgo_DataMapOfPassKeyIntege
	
	#include <GEOMAlgo_PassKey.hxx>
	#include <Standard_Integer.hxx>
	#include <GEOMAlgo_PassKeyMapHasher.hxx
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	
	typedef NCollection_DataMap<GEOMAlgo_Pa
	typedef GEOMAlgo_DataMapOfPassKeyIntege
	
	#undef _NCollection_MapHasher
	
	
	#endif
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 77-81</strong></td>
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 87-90[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void processItem(const std::s
	{
	const std::size_t NItems = myInputDat
	/// upper triangle for the matrix, al
	for (std::size_t j = index + 1; j < N</code></td>
          <td>	<code>virtual void process() override final
	{
	const std::size_t NItems = myInputDat
	for (std::size_t index = 0; index < N
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 534-539</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 475-480[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListOfShape aLSD;
	//
	aLSD.Append(aC);
	myImages.Bind(aCnew, aLSD);
	myOrigins.Bind(aC, aCnew);
	}</code></td>
          <td>	<code>TopTools_ListOfShape aLW;
	//
	aLW.Append(aW);
	myImages.Bind(newWire, aLW);
	myOrigins.Bind(aW, newWire);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 433-435</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 241-243[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(</code></td>
          <td>	<code>const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);
	iErr=GEOMAlgo_SurfaceTools::GetState(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 140-143</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 364-367[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aPln=myGAS[i-1].Plane();
	aPos=aPln.Position();
	aP=aPos.Location();
	aD=aPos.Direction();</code></td>
          <td>	<code>aSphere=aGAS.Sphere();
	aP0=aSphere.Location();
	aAx3=aSphere.Position();
	aR1=aSphere.Radius();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 940-942</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1319-1321[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (; anIter.More(); anIter.Next())
	aMapSubShapes.Add(anIter.Value());
	}</code></td>
          <td>	<code>for (; anExp.More(); anExp.Next()) {
	aLastZoneBound.Add(anExp.Current());
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 194-198</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 175-178[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer GEOMAlgo_AlgoTools::Bu
	(const TopoDS_Edge& aEold,
	const TopoDS_Edge& aEnew,
	const TopoDS_Face& aF,
	const Handle(IntTools_Context)& aCtx)</code></td>
          <td>	<code>static Standard_Integer BuildPCurveFo
	const TopoDS_Edge& aEnew,
	const TopoDS_Face& aF,
	const Handle(IntTools_Context)& aCtx)
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 657-660</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 140-143[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aElips=aGAC.Ellipse();
	aP=aElips.Location();
	aAx2=aElips.Position();
	aR1=aElips.MajorRadius();</code></td>
          <td>	<code>aPln=myGAS[i-1].Plane();
	aPos=aPln.Position();
	aP=aPos.Location();
	aD=aPos.Direction();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 310-320</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 153-162[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aMS1, aMS2
	TopTools_DataMapOfShapeListOfShape aD
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_ListIteratorOfListOfShape aI
	GEOMAlgo_CoupleOfShapes aCS;
	//
	GEOMAlgo_BoxBndTreeSelector aSelector
	GEOMAlgo_BoxBndTree aBBTree;
	NCollection_UBTreeFiller <Standard_In
	//
	myErrorStatus=0;</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_DataMapOfShapeListOfShape aM
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	GEOMAlgo_BndSphereTreeSelector aSelec
	GEOMAlgo_BndSphereTree aBBTree;
	NCollection_UBTreeFiller <Standard_In
	//
	myErrorStatus=0;
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 104-117</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 103-116[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	virtual void CheckResult() ;
	
	Standard_EXPORT
	void MakeVertices() ;
	
	Standard_EXPORT
	void MakeEdges() ;
	
	Standard_EXPORT
	void MakeFaces() ;
	
	Standard_EXPORT
	void MakeShapes(const TopAbs_ShapeEnu</code></td>
          <td>	<code>Standard_EXPORT
	virtual void CheckData() ;
	
	Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryWriter.h: line 59-61</strong></td>
        <td style="text-align:center"><strong>src/PPP/Writer.h: line 24-26       [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (not fs::path(file_name).is_absolu
	file_name = dataStoragePath(file_name
	if (file_name.size())</code></td>
          <td>	<code>if (!fs::path(file_name).is_absolute(
	file_name = dataStoragePath(file_name
	if (file_name.size() && myOutputData-</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 160-164</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 176-180[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>myModified.Clear();
	myNew.Clear();
	myMapRemoved.Clear();
	myMapModified.Clear();
	myMapNewShapeAnc.Clear();</code></td>
          <td>	<code>myIterator.Clear();
	myShapesIn.Clear();
	myShapesOn.Clear();
	myShapesInclusive.Clear();
	myMapShapePnt.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 772-774</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 360-363[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aNbSE=0;
	aExp.Init(aF, TopAbs_EDGE);
	for (; aExp.More(); aExp.Next()) {
	</code></td>
          <td>	<code>bIsConformState=Standard_False;
	//
	aExp.Init(aE, TopAbs_VERTEX);
	for (; aExp.More(); aExp.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 742-747</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 888-891[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedDataMapOfShapeListOfS
	//
	iErr=1;
	//
	aNbE=aMPKLE.Extent();
	for (i=1; i<=aNbE; ++i) {</code></td>
          <td>	<code>iCntOut=0;
	bFound=Standard_False;
	aNbS2=aMS2.Extent();
	for (i=1; i<=aNbS2; ++i) {
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 421-428</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 612-618[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Solid& aSolid = TopoDS::
	//
	TopAbs_Orientation anOr = aSolid.Orie
	//
	aBB.MakeSolid(aNewSolid);
	aNewSolid.Orientation(anOr);
	//
	aExp.Init(aSolid, TopAbs_SHELL);</code></td>
          <td>	<code>aHeight=aPC[0].Distance(aPC[1]);
	//
	gp_Ax3 aAx3=aCyl.Position();
	aAx3.SetLocation(aPc);
	//
	aInfo.SetPosition(aAx3);
	aInfo.SetLocation(aPc);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.hxx: line 85-94</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.hxx: line 83-92[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>void Clear() ;
	
	Standard_EXPORT
	Standard_Integer NbIds() const;
	
	Standard_EXPORT
	Standard_Boolean IsEqual(const GEOMAl
	
	Standard_EXPORT
	Standard_Integer HashCode(const Stand</code></td>
          <td>	<code>void SetIds(const TColStd_ListOfInteg
	
	Standard_EXPORT
	Standard_Integer NbIds() const;
	
	Standard_EXPORT
	Standard_Boolean IsEqual(const GEOMAl
	
	Standard_EXPORT
	Standard_Integer HashCode(const Stand</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 277-281</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 684-688[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aNbSp==1) {
	aF=*((TopoDS_Face*)&aLSp.First());
	}
	//
	iErr=GEOMAlgo_AlgoTools::PntInFace(aF</code></td>
          <td>	<code>if (aIt.More()) {
	aVD=*((TopoDS_Vertex*)&aIt.Value());
	}
	//
	aPD=BRep_Tool::Pnt(aVD);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 59-74</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 64-79[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_BuilderShape()
	{
	myTolerance=0.0001;
	}
	//=====================================
	//function : ~GEOMAlgo_Gluer2
	//purpose :
	//=====================================
	GEOMAlgo_Gluer2::~GEOMAlgo_Gluer2()
	{
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::Clear()</code></td>
          <td>	<code>GEOMAlgo_Algo()
	{
	myTolerance=0.0001;
	}
	//=====================================
	//function : ~
	//purpose :
	//=====================================
	GEOMAlgo_ShapeInfoFiller::~GEOMAlgo_Sha
	{
	}
	//=====================================
	//function : SetTolerance
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::SetToler</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 106-110</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 449-451[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType2=aS2.ShapeType();
	//
	// 1. A point on shape #2 -> aP2
	if (myMapShapePnt.IsBound(aS2)) {
	aP2=myMapShapePnt.Find(aS2);</code></td>
          <td>	<code>const TopoDS_Shape& aE=aItS.Value();
	if (myOrigins.IsBound(aE)) {
	aEnew=myOrigins.Find(aE);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 723-733</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 733-743[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : FillNbSubshapes
	//purpose :
	//=====================================
	void GEOMAlgo_ShapeInfoFiller::FillNbSu
	GEOMAlgo_ShapeInfo& aInfo)
	{
	myErrorStatus=0;
	//
	Standard_Integer i, aNb, aNbS;</code></td>
          <td>	<code>}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	myErrorStatus=0;
	//
	Standard_Integer j, aNbNodes, aIndex,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 152-160</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 223-232[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapOfShape aMVProcessed;
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_DataMapOfShapeListOfShape aM
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	GEOMAlgo_BndSphereTreeSelector aSelec
	GEOMAlgo_BndSphereTree aBBTree;
	NCollection_UBTreeFiller <Standard_In
	</code></td>
          <td>	<code>TopTools_IndexedMapOfShape aMV, aMVPr
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_DataMapOfShapeListOfShape aM
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	//
	GEOMAlgo_BndSphereTreeSelector aSelec
	GEOMAlgo_BndSphereTree aBBTree;
	NCollection_UBTreeFiller <Standard_In</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1233-1235</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1245-1247[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	
	for (;anIter.More(); anIter.Next()) {</code></td>
          <td>	<code>NCollection_List<TopTools_ListOfShape
	
	for (;anIter.More(); anIter.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 44-44</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 132-132[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>this_geomPipeline = os.path.dirname(o</code></td>
          <td>	<code>lib_path = os.path.dirname(os.path.di</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 223-232</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 152-160[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_IndexedMapOfShape aMV, aMVPr
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_DataMapOfShapeListOfShape aM
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	//
	GEOMAlgo_BndSphereTreeSelector aSelec
	GEOMAlgo_BndSphereTree aBBTree;
	NCollection_UBTreeFiller <Standard_In</code></td>
          <td>	<code>TopTools_MapOfShape aMVProcessed;
	TopTools_ListIteratorOfListOfShape aI
	TopTools_DataMapIteratorOfDataMapOfSh
	TopTools_DataMapOfShapeListOfShape aM
	GEOMAlgo_IndexedDataMapOfIntegerShape
	GEOMAlgo_IndexedDataMapOfShapeBndSphe
	GEOMAlgo_BndSphereTreeSelector aSelec
	GEOMAlgo_BndSphereTree aBBTree;
	NCollection_UBTreeFiller <Standard_In
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryProcessor.h: line 159-161</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 87-90[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>myShapes = myInputData->get<ItemConta
	myShapeIDs = myInputData->get<VectorT
	myShapeErrors = myInputData->get<MapT
	</code></td>
          <td>	<code>if (myInputData->contains("myShapeOri
	myShapeOrientedBoundBoxes = myInputDa
	
	myGeometryProperties = myInputData->g</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 72-80</strong></td>
        <td style="text-align:center"><strong>src/PPP/Reader.h: line 23-28       [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>MapType<ItemHashType, std::string> my
	// MapType<ItemHashType, ItemHashType
	// MapType<ItemHashType, bool> mySupp
	/// @}
	
	public:
	virtual void process() override
	{
	std::string file_name = myConfig["dat</code></td>
          <td>	<code>VectorType<std::string> myFilePaths;
	
	public:
	virtual void process() override
	{
	std::string file_name = myConfig["dat
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfShapePnt.hxx: line 25-44</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_DataMapOfShapeMapOfShape.hxx: line 25-44[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfShapePnt_Head
	#define GEOMAlgo_DataMapOfShapePnt_Head
	
	
	#include <TopoDS_Shape.hxx>
	#include <gp_Pnt.hxx>
	#include <TopTools_ShapeMapHasher.hxx>
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	#include <gp_Pnt.hxx>
	
	typedef NCollection_DataMap<TopoDS_Shap
	typedef GEOMAlgo_DataMapOfShapePnt::Ite
	
	#undef _NCollection_MapHasher
	
	
	
	#endif</code></td>
          <td>	<code>#ifndef GEOMAlgo_DataMapOfShapeMapOfSha
	#define GEOMAlgo_DataMapOfShapeMapOfSha
	
	
	#include <TopoDS_Shape.hxx>
	#include <TopTools_MapOfShape.hxx>
	#include <TopTools_ShapeMapHasher.hxx>
	
	#define _NCollection_MapHasher
	#include <NCollection_DataMap.hxx>
	
	
	typedef NCollection_DataMap<TopoDS_Shap
	typedef GEOMAlgo_DataMapOfShapeMapOfSha
	
	#undef _NCollection_MapHasher
	
	
	
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 104-110</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 118-124[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_PassKeyShape::SetShapes
	const TopoDS_Shape& aS2)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);</code></td>
          <td>	<code>const TopoDS_Shape& aS2,
	const TopoDS_Shape& aS3)
	{
	TopTools_ListOfShape aLS;
	//
	aLS.Append(aS1);
	aLS.Append(aS2);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 657-659</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 670-671[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>this->myCompounds[xp.Current().HashCo
	// solids should have been extracted
	}</code></td>
          <td>	<code>this->myOtherShapes[xp.Current().Hash
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 55-59</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 65-69[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_PassKey::GEOMAlgo_PassKey(co
	{
	myNbIds=aOther.myNbIds;
	mySum=aOther.mySum;
	myMap=aOther.myMap;</code></td>
          <td>	<code>GEOMAlgo_PassKey& GEOMAlgo_PassKey::A
	{
	myNbIds=aOther.myNbIds;
	mySum=aOther.mySum;
	myMap=aOther.myMap;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1299-1300</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 660-661[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i = 1; i <= aNbZones; ++i) {
	if (!aMapIndices.Contains(i)) {</code></td>
          <td>	<code>for (j=j1; j<=j2; ++j) {
	if (!aMBN.Contains(j)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Context.cpp: line 112-120</strong></td>
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 87-95[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>setupLogger(myConfig);
	}
	else
	{
	std::cout << "configuration json file
	<< "` does not exists, terminate chec
	std::terminate();
	}
	}</code></td>
          <td>	<code>setConfig(Context::config()); // appl
	}
	else
	{
	std::cout << "configuration json file
	<< config_filename << "\n , program t
	std::terminate();
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 155-157</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 77-79  [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>void read(std::string file_name, cons
	{
	if (Utilities::hasFileExt(file_name,</code></td>
          <td>	<code>void saveShape(const TopoDS_Shape& sh
	{
	if (Utilities::hasFileExt(file_name,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 17-25</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 32-39[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>from pppStartPipeline import ppp_start_
	from detectFreeCAD import append_freeca
	
	append_freecad_mod_path()
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)</code></td>
          <td>	<code>```python
	from detectFreeCAD import append_freeca
	append_freecad_mod_path()
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 420-423</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 565-568[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aE1)) {
	continue;
	}</code></td>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aE1)) {
	continue;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Reader.h: line 23-28</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 72-80[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>VectorType<std::string> myFilePaths;
	
	public:
	virtual void process() override
	{
	std::string file_name = myConfig["dat
	
	
	</code></td>
          <td>	<code>MapType<ItemHashType, std::string> my
	// MapType<ItemHashType, ItemHashType
	// MapType<ItemHashType, bool> mySupp
	/// @}
	
	public:
	virtual void process() override
	{
	std::string file_name = myConfig["dat</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 146-159</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 84-98[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer2::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	CheckData();
	if (myErrorStatus) {
	return;
	}
	</code></td>
          <td>	<code>}
	//=====================================
	//function : Perform
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::Perform()
	{
	myErrorStatus=0;
	myWarningStatus=0;
	//
	// 1.
	CheckData();
	if(myErrorStatus) {
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 21-22</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 188-189[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>built_module_dir = os.path.dirname(th
	if os.path.exists(os.path.abspath(bui</code></td>
          <td>	<code>pymod_path = os.path.dirname(cmod_pat
	if os.path.exists(pymod_path):</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 411-414</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 103-106[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType1=myGAS.GetType();
	//
	TopExp::MapShapes(myShape, TopAbs_FAC
	aNbF=aM.Extent();</code></td>
          <td>	<code>const TopoDS_Shape& aObj=aLS.First();
	//
	TopExp::MapShapes(aObj, TopAbs_FACE,
	aNbF=aM.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 88-91</strong></td>
        <td style="text-align:center"><strong>src/python/CMakeLists.txt: line 44-47[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>else()
	find_package(OpenCasCade REQUIRED) #
	if(OCC_FOUND)
	include_directories(${OCC_INCLUDE_DIR</code></td>
          <td>	<code>list(APPEND CMAKE_MODULE_PATH "${PARE
	find_package(OpenCasCade REQUIRED) #
	if(OCC_FOUND)
	include_directories(${OCC_INCLUDE_DIR</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 565-568</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 613-616[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aE1)) {
	continue;
	}</code></td>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aE1)) {
	continue;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 132-132</strong></td>
        <td style="text-align:center"><strong>src/python/GeomTestBase.py: line 44-44[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>lib_path = os.path.dirname(os.path.di</code></td>
          <td>	<code>this_geomPipeline = os.path.dirname(o</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 103-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 411-414[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aObj=aLS.First();
	//
	TopExp::MapShapes(aObj, TopAbs_FACE,
	aNbF=aM.Extent();</code></td>
          <td>	<code>aType1=myGAS.GetType();
	//
	TopExp::MapShapes(myShape, TopAbs_FAC
	aNbF=aM.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 169-180</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 402-411[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType=aS.ShapeType();
	switch(aType) {
	//
	case TopAbs_VERTEX:
	FillVertex(aS);
	break;
	//
	case TopAbs_EDGE:
	FillEdge(aS);
	break;
	//
	case TopAbs_FACE:</code></td>
          <td>	<code>aShape.Orientation(TopAbs_FORWARD);
	
	switch(theType) {
	case TopAbs_EDGE:
	processEdge(aShape);
	break;
	case TopAbs_WIRE:
	processWire(aShape);
	break;
	case TopAbs_FACE:
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 152-157</strong></td>
        <td style="text-align:center"><strong>src/python/geomPipeline.py: line 254-259[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>"value": globalTolerance,
	"unit": "mm",
	"range": [1e-5, 10],
	"doc": "this should be bigger than th
	},
	"scriptFolder": { # needed by C++ sid</code></td>
          <td>	<code>"value": 0.001,
	"unit": "mm",
	"range": [1e-5, 1],
	"doc": "tolerance for boolean operati
	},
	"clearanceThreshold": {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 26-56</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 26-53[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_Gluer2_HeaderFile
	#define _GEOMAlgo_Gluer2_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopTools_DataMapOfShapeListOf
	#include <TopTools_DataMapOfShapeShape.
	
	#include <GEOMAlgo_GluerAlgo.hxx>
	#include <GEOMAlgo_BuilderShape.hxx>
	#include <GEOMAlgo_GlueDetector.hxx>
	#include <GEOMAlgo_CoupleOfShapes.hxx>
	#include <GEOMAlgo_ListOfCoupleOfShapes
	
	//=====================================
	//class : GEOMAlgo_Gluer2
	//purpose :
	//=====================================
	class GEOMAlgo_Gluer2 : public GEOMAlgo
	public GEOMAlgo_BuilderShape {
	public:
	
	Standard_EXPORT
	GEOMAlgo_Gluer2();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_Gluer2();</code></td>
          <td>	<code>#ifndef _GEOMAlgo_GlueDetector_HeaderFi
	#define _GEOMAlgo_GlueDetector_HeaderFi
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_IndexedDataMapOfShap
	
	#include <GEOMAlgo_GluerAlgo.hxx>
	#include <GEOMAlgo_Algo.hxx>
	#include <GEOMAlgo_PassKeyShape.hxx>
	
	//=====================================
	//function : GEOMAlgo_GlueDetector
	//purpose :
	//=====================================
	class GEOMAlgo_GlueDetector : public GE
	public GEOMAlgo_Algo
	{
	public:
	Standard_EXPORT
	GEOMAlgo_GlueDetector();
	
	Standard_EXPORT virtual
	~GEOMAlgo_GlueDetector();
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/test_collision.py: line 90-92</strong></td>
        <td style="text-align:center"><strong>src/python/test_collision.py: line 113-115[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>def validate_geometry(self, shape):
	print("len(shape.Faces)", len(shape.F
	print("len(shape.Solids) = ", len(sha</code></td>
          <td>	<code>def validate_geometry(self, shape, su
	print("len(shape.Faces)", len(shape.F
	print("len(shape.Solids) = ", len(sha</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1119-1128</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 233-243[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>myShapesIn.Bind(aS1, aMS);
	}
	}
	//=====================================
	//function : FillShapesOn
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::FillShapesOn(
	const TopoDS_Shape& aS2)
	{
	</code></td>
          <td>	<code>aBB.Add(myResult, aSR);
	}
	}
	
	//=====================================
	//function : AddInternalShapes
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::AddInternalS
	const TopTools_IndexedMapOfShape& aMS
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 520-525</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 529-534[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopExp_Explorer Ex(shape, TopAbs_EDGE
	while (Ex.More())
	{
	edgeCount++;
	Ex.Next();
	}</code></td>
          <td>	<code>TopExp_Explorer Ex(shape, TopAbs_FACE
	while (Ex.More())
	{
	faceCount++;
	Ex.Next();
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 49-54</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 67-72[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_PassKeyShape::GEOMAlgo_PassK
	{
	myUpper=432123;
	myNbIds=aOther.myNbIds;
	mySum=aOther.mySum;
	myMap=aOther.myMap;</code></td>
          <td>	<code>GEOMAlgo_PassKeyShape& GEOMAlgo_PassK
	{
	myUpper=432123;
	myNbIds=aOther.myNbIds;
	mySum=aOther.mySum;
	myMap=aOther.myMap;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 65-67</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 336-338[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (TopExp_Explorer i(aShape, TopAbs
	{
	aFaceList.Append(TopoDS::Face(i.Curre</code></td>
          <td>	<code>for (TopExp_Explorer anExp(loaded_sha
	{
	shapes.push_back(anExp.Current());</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 650-650</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 655-655[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (xp.Init(aShape, TopAbs_SHELL); x</code></td>
          <td>	<code>for (xp.Init(aShape, TopAbs_COMPOUND)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 106-119</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1178-1191[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	return Standard_True;
	}
	
	//=====================================
	//function : GetInPlaceOld
	//purpose :
	//=====================================
	Standard_Integer GEOMAlgo_GetInPlaceAPI
	(const TopoDS_Shape &theWhere,
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac
	{</code></td>
          <td>	<code>}
	
	return isModified;
	}
	
	//=====================================
	//function : removeCommonFaces
	//purpose :
	//=====================================
	Standard_Boolean GEOMAlgo_Extractor::re
	(const TopoDS_Shape &theShell,
	const TopTools_IndexedMapOfShape &the
	TopTools_ListOfShape &theNewShells)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 543-546</strong></td>
        <td style="text-align:center"><strong>src/PPP/Utilities.cpp: line 30-32  [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (size_t i = 0; i < shapes.size();
	{
	// TODO: should also compare boundbox
	if (OccUtils::floatEqual(volume, vols</code></td>
          <td>	<code>for (size_t j = 0; j < extension.leng
	{
	if (std::tolower(ext[j]) != std::tolo
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_2.cxx: line 102-106</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 462-467[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>bToReverse=BOPTools_AlgoTools::IsSpli
	if (bToReverse) {
	aSim.Reverse();
	}
	}
	</code></td>
          <td>	<code>Standard_Boolean bIsToReverse=
	GEOMAlgo_AlgoTools::IsSplitToReverse(
	if (bIsToReverse) {
	aER.Reverse();
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/CMakeLists.txt: line 44-47</strong></td>
        <td style="text-align:center"><strong>src/CMakeLists.txt: line 88-91     [25]</strong></td>
        </tr>
        <tr>
          <td>	<code>list(APPEND CMAKE_MODULE_PATH "${PARE
	find_package(OpenCasCade REQUIRED) #
	if(OCC_FOUND)
	include_directories(${OCC_INCLUDE_DIR</code></td>
          <td>	<code>else()
	find_package(OpenCasCade REQUIRED) #
	if(OCC_FOUND)
	include_directories(${OCC_INCLUDE_DIR</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 92-102</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 94-104[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean IsDeleted(const Topo
	
	Standard_EXPORT
	const TopTools_DataMapOfShapeListOfSh
	
	Standard_EXPORT
	const TopTools_DataMapOfShapeShape& O
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;</code></td>
          <td>	<code>virtual void Perform() ;
	
	Standard_EXPORT
	const TopTools_ListOfShape& Shapes()
	
	Standard_EXPORT
	const GEOMAlgo_IndexedDataMapOfShapeS
	
	protected:
	Standard_EXPORT
	virtual void CheckData() ;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 138-139</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 140-141[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>if o.attrib["name"] in self.parts.key
	self.process_group(o, self.parts)</code></td>
          <td>	<code>elif o.attrib["name"] in self.groups.
	self.process_group(o, self.groups)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 254-257</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 86-89[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aType==TopAbs_FACE)) {
	myErrorStatus=21;// non-brep shapes</code></td>
          <td>	<code>aType==GeomAbs_Sphere)) {
	myErrorStatus=11; // unallowed surfac</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 241-243</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 343-345[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Vertex& aV=TopoDS::Verte
	aP=BRep_Tool::Pnt(aV);
	iErr=GEOMAlgo_SurfaceTools::GetState(</code></td>
          <td>	<code>bInfU1=Precision::IsNegativeInfinite(
	bInfU2=Precision::IsPositiveInfinite(
	bInfV1=Precision::IsNegativeInfinite(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GluerAlgo.cxx: line 99-107</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeAlgo.cxx: line 53-61[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_GluerAlgo::SetContext(con
	{
	myContext=theContext;
	}
	//=====================================
	//function : Context
	//purpose :
	//=====================================
	const Handle(IntTools_Context)& GEOMAlg</code></td>
          <td>	<code>void GEOMAlgo_ShapeAlgo::SetContext(con
	{
	myContext=theContext;
	}
	//=====================================
	//function : Context
	//purpose :
	//=====================================
	const Handle(IntTools_Context)& GEOMAlg</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.hxx: line 26-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 26-56[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>#ifndef _GEOMAlgo_GlueDetector_HeaderFi
	#define _GEOMAlgo_GlueDetector_HeaderFi
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopTools_ListOfShape.hxx>
	#include <TopTools_IndexedDataMapOfShap
	
	#include <GEOMAlgo_GluerAlgo.hxx>
	#include <GEOMAlgo_Algo.hxx>
	#include <GEOMAlgo_PassKeyShape.hxx>
	
	//=====================================
	//function : GEOMAlgo_GlueDetector
	//purpose :
	//=====================================
	class GEOMAlgo_GlueDetector : public GE
	public GEOMAlgo_Algo
	{
	public:
	Standard_EXPORT
	GEOMAlgo_GlueDetector();
	
	Standard_EXPORT virtual
	~GEOMAlgo_GlueDetector();
	
	
	</code></td>
          <td>	<code>#ifndef _GEOMAlgo_Gluer2_HeaderFile
	#define _GEOMAlgo_Gluer2_HeaderFile
	
	#include <Standard.hxx>
	#include <Standard_Macro.hxx>
	#include <Standard_Boolean.hxx>
	
	#include <TopAbs_ShapeEnum.hxx>
	
	#include <TopTools_DataMapOfShapeListOf
	#include <TopTools_DataMapOfShapeShape.
	
	#include <GEOMAlgo_GluerAlgo.hxx>
	#include <GEOMAlgo_BuilderShape.hxx>
	#include <GEOMAlgo_GlueDetector.hxx>
	#include <GEOMAlgo_CoupleOfShapes.hxx>
	#include <GEOMAlgo_ListOfCoupleOfShapes
	
	//=====================================
	//class : GEOMAlgo_Gluer2
	//purpose :
	//=====================================
	class GEOMAlgo_Gluer2 : public GEOMAlgo
	public GEOMAlgo_BuilderShape {
	public:
	
	Standard_EXPORT
	GEOMAlgo_Gluer2();
	
	Standard_EXPORT
	virtual ~GEOMAlgo_Gluer2();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 402-411</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 169-180[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>aShape.Orientation(TopAbs_FORWARD);
	
	switch(theType) {
	case TopAbs_EDGE:
	processEdge(aShape);
	break;
	case TopAbs_WIRE:
	processWire(aShape);
	break;
	case TopAbs_FACE:
	
	</code></td>
          <td>	<code>aType=aS.ShapeType();
	switch(aType) {
	//
	case TopAbs_VERTEX:
	FillVertex(aS);
	break;
	//
	case TopAbs_EDGE:
	FillEdge(aS);
	break;
	//
	case TopAbs_FACE:</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 106-111</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 241-247[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeomAdaptor_Surface aGAS;
	//
	aState=TopAbs_UNKNOWN;
	aGAS.Load(aSurf);
	//
	iErr=GEOMAlgo_SurfaceTools::GetState(
	</code></td>
          <td>	<code>aTol=1.e-7;
	//
	// 1. bUClosed - direction of closene
	//
	aES=aEold;
	aES.Orientation(TopAbs_FORWARD);
	aC2DS1=BRep_Tool::CurveOnSurface(aES,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 760-764</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 425-428[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_ShapeInfo& aInfo=myMapInfo.C
	aInfo.SetKindOfDef(GEOMAlgo_KD_ARBITR
	//
	aKS=aInfo.KindOfShape();
	if (aKS!=GEOMAlgo_KS_TORUS) {</code></td>
          <td>	<code>aS=BRep_Tool::Surface(aF);
	aGAS.Load(aS);
	aType2=aGAS.GetType();
	if (aType2!=aType1) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 16-17</strong></td>
        <td style="text-align:center"><strong>src/python/pppStartPipeline.py: line 37-38[25]</strong></td>
        </tr>
        <tr>
          <td>	<code>this_file_folder = os.path.dirname(os
	built_module_dir = os.path.dirname(th</code></td>
          <td>	<code>this_file_folder = os.path.dirname(os
	ppp_geom_executable = os.path.join(th</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 124-125</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 85-86[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Handle(BRepCheck_Result)& resul
	const BRepCheck_ListOfStatus& status</code></td>
          <td>	<code>const BVH_Vec3d& aP1 = aBvh->MinPoint
	const BVH_Vec3d& aP2 = aBvh->MaxPoint</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 955-958</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 116-118[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aFFWD.Orientation(TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFFWD, aLoc);
	bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP</code></td>
          <td>	<code>aTol=BRep_Tool::Tolerance(aFF);
	aS=BRep_Tool::Surface(aFF, aLoc);
	bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1089-1094</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.cxx: line 55-61[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (theMapFence.Add(theShape)) {
	Standard_Boolean isKept = Standard_Tr
	
	if (myMapRemoved.Contains(theShape))
	myRemoved.Append(theShape);
	isKept = Standard_False;
	</code></td>
          <td>	<code>Standard_Boolean GEOMAlgo_BndSphereTr
	{
	Standard_Boolean bRet=Standard_False;
	//
	if (myFence.Add(aIndex)) {
	myIndices.Append(aIndex);
	bRet=!bRet;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/analyzeDumpFiles.py: line 32-40</strong></td>
        <td style="text-align:center"><strong>src/python/detectFreeCAD.py: line 33-39[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>from detectFreeCAD import append_freeca
	
	append_freecad_mod_path()
	
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)</code></td>
          <td>	<code>from detectFreeCAD import append_freeca
	append_freecad_mod_path()
	try:
	import FreeCAD
	except ImportError:
	print("freecad is not installed or de
	sys.exit(0)
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 99-104</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 126-131[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const Standard_Real aTol,
	TopTools_ListOfShape& aLESD,
	const Handle(IntTools_Context)& aCtx)
	
	Standard_EXPORT
	static void PointOnShape(const TopoDS</code></td>
          <td>	<code>const TopoDS_Shape& aS,
	gp_Pnt& aP2,
	const Handle(IntTools_Context)& aCtx)
	
	Standard_EXPORT
	static void CorrectTolerances(const T</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 137-142</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 225-230[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aGAS1.Load(aS1);
	aST1=aGAS1.GetType();
	bRet=(aST1==aST);
	//
	return bRet;
	}</code></td>
          <td>	<code>aGAS1.Load(aS1);
	aST1=aGAS1.GetType();
	bRet=(aST1==GeomAbs_Plane);
	//
	return bRet;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BuilderShape.cxx: line 54-65</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1133-1143[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>return myShape;
	}
	//
	//=====================================
	//function : Generated
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_
	{
	myHistShapes.Clear();
	return myHistShapes;
	}</code></td>
          <td>	<code>return myGenerated;
	}
	//=====================================
	//function : Generated
	//purpose :
	//=====================================
	const TopTools_ListOfShape& GEOMAlgo_Gl
	{
	myGenerated.Clear();
	return myGenerated;
	}
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/BoundBoxBuilder.h: line 41-45</strong></td>
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 60-69[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	virtual void prepareOutput() override
	{
	myOutputData->emplace("myShapeBoundBo
	
	
	
	
	</code></td>
          <td>	<code>}
	
	/**
	* \brief preparing work in serial mod
	*/
	virtual void prepareOutput() override
	{
	// todo: if called in pipeline explic
	// myCouplingMatrix.writeMatrixMarket
	myOutputData->emplace("myCouplingMatr</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 186-194</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 122-130[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopAbs_State aState;
	gp_Pnt aP;
	gp_Pnt2d aP2D;
	TopoDS_Face aF;
	//
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();</code></td>
          <td>	<code>Standard_Integer i, iBeg, iEnd, aNbVV
	Standard_Real aTol;
	TopAbs_State aSt;
	TopAbs_ShapeEnum aType;
	gp_Pnt aP3D;
	//
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 113-118</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 266-272[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=12; // wrong number of
	return;
	}
	//
	for (i=1; i<=aNbF; ++i) {
	const TopoDS_Face& aF=TopoDS::Face(aM
	</code></td>
          <td>	<code>myErrorStatus=31;
	return;
	}
	//
	// 1.
	for (i=1; i<=aNbS1; ++i) {
	const TopoDS_Shape& aSS1=aMS1(i);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1153-1154</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 738-741[24]</strong></td>
        </tr>
        <tr>
          <td>	<code></code></td>
          <td>	<code>myShapeType==TopAbs_SOLID)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 195-197</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 783-786[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSkey=aMC.FindKey
	const TopTools_IndexedMapOfShape& aM=
	aLSX.Clear();
	</code></td>
          <td>	<code>const TopoDS_Shape& aE1=aMEToAdd.Find
	const TopTools_ListOfShape& aLE=aMETo
	//
	aPKE1.SetShapes(aE1);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 546-552</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 597-603[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer j, j1, j2, k, n[4],
	TopLoc_Location aLoc;
	Handle(Poly_Triangulation) aTRF;
	TColStd_MapOfInteger aMBN;
	GEOMAlgo_DataMapOfPassKeyInteger aMPK
	GEOMAlgo_DataMapIteratorOfDataMapOfPa
	gp_Pnt aP, aP1, aP2;</code></td>
          <td>	<code>Standard_Integer j, j1, j2, k, n[4],
	TopLoc_Location aLoc;
	Handle(Poly_Triangulation) aTRF;
	TColStd_MapOfInteger aMBN;
	GEOMAlgo_DataMapOfPassKeyInteger aMPK
	GEOMAlgo_DataMapIteratorOfDataMapOfPa
	gp_Pnt aP, aP1, aP2;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 111-119</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 126-134[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes
	const TopoDS_Shape& aS2,
	const TopoDS_Shape& aS3)</code></td>
          <td>	<code>SetShapes(aLS);
	}
	//=====================================
	//function :SetShapes
	//purpose :
	//=====================================
	void GEOMAlgo_PassKeyShape::SetShapes
	const TopoDS_Shape& aS2,
	const TopoDS_Shape& aS3,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 50-53</strong></td>
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 56-60      [24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Processor::init();
	Reader::init();
	Writer::init();
	CouplingMatrixBuilder::init();
	</code></td>
          <td>	<code>GeometryProcessor::init();
	GeometryReader::init();
	GeometryWriter::init();
	
	GeometryPropertyBuilder::init();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 221-234</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 921-935[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	return 0;
	}
	
	//=====================================
	//function : GetNormal
	//purpose :
	//=====================================
	gp_Vec GEOMAlgo_GetInPlaceAPI::GetNorma
	(const TopoDS_Face &theFace,
	const BRepExtrema_DistShapeShape &the
	{
	gp_Vec defaultNorm(1,0,0); // to have
	</code></td>
          <td>	<code>}
	
	return aResult;
	}
	
	//=====================================
	//function : getShapeFromSubShapes
	//purpose :
	//=====================================
	TopoDS_Shape GEOMAlgo_Extractor::getSha
	(const TopoDS_Shape &theShape,
	const TopTools_ListOfShape &theSubSha
	{
	// Fill the map of sub-shapes.
	TopTools_ListIteratorOfListOfShape an</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 300-313</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.hxx: line 328-343[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean removeCommonFaces
	(const TopoDS_Shape &theShell,
	const TopTools_IndexedMapOfShape &the
	TopTools_ListOfShape &theNewShells);
	
	/**
	* \brief This method creates wires fr
	*
	* \param theWire the input wire.
	* \param theListListEdges the list of
	* on output.
	* \param theWires the list of created
	*/
	void makeWires(const TopoDS_Shape &th
	
	</code></td>
          <td>	<code>void groupViaBounds(const TopoDS_Shap
	const TopTools_ListOfShape &theSubSha
	TopTools_ListOfShape &theNewShapes);
	
	/**
	* \brief This method returns the list
	* from theShape. It performs recursiv
	* theModifShapes is not cleared at fi
	* to TopAbs_SHAPE (default value) all
	* otherwise shapes of particular type
	*
	* \param theShape the shape examined.
	* \param theModifShapes the list of m
	* \param theShapeType the shape type
	*/
	void getModified(const TopoDS_Shape &</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 597-603</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 546-552[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer j, j1, j2, k, n[4],
	TopLoc_Location aLoc;
	Handle(Poly_Triangulation) aTRF;
	TColStd_MapOfInteger aMBN;
	GEOMAlgo_DataMapOfPassKeyInteger aMPK
	GEOMAlgo_DataMapIteratorOfDataMapOfPa
	gp_Pnt aP, aP1, aP2;</code></td>
          <td>	<code>Standard_Integer j, j1, j2, k, n[4],
	TopLoc_Location aLoc;
	Handle(Poly_Triangulation) aTRF;
	TColStd_MapOfInteger aMBN;
	GEOMAlgo_DataMapOfPassKeyInteger aMPK
	GEOMAlgo_DataMapIteratorOfDataMapOfPa
	gp_Pnt aP, aP1, aP2;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 1126-1131</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 442-447[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aSnew=myOrigins.F
	if (!aSnew.IsSame(aS)) {
	myGenerated.Append(aSnew);
	}
	}
	}</code></td>
          <td>	<code>const TopoDS_Shape& aSx=aMx(i);
	if (!aMS.Contains(aSx)) {
	mySolidsAlone.Append(aSx);
	}
	}
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 34-37</strong></td>
        <td style="text-align:center"><strong>src/test/UtilitiesTest.cpp: line 43-46[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>TEST_CASE("UtilitiesTest", "HasFileExte
	{
	auto file_name = std::string("./tmp/h
	REQUIRE(Utilities::hasFileExt(file_na</code></td>
          <td>	<code>TEST_CASE("TimeStampTest", "TimeStampFi
	{
	auto file_name = std::string("./tmp/h
	REQUIRE(Utilities::timeStampFileName(</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.hxx: line 80-86</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.hxx: line 126-133[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>virtual void CheckData() ;
	
	Standard_EXPORT
	void FillNbSubShapes(const TopoDS_Sha
	
	Standard_EXPORT
	void FillSubShapes(const TopoDS_Shape
	</code></td>
          <td>	<code>void InnerTolerance() ;
	
	Standard_EXPORT
	void EdgePassKey(const TopoDS_Edge& a
	GEOMAlgo_PassKeyShape& aPK) ;
	
	Standard_EXPORT
	void FacePassKey(const TopoDS_Face& a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 236-239</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 115-118[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(not internalMul</code></td>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(false);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 61-64</strong></td>
        <td style="text-align:center"><strong>src/PPP/PipelineController.cpp: line 50-53[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeometrySearchBuilder::init();
	BoundBoxBuilder::init();
	GeometryShapeChecker::init();
	CollisionDetector::init();</code></td>
          <td>	<code>Processor::init();
	Reader::init();
	Writer::init();
	CouplingMatrixBuilder::init();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 590-591</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 664-665[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aKNE==GEOMAlgo_KN_CIRCLE && aKCE=
	aPC[aNbCE]=aInfoE.Location();</code></td>
          <td>	<code>if (aKNE==GEOMAlgo_KN_CIRCLE && aKCE=
	aPC[i]=aInfoE.Location();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 162-168</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 227-234[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_GluerAlgo::Perform();
	//
	PerformShapesToWork();
	if (myErrorStatus) {
	return;
	}
	if (myWarningStatus==1) {
	</code></td>
          <td>	<code>GEOMAlgo_ShapeAlgo::Perform();
	//
	// 1
	ProcessVertices();
	if(myErrorStatus) {
	return;
	}
	if (myShapeType==TopAbs_VERTEX) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 107-110</strong></td>
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 22-24[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>add_executable(parallel_tests ${PARALLE
	set_target_properties(parallel_tests PR
	
	target_link_libraries(parallel_tests ${</code></td>
          <td>	<code>add_executable(app_tests ${APP_TEST_SOU
	set_target_properties(app_tests PROPERT
	target_link_libraries(app_tests ${CMAKE
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 247-248</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1324-1325[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	if (aMp.Contains(i)) {</code></td>
          <td>	<code>for (i = 1; i <= aNbZones; ++i) {
	if (aMapIndices.Contains(i)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 115-122</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 108-116[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	//=====================================
	// function: BuildResult
	// purpose:
	//=====================================
	void GEOMAlgo_VertexSolid::BuildResult(
	{
	Standard_Integer i, iBeg, iEnd, aNbVV
	</code></td>
          <td>	<code>}
	
	//=====================================
	//function : BuildSolid
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::BuildSolid()
	{
	Standard_Integer i, aNbF, aNbSx, iErr</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 221-227</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 346-352[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNb, iErr;
	TopAbs_State aSt;
	TopAbs_Orientation aOr;
	gp_Pnt aP;
	TopTools_IndexedMapOfShape aM;
	//
	TopExp::MapShapes(myArg1, TopAbs_FACE</code></td>
          <td>	<code>Standard_Integer i, aNb, iCnt, iErr;
	TopAbs_State aSt;
	TopTools_IndexedMapOfShape aM;
	TopExp_Explorer aExp;
	GEOMAlgo_ListIteratorOfListOfPnt aIt;
	//
	TopExp::MapShapes(myShape, TopAbs_EDG</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 46-47</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 56-57[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto data = std::any_cast<std::shared
	REQUIRE(data->name == "A class");</code></td>
          <td>	<code>auto data = std::any_cast<std::shared
	REQUIRE(data->size() == aNumber);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 188-188</strong></td>
        <td style="text-align:center"><strong>src/python/FreeCADParser.py: line 189-189[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>position = [p.attrib["Px"], p.attrib[</code></td>
          <td>	<code>origin = [p.attrib["Ox"], p.attrib["O</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 547-549</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 590-593[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>BRep_Tool::Curve(aE, aT1, aT2);
	aTx=IntTools_Tools::IntermediatePoint
	GEOMAlgo_AlgoTools::PointOnEdge(aE, a
	</code></td>
          <td>	<code>aU=IntTools_Tools::IntermediatePoint(
	aV=IntTools_Tools::IntermediatePoint(
	//
	GEOMAlgo_AlgoTools::PointOnFace(aF, a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 163-165</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 171-172[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>d.set<const Data>("CP_C", std::make_s
	// d.set("CP_CC", std::make_shared<co
	REQUIRE(d.get<const Data>("CP_C")->si</code></td>
          <td>	<code>d.setSerializable<const Data>("CP_S",
	REQUIRE(d.get<const Data>("CP_S")->si
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 97-105</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.cxx: line 87-95[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	if(myBox.IsNull()) {
	myErrorStatus=10; // myBox=NULL
	return;
	}
	//
	aTypeShape=myBox.ShapeType();</code></td>
          <td>	<code>TopoDS_Solid aS;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10; // mySolid=NULL
	return;
	}
	//
	aType=myShape.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 597-600</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 660-663[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aLength=aP1.Distance(aP2);
	aXYZ1=aP1.XYZ();
	aXYZ2=aP2.XYZ();
	aXYZc=aXYZ1+aXYZ2;</code></td>
          <td>	<code>const GEOMAlgo_ShapeInfo& aInfoE=myMa
	aKNE=aInfoE.KindOfName();
	aKCE=aInfoE.KindOfClosed();
	aKSE=aInfoE.KindOfShape();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 99-101</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1046-1048[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>while (!aMapInc.IsEmpty()) {
	TopTools_MapIteratorOfMapOfShape aMap
	const TopoDS_Shape &aWhole = myShapes</code></td>
          <td>	<code>while (!aMapRemaining.IsEmpty()) {
	TopTools_MapIteratorOfMapOfShape anIt
	const TopoDS_Shape &aShape = anIter.K</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 651-651</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 657-657[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>this->myShells[xp.Current().HashCode(</code></td>
          <td>	<code>this->myCompounds[xp.Current().HashCo</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.hxx: line 126-139</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 106-119[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_EXPORT
	void FillFaces() ;
	
	Standard_EXPORT
	void FillShells() ;
	
	Standard_EXPORT
	void FillSolids() ;
	
	Standard_EXPORT
	void FillCompSolids() ;
	
	Standard_EXPORT
	void FillCompounds() ;</code></td>
          <td>	<code>Standard_EXPORT
	void ProcessVertices() ;
	
	Standard_EXPORT
	void ProcessEdges() ;
	
	Standard_EXPORT
	void ProcessFaces() ;
	
	Standard_EXPORT
	void ProcessSolids() ;
	
	Standard_EXPORT
	void InnerPoints(const TopoDS_Face& a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 79-86</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 77-84[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_FinderShapeOn::GEOMAlgo_Finder
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myIsAnalytic=Standard_True;</code></td>
          <td>	<code>GEOMAlgo_FinderShapeOn2::GEOMAlgo_Finde
	:
	GEOMAlgo_ShapeAlgo()
	{
	myTolerance=0.0001;
	myShapeType=TopAbs_VERTEX;
	myState=GEOMAlgo_ST_UNKNOWN;
	myNbPntsMin=3;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 665-669</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 669-673[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>std::cout << "This builder has delete
	}
	if (mkGFA->HasGenerated())
	{
	std::cout << "This builder has genera</code></td>
          <td>	<code>std::cout << "This builder has genera
	}
	if (mkGFA->HasModified())
	{
	std::cout << "This builder has modifi</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 130-138</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 159-167[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	// Compare a shape with an image.
	if (!CompareGProps(aWhole, aLS1)) {
	// Image doesn't correspond to the sh
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
          <td>	<code>}
	
	// Compare a shape with an image.
	if (!CompareGProps(theS, aLS2)) {
	// Image doesn't correspond to the sh
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 153-162</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 108-114[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	
	/// write sparse matrix into a json f
	/// [{"colIndex": value, "colIndex":
	void toJson(const std::string file_na
	{
	/* tested but only for json textual f
	std::ofstream os(file_name);
	os << "[\n";</code></td>
          <td>	<code>}
	
	/// this dump only geometry propertie
	void dump(const std::string file_name
	{
	std::ofstream o(file_name);
	o << '[' << std::endl;
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 85-94</strong></td>
        <td style="text-align:center"><strong>src/PPP/Processor.h: line 95-104   [24]</strong></td>
        </tr>
        <tr>
          <td>	<code>inline const Config characteristics()
	{
	return myCharacteristics;
	}
	
	/// deprecated this in favour of Proc
	void setInputInformation(std::shared_
	{
	myInfo = info;
	}</code></td>
          <td>	<code>std::shared_ptr<Information> getOutpu
	{
	return myInfo;
	}
	
	/// set by builder
	void setOperator(std::shared_ptr<Oper
	{
	myOperator = v;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 160-172</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSurf.cxx: line 65-77[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const GEOMAlgo_DataMapOfShapeMapOfShape
	{
	return myShapesOn;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_GetInPlace::Clear()
	{
	TopoDS_Shape aS;
	//
	myErrorStatus=0;</code></td>
          <td>	<code>const Handle(Geom_Surface)& GEOMAlgo_
	{
	return myS;
	}
	//=====================================
	//function : CheckData
	//purpose :
	//=====================================
	void GEOMAlgo_ClsfSurf::CheckData()
	{
	GeomAbs_SurfaceType aType;
	//
	myErrorStatus=0;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 613-618</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueDetector.cxx: line 415-420[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Edge& aE1=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aE1)) {
	continue;
	}
	//
	if (myShapesOn.IsBound(aE1)) {</code></td>
          <td>	<code>const TopoDS_Edge& aEE=*((TopoDS_Edge
	if (BRep_Tool::Degenerated(aEE)) {
	continue;
	}
	//
	if (myOrigins.IsBound(aE)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 904-912</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 920-928[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>"KN_QUADRANGLE",
	"KN_ARCELLIPSE",
	"KN_SOLID"
	};
	int i;
	//
	i=(Standard_Integer)aKS;
	printf(" KindOfName : %s\n", pStr[i])
	}</code></td>
          <td>	<code>"KD_UNKNOWN",
	"KD_SPECIFIED",
	"KB_ARBITRARY"
	};
	int i;
	//
	i=(Standard_Integer)aKD;
	printf(" KindOfDef: %s\n", pStr[i]);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryMain.cpp: line 11-14</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 671-676[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (argc < 2)
	{
	std::cout << "Error: input config fil
	std::cout << "Usage: geomPipeline con
	
	</code></td>
          <td>	<code>if (mkGFA->HasModified())
	{
	std::cout << "This builder has modifi
	// const auto& inputs = mkGFA->Argume
	
	std::cout << "modified faces count =</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1338-1340</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1401-1403[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_MapIteratorOfMapOfShape aMap
	
	for (; aMapIt.More(); aMapIt.Next())</code></td>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	for (; anIt.More(); anIt.Next()) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 1046-1048</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 99-101[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>while (!aMapRemaining.IsEmpty()) {
	TopTools_MapIteratorOfMapOfShape anIt
	const TopoDS_Shape &aShape = anIter.K</code></td>
          <td>	<code>while (!aMapInc.IsEmpty()) {
	TopTools_MapIteratorOfMapOfShape aMap
	const TopoDS_Shape &aWhole = myShapes</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 932-943</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 732-743[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	}
	//=====================================
	//function : MakeFace
	//purpose :
	//=====================================
	void GEOMAlgo_Gluer::MakeFace(const Top
	TopoDS_Face& aNewFace)
	{
	myErrorStatus=0;
	//
	Standard_Boolean bIsToReverse, bIsUPe</code></td>
          <td>	<code>}// if (!aNb && myNbPntsMin) {
	}
	//=====================================
	//function : InnerPoints
	//purpose :
	//=====================================
	void GEOMAlgo_FinderShapeOn2::InnerPoin
	GEOMAlgo_ListOfPnt& aLP)
	{
	myErrorStatus=0;
	//
	Standard_Integer j, aNbNodes, aIndex,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 122-130</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 186-194[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, iBeg, iEnd, aNbVV
	Standard_Real aTol;
	TopAbs_State aSt;
	TopAbs_ShapeEnum aType;
	gp_Pnt aP3D;
	//
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();</code></td>
          <td>	<code>TopAbs_ShapeEnum aType;
	TopAbs_State aState;
	gp_Pnt aP;
	gp_Pnt2d aP2D;
	TopoDS_Face aF;
	//
	myLSIN.Clear();
	myLSOUT.Clear();
	myLSON.Clear();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 219-227</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 502-509[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>myErrorStatus=0;
	//
	Standard_Boolean bIsClosed;
	TopAbs_ShapeEnum aType;
	GEOMAlgo_KindOfClosed aKC;
	//
	aType=aS.ShapeType();
	//-----------------------------------
	if (myMapInfo.Contains(aS)) {</code></td>
          <td>	<code>TopAbs_ShapeEnum aType;
	Standard_Integer aR;
	BRep_Builder BB;
	TopoDS_Iterator aIt;
	//
	aType=aE.ShapeType();
	//
	if (aOriginals.IsBound(aE)) {
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 634-639</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 647-649[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (iCnt>1) {
	// take the first having occurred inn
	// and discretize it
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	//
	aN1=(Standard_Integer)aPK.Id(1);</code></td>
          <td>	<code>if (iCnt==1) {
	const GEOMAlgo_PassKey& aPK=aIt.Key()
	aNx=(Standard_Integer)aPK.Id(1);
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 102-103</strong></td>
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 112-113[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (Utilities::hasFileExt(file_name,
	{</code></td>
          <td>	<code>else if (Utilities::hasFileExt(file_n
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 451-457</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 221-227[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer i, aNbF, iCnt, iErr;
	TopAbs_State aSt;
	TopTools_IndexedMapOfShape aM;
	TopExp_Explorer aExp;
	GEOMAlgo_ListIteratorOfListOfPnt aIt;
	//
	TopExp::MapShapes(myShape, TopAbs_FAC</code></td>
          <td>	<code>Standard_Integer i, aNb, iErr;
	TopAbs_State aSt;
	TopAbs_Orientation aOr;
	gp_Pnt aP;
	TopTools_IndexedMapOfShape aM;
	//
	TopExp::MapShapes(myArg1, TopAbs_FACE</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 834-838</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryReader.h: line 185-189[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopTools_ListIteratorOfListOfShape an
	
	while (anIter.More()) {
	const TopoDS_Shape &aSubShape = anIte
	Standard_Boolean isToRm = Standard_Fa</code></td>
          <td>	<code>TopExp_Explorer Ex(shape, TopAbs_SOLI
	while (Ex.More())
	{
	const TopoDS_Shape& s = Ex.Current();
	json pp = p;</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools_1.cxx: line 132-135</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GlueAnalyser.cxx: line 204-206[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aChain.Add(aF);
	//
	const TopTools_IndexedMapOfShape& aMV
	aNbV=aMV.Extent();</code></td>
          <td>	<code>const Bnd_Box& aBoxV=aMSB.FindFromKey
	const TColStd_ListOfInteger& aLI=aBSB
	aNbVSD=aLI.Extent();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 752-754</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.cxx: line 554-558[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Handle(Poly_Polygon3D) aPE = BRep_Too
	if (aPE.IsNull()) {
	if (!BuildTriangulation(aE)) {
	
	</code></td>
          <td>	<code>aLP.Clear();
	//
	aTRF=BRep_Tool::Triangulation(aF, aLo
	if (aTRF.IsNull()) {
	if (!GEOMAlgo_AlgoTools::BuildTriangu</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 604-609</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 315-320[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>gp_Vec aVec(aPc, aP2);
	gp_Dir aDir(aVec);
	//
	aInfo.SetLocation(aPc);
	aInfo.SetDirection(aDir);
	aInfo.SetLength(aLength);</code></td>
          <td>	<code>gp_Ax2 aAx2(aPc, aDir[iMin], aDir[iMa
	gp_Ax3 aAx3(aAx2);
	//
	aInfo.SetKindOfName(GEOMAlgo_KN_BOX);
	aInfo.SetLocation(aPc);
	aInfo.SetLength(aLength);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 314-315</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 327-328[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(countSubShapes(compSolid, Top
	REQUIRE(countSubShapes(compSolid, Top</code></td>
          <td>	<code>REQUIRE(countSubShapes(readback, TopA
	REQUIRE(countSubShapes(readback, TopA</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 901-902</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_SurfaceTools.cxx: line 147-148[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const gp_Pnt& aPC1=aSp1.Position().Lo
	const gp_Pnt& aPC2=aSp2.Position().Lo</code></td>
          <td>	<code>const gp_XYZ &aLoc = aCyl.Location().
	const gp_Ax1 &aAxis = aCyl.Axis();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 160-162</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 122-124[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (aType==theType && !myMapTools.Con
	if (myImages.IsBound(aS)) {
	const TopTools_ListOfShape& aLSIm=myI</code></td>
          <td>	<code>if (!aS.IsNull()) {
	if (myMapInfo.Contains(aS)) {
	const GEOMAlgo_ShapeInfo& aInfo=myMap</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 101-108</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_2.cxx: line 122-129[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape &aWhole = myShapes
	
	if (!myImages.IsBound(aWhole)) {
	// Should not be.
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
          <td>	<code>const TopoDS_Shape &aS1x = aItS1x.Val
	
	if (!aMapInc.Remove(aS1x)) {
	// There is no aS1x in theS. Should n
	UpdateChecked(theS, 0);
	myFound = Standard_False;
	return 0;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/OccBVHdemo.cpp: line 88-89</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryShapeChecker.h: line 124-125[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const BVH_Vec3d& aQ1 = aBvh->MinPoint
	const BVH_Vec3d& aQ2 = aBvh->MaxPoint</code></td>
          <td>	<code>const Handle(BRepCheck_Result)& resul
	const BRepCheck_ListOfStatus& status</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 609-614</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 413-417[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_AlgoTools::PointOnEdge(aE, a
	}
	break;
	//
	case TopAbs_FACE: {
	const TopoDS_Face& aF=TopoDS::Face(aS</code></td>
          <td>	<code>aBB.UpdateVertex(aVx, myTolerance);
	}
	break;
	case TopAbs_EDGE: {
	const TopoDS_Edge& aEx=TopoDS::Edge(a
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 178-179</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 412-413[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>for ( Exp_aWhat.ReInit(); Exp_aWhat.M
	GetShapeProperties( Exp_aWhat.Current</code></td>
          <td>	<code>for (; It.More(); It.Next()) {
	MakeSubShapes(It.Value(), theMS, theR</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.cxx: line 52-66</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_BndSphereTree.cxx: line 63-77[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aS2=myShape2;
	}
	//=====================================
	//function : SetShape1
	//purpose :
	//=====================================
	void GEOMAlgo_CoupleOfShapes::SetShape1
	{
	myShape1=aS1;
	}
	//=====================================
	//function : SetShape2
	//purpose :
	//=====================================
	void GEOMAlgo_CoupleOfShapes::SetShape2</code></td>
          <td>	<code>return bRet;
	}
	//=====================================
	//function : SetBox
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::
	{
	myBox=aBox;
	}
	//=====================================
	//function : Clear
	//purpose :
	//=====================================
	void GEOMAlgo_BndSphereTreeSelector::</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 508-515</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 709-716[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer aNbV, aNbE, aNbF;
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aNbE=NbSubShapes(TopAbs_EDGE);</code></td>
          <td>	<code>Standard_Real aX, aY, aZ;
	GEOMAlgo_KindOfShape aKS;
	GEOMAlgo_KindOfName aKN;
	GEOMAlgo_KindOfBounds aKB;
	GEOMAlgo_KindOfClosed aKC;
	//
	aNbV=NbSubShapes(TopAbs_VERTEX);
	aKS=KindOfShape();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 188-190</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 236-239[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	mkGFA->SetFuzzyValue(theTolerance);
	</code></td>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(not internalMul</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 56-60</strong></td>
        <td style="text-align:center"><strong>src/Geom/Geom.cpp: line 61-64      [24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GeometryProcessor::init();
	GeometryReader::init();
	GeometryWriter::init();
	
	GeometryPropertyBuilder::init();</code></td>
          <td>	<code>GeometrySearchBuilder::init();
	BoundBoxBuilder::init();
	GeometryShapeChecker::init();
	CollisionDetector::init();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 315-316</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 827-828[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (anIter.Initialize(mySubShapes);
	const TopoDS_Shape &aSubShape = anIte</code></td>
          <td>	<code>for (anExp.Init(myShape, theType); an
	const TopoDS_Shape &aShape = anExp.Cu</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/OccUtils.cpp: line 671-676</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometryMain.cpp: line 11-14[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (mkGFA->HasModified())
	{
	std::cout << "This builder has modifi
	// const auto& inputs = mkGFA->Argume
	
	std::cout << "modified faces count =</code></td>
          <td>	<code>if (argc < 2)
	{
	std::cout << "Error: input config fil
	std::cout << "Usage: geomPipeline con
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 122-124</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 160-162[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>if (!aS.IsNull()) {
	if (myMapInfo.Contains(aS)) {
	const GEOMAlgo_ShapeInfo& aInfo=myMap</code></td>
          <td>	<code>if (aType==theType && !myMapTools.Con
	if (myImages.IsBound(aS)) {
	const TopTools_ListOfShape& aLSIm=myI</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 557-562</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 453-459[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>bIsToReverse=IsToReverse(aFR, aF);
	if (bIsToReverse) {
	aFR.Reverse();
	}
	aBB.Add(aNewShell, aFR);
	}
	</code></td>
          <td>	<code>bToReverse=BOPTools_AlgoTools::IsSpli
	if (bToReverse) {
	aEnew.Reverse();
	}
	//
	aBB.Add(aWnew, aEnew);
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKeyShape.cxx: line 157-160</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 277-280[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	myMap.Add(aS);
	}
	myNbIds=myMap.Extent();</code></td>
          <td>	<code>const TopoDS_Shape& aS=aIt.Value();
	aLS.Append(aS);
	}
	aNbS=aLS.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/CMakeLists.txt: line 21-23</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 61-63 [24]</strong></td>
        </tr>
        <tr>
          <td>	<code>endif()
	
	##################### standalone app ##</code></td>
          <td>	<code>endif()
	
	#######################################</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 481-485</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 125-128[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean GEOMAlgo_AlgoTools::Pr
	(const gp_Pnt& aP1,
	const TopoDS_Shape& aS,
	gp_Pnt& aP2,
	const Handle(IntTools_Context)& aCtx)</code></td>
          <td>	<code>static Standard_Boolean ProjectPointO
	const TopoDS_Shape& aS,
	gp_Pnt& aP2,
	const Handle(IntTools_Context)& aCtx)
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 326-333</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.hxx: line 40-46[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>void CheckGProps() ;
	
	Standard_EXPORT
	void FillShapesIn(const TopoDS_Shape&
	const TopoDS_Shape& theS2) ;
	
	Standard_EXPORT
	void FillShapesOn(const TopoDS_Shape&</code></td>
          <td>	<code>GEOMAlgo_CoupleOfShapes();
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShape1(const TopoDS_Shape& aS
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 151-154</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainerTest.cpp: line 160-163[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>REQUIRE(d.getConst<Data>("C")->size()
	
	// if it is pointer, it must provide
	d.set<Data>("CP", std::make_shared<Da</code></td>
          <td>	<code>REQUIRE(d.get<Data>("CP_V")->size() =
	
	// test const, const can not be moved
	d.set<const Data>("CP_C", std::make_s</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.hxx: line 125-128</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 481-485[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>static Standard_Boolean ProjectPointO
	const TopoDS_Shape& aS,
	gp_Pnt& aP2,
	const Handle(IntTools_Context)& aCtx)
	</code></td>
          <td>	<code>Standard_Boolean GEOMAlgo_AlgoTools::Pr
	(const gp_Pnt& aP1,
	const TopoDS_Shape& aS,
	gp_Pnt& aP2,
	const Handle(IntTools_Context)& aCtx)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 273-274</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 284-285[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aVx=*((TopoDS_Vertex*)(&aIt.Value()))
	aP3D=BRep_Tool::Pnt(aVx);</code></td>
          <td>	<code>aVx=*((TopoDS_Vertex*)(&aIt.Value()))
	aP3D=BRep_Tool::Pnt(aVx);</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 583-585</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 810-812[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>bInf1=Precision::IsNegativeInfinite(a
	bInf2=Precision::IsPositiveInfinite(a</code></td>
          <td>	<code>bInf1=Precision::IsNegativeInfinite(a
	bInf2=Precision::IsPositiveInfinite(a</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 247-249</strong></td>
        <td style="text-align:center"><strong>src/PropertyContainer/PropertyContainer.hpp: line 306-308[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>p.setFlag(PropertyFlag::Transient); /
	myProperties.emplace(key, std::move(p
	}</code></td>
          <td>	<code>p.setFlag(PropertyFlag::Transient); /
	myProperties.emplace(key, std::move(p
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 160-169</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeometrySearchBuilder.h: line 192-201[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>myFilterCount = myBoundBoxes.size();
	}
	else if (myShapeSearchType == ShapeSe
	{
	// todo: single filename full path or
	}
	else
	{
	LOG_F(WARNING, "Geometry search input
	}</code></td>
          <td>	<code>matched[index] = matchBoundBox(index,
	}
	else if (myShapeSearchType == ShapeSe
	{
	// todo
	}
	else
	{
	LOG_F(WARNING, "Geometry search input
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 783-786</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_3.cxx: line 195-197[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shape& aE1=aMEToAdd.Find
	const TopTools_ListOfShape& aLE=aMETo
	//
	aPKE1.SetShapes(aE1);</code></td>
          <td>	<code>const TopoDS_Shape& aSkey=aMC.FindKey
	const TopTools_IndexedMapOfShape& aM=
	aLSX.Clear();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1324-1325</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 247-248[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (i = 1; i <= aNbZones; ++i) {
	if (aMapIndices.Contains(i)) {</code></td>
          <td>	<code>for (i=1; i<=aNbF; ++i) {
	if (aMp.Contains(i)) {</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 418-422</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 609-614[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.UpdateEdge(aEx, myTolerance);
	}
	break;
	case TopAbs_FACE: {
	const TopoDS_Face& aFx=TopoDS::Face(a
	</code></td>
          <td>	<code>GEOMAlgo_AlgoTools::PointOnEdge(aE, a
	}
	break;
	//
	case TopAbs_FACE: {
	const TopoDS_Face& aF=TopoDS::Face(aS</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 308-312</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.hxx: line 86-90[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Boolean GEOMAlgo_GetInPlaceAPI
	(const Handle(GEOM_Function) &theWher
	const TopTools_IndexedMapOfShape &the
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac</code></td>
          <td>	<code>Standard_EXPORT static Standard_Boole
	(const Handle(GEOM_Function) &theWher
	const TopTools_IndexedMapOfShape &the
	const TopoDS_Shape &theWhat,
	TopTools_ListOfShape &theShapesInPlac</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 507-511</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 957-959[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillNbSubShapes(aS, aInfo);
	//
	aE=TopoDS::Edge(aS);
	//
	bDegenerated=BRep_Tool::Degenerated(a</code></td>
          <td>	<code>aS=BRep_Tool::Surface(aFFWD, aLoc);
	bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP
	aTol=BRep_Tool::Tolerance(aFFWD);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 23-29</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfo.cxx: line 29-35[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>Standard_Integer TypeToInteger(const
	static
	void DumpKindOfShape(const GEOMAlgo_K
	static
	void DumpKindOfClosed(const GEOMAlgo_
	static
	void DumpKindOfBounds(const GEOMAlgo_</code></td>
          <td>	<code>void DumpKindOfBounds(const GEOMAlgo_
	static
	void DumpKindOfName(const GEOMAlgo_Ki
	static
	void DumpKindOfDef(const GEOMAlgo_Kin
	static
	void DumpPosition(const gp_Ax3& aAx3)</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeometryPropertyBuilder.h: line 123-132</strong></td>
        <td style="text-align:center"><strong>src/PPP/SparseMatrix.h: line 153-162[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/// write meta data in json for solid
	/// suppressed Item will not have met
	/// if there is no name information,
	/// if there is no coloar or material
	void writeMetaData(const std::string
	{
	std::ofstream o(file_name);
	o << '[' << std::endl;</code></td>
          <td>	<code>}
	
	
	/// write sparse matrix into a json f
	/// [{"colIndex": value, "colIndex":
	void toJson(const std::string file_na
	{
	/* tested but only for json textual f
	std::ofstream os(file_name);
	os << "[\n";</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 250-254</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 448-450[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aC2DS2=BRep_Tool::CurveOnSurface(aES,
	//
	aTS=IntTools_Tools::IntermediatePoint
	//
	aC2DS1->D1(aTS, aP2DS1, aV2DS1);</code></td>
          <td>	<code>Handle(Geom_Curve)aC1=BRep_Tool::Curv
	aT1=IntTools_Tools::IntermediatePoint
	aC1->D0(aT1, aP);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfSolid.cxx: line 87-95</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ClsfBox.cxx: line 97-105[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>TopoDS_Solid aS;
	//
	if (myShape.IsNull()) {
	myErrorStatus=10; // mySolid=NULL
	return;
	}
	//
	aType=myShape.ShapeType();</code></td>
          <td>	<code>myErrorStatus=0;
	//
	if(myBox.IsNull()) {
	myErrorStatus=10; // myBox=NULL
	return;
	}
	//
	aTypeShape=myBox.ShapeType();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 270-275</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx: line 317-322[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>myClsf->CheckData();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=41; // invalid data for
	return;
	}</code></td>
          <td>	<code>myClsf->Perform();
	iErr=myClsf->ErrorStatus();
	if (iErr) {
	myErrorStatus=40; // point can not be
	return;
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 255-257</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 271-273[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aItLS.Initialize(aLSR);
	for (; aItLS.More(); aItLS.Next()) {
	aSd=*((TopoDS_Solid*)&aItLS.Value());</code></td>
          <td>	<code>aIt.Initialize(aLV);
	for (; aIt.More(); aIt.Next()) {
	aVx=*((TopoDS_Vertex*)(&aIt.Value()))</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.cxx: line 304-311</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_PassKey.cxx: line 138-143[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>BOPAlgo_PaveFiller aPF;
	//
	// 1. Prepare DSFiller
	aLS.Append(myArg1);
	aLS.Append(aS);
	aPF.SetArguments(aLS);
	//
	aPF.Perform();</code></td>
          <td>	<code>TColStd_ListOfInteger aLI;
	//
	aLI.Append(aId1);
	aLI.Append(aId2);
	aLI.Append(aId3);
	aLI.Append(aId4);
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.hxx: line 40-46</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 326-333[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_CoupleOfShapes();
	
	Standard_EXPORT
	void SetShapes(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShape1(const TopoDS_Shape& aS
	</code></td>
          <td>	<code>void CheckGProps() ;
	
	Standard_EXPORT
	void FillShapesIn(const TopoDS_Shape&
	const TopoDS_Shape& theS2) ;
	
	Standard_EXPORT
	void FillShapesOn(const TopoDS_Shape&</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 104-117</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx: line 122-132[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>CheckData();
	if (HasErrors()) {
	return;
	}
	//
	// 2. Prepare
	Prepare();
	if (HasErrors()) {
	return;
	}
	//
	// 3. Fill Images
	// 3.1 Vertice
	FillImagesVertices();</code></td>
          <td>	<code>BuildResult(TopAbs_VERTEX);
	if (HasErrors()) {
	return;
	}
	// 3.2 Edges
	FillImagesEdges();
	if (HasErrors()) {
	return;
	}
	//
	BuildResult(TopAbs_EDGE);
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfName.hxx: line 39-55</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_KindOfShape.hxx: line 29-45[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>GEOMAlgo_KN_ARCCIRCLE,
	GEOMAlgo_KN_POLYGON,
	GEOMAlgo_KN_POLYHEDRON,
	GEOMAlgo_KN_DISKCIRCLE,
	GEOMAlgo_KN_DISKELLIPSE,
	GEOMAlgo_KN_RECTANGLE,
	GEOMAlgo_KN_TRIANGLE,
	GEOMAlgo_KN_QUADRANGLE,
	GEOMAlgo_KN_ARCELLIPSE,
	GEOMAlgo_KN_SOLID
	};
	
	#ifndef _Standard_PrimitiveTypes_Header
	#include <Standard_PrimitiveTypes.hxx>
	#endif
	
	#endif</code></td>
          <td>	<code>GEOMAlgo_KS_CYLINDER,
	GEOMAlgo_KS_BOX,
	GEOMAlgo_KS_TORUS,
	GEOMAlgo_KS_CONE,
	GEOMAlgo_KS_ELLIPSE,
	GEOMAlgo_KS_PLANE,
	GEOMAlgo_KS_CIRCLE,
	GEOMAlgo_KS_LINE,
	GEOMAlgo_KS_DEGENERATED,
	GEOMAlgo_KS_BSPLINE
	};
	
	#ifndef _Standard_PrimitiveTypes_Header
	#include <Standard_PrimitiveTypes.hxx>
	#endif
	
	#endif</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2.cxx: line 453-456</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_2.cxx: line 102-105[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>bToReverse=BOPTools_AlgoTools::IsSpli
	if (bToReverse) {
	aEnew.Reverse();
	}</code></td>
          <td>	<code>bToReverse=BOPTools_AlgoTools::IsSpli
	if (bToReverse) {
	aSim.Reverse();
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 79-83</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 191-194[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aInfo.SetKindOfName(GEOMAlgo_KN_UNKNO
	//
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	aNbF=aMF.Extent();</code></td>
          <td>	<code>aBB.MakeCompound(aC);
	//
	TopExp::MapShapes(myShape, myLimit, a
	aNbS=aMx.Extent();
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 169-172</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace_1.cxx: line 175-178[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}//if (aType1==TopAbs_EDGE) {
	//
	else if (aType1==TopAbs_FACE) {
	const TopoDS_Face& aF1=*((TopoDS_Face</code></td>
          <td>	<code>}
	//
	else if (aType1==TopAbs_SOLID) {
	const TopoDS_Solid& aZ1=*((TopoDS_Sol</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 292-295</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 188-190[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	// mkGFA->SetGlue(BOPAlgo_GlueShift);
	mkGFA->SetRunParallel(false);</code></td>
          <td>	<code>auto mkGFA = std::make_shared<BRepAlg
	mkGFA->SetNonDestructive(true);
	mkGFA->SetFuzzyValue(theTolerance);
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 852-860</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 103-107[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aArea=aSphere[0].Area();
	//
	//modified by NIZNHY-PKV Tue Jun 09 0
	BRepGProp::SurfaceProperties(aSd, aGP
	//BRepGProp::SurfaceProperties(aSd, a
	//modified by NIZNHY-PKV Tue Jun 09 0
	aAreaS=aGProps.Mass();
	//
	dA=fabs(aAreaS-aArea);</code></td>
          <td>	<code>const TopoDS_Shape& aObj=aLS.First();
	//
	TopExp::MapShapes(aObj, TopAbs_FACE,
	aNbF=aM.Extent();
	myRank=(aNbF) ? 1 : 0;
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn.hxx: line 66-72</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_FinderShapeOn1.hxx: line 64-70[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>void SetSurface(const Handle(Geom_Sur
	
	Standard_EXPORT
	void SetShapeType(const TopAbs_ShapeE
	
	Standard_EXPORT
	void SetState(const GEOMAlgo_State aS</code></td>
          <td>	<code>void SetSurface(const Handle(Geom_Sur
	
	Standard_EXPORT
	void SetShapeType(const TopAbs_ShapeE
	
	Standard_EXPORT
	void SetState(const GEOMAlgo_State aS</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/CouplingMatrixBuilder.h: line 60-69</strong></td>
        <td style="text-align:center"><strong>src/Geom/BoundBoxBuilder.h: line 41-45[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/**
	* \brief preparing work in serial mod
	*/
	virtual void prepareOutput() override
	{
	// todo: if called in pipeline explic
	// myCouplingMatrix.writeMatrixMarket
	myOutputData->emplace("myCouplingMatr</code></td>
          <td>	<code>}
	
	virtual void prepareOutput() override
	{
	myOutputData->emplace("myShapeBoundBo
	
	
	
	
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 935-941</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.cxx: line 944-950[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>FillImgSimple(theShape, TopAbs_VERTEX
	//
	// 2. Edges
	FillImgSimple(theShape, TopAbs_EDGE,
	//
	// 3. Wires
	FillImgComplex(theShape, TopAbs_WIRE,</code></td>
          <td>	<code>FillImgSimple(theShape, TopAbs_FACE,
	//
	// 5. Shells
	FillImgComplex(theShape, TopAbs_SHELL
	//
	// 6. Solids
	FillImgSimple(theShape, TopAbs_SOLID,</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_RemoverWebs.cxx: line 108-116</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_VertexSolid.cxx: line 115-122[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	//=====================================
	//function : BuildSolid
	//purpose :
	//=====================================
	void GEOMAlgo_RemoverWebs::BuildSolid()
	{
	Standard_Integer i, aNbF, aNbSx, iErr</code></td>
          <td>	<code>}
	//=====================================
	// function: BuildResult
	// purpose:
	//=====================================
	void GEOMAlgo_VertexSolid::BuildResult(
	{
	Standard_Integer i, iBeg, iEnd, aNbVV
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 921-935</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlaceAPI.cxx: line 221-234[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	return aResult;
	}
	
	//=====================================
	//function : getShapeFromSubShapes
	//purpose :
	//=====================================
	TopoDS_Shape GEOMAlgo_Extractor::getSha
	(const TopoDS_Shape &theShape,
	const TopTools_ListOfShape &theSubSha
	{
	// Fill the map of sub-shapes.
	TopTools_ListIteratorOfListOfShape an</code></td>
          <td>	<code>}
	
	return 0;
	}
	
	//=====================================
	//function : GetNormal
	//purpose :
	//=====================================
	gp_Vec GEOMAlgo_GetInPlaceAPI::GetNorma
	(const TopoDS_Face &theFace,
	const BRepExtrema_DistShapeShape &the
	{
	gp_Vec defaultNorm(1,0,0); // to have
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 172-176</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_AlgoTools.cxx: line 569-573[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>void GEOMAlgo_AlgoTools::FaceNormal (co
	const Standard_Real U,
	const Standard_Real V,
	gp_Vec& aN)
	{</code></td>
          <td>	<code>void GEOMAlgo_AlgoTools::PointOnFace(co
	const Standard_Real aU,
	const Standard_Real aV,
	gp_Pnt& aP3D)
	{</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 74-78</strong></td>
        <td style="text-align:center"><strong>src/Geom/CollisionDetector.cpp: line 778-781[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	auto max_original_volume = *std::max_
	// auto min_original_volume = *std::m
	
	if (resultShapes.size() > originalSha</code></td>
          <td>	<code>}
	auto maxOther = *std::max_element(int
	
	if (thisCount > maxOther)
	</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Splitter.cxx: line 191-194</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller_1.cxx: line 79-83[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aBB.MakeCompound(aC);
	//
	TopExp::MapShapes(myShape, myLimit, a
	aNbS=aMx.Extent();
	</code></td>
          <td>	<code>aInfo.SetKindOfName(GEOMAlgo_KN_UNKNO
	//
	TopExp::MapShapes(aSd, TopAbs_FACE, a
	//
	aNbF=aMF.Extent();</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/LICENSE: line 326-327</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/LICENSE: line 368-369[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>that part of it is a work based on th
	where to find the accompanying uncomb</code></td>
          <td>	<code>particular circumstance, the balance of
	and the section as a whole is intended</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 544-549</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_ShapeInfoFiller.cxx: line 333-338[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>const TopoDS_Shell& aShell=TopoDS::Sh
	anOr=aShell.Orientation();
	//
	aBB.MakeShell(aNewShell);
	aNewShell.Orientation(anOr);
	aExp.Init(aShell, TopAbs_FACE);</code></td>
          <td>	<code>aP0=aPln.Location();
	aAx3=aPln.Position();
	//
	aInfo.SetKindOfShape(GEOMAlgo_KS_PLAN
	aInfo.SetKindOfName(GEOMAlgo_KN_PLANE
	aInfo.SetKindOfClosed(GEOMAlgo_KC_NOT</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer2_1.cxx: line 116-118</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Gluer.cxx: line 955-958[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>aTol=BRep_Tool::Tolerance(aFF);
	aS=BRep_Tool::Surface(aFF, aLoc);
	bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP
	</code></td>
          <td>	<code>aFFWD.Orientation(TopAbs_FORWARD);
	//
	aS=BRep_Tool::Surface(aFFWD, aLoc);
	bIsUPeriodic=GEOMAlgo_AlgoTools::IsUP</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_Extractor.cxx: line 1108-1110</strong></td>
        <td style="text-align:center"><strong>src/Geom/GeomTests/GeomTests.cpp: line 336-339[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>for (anIter.Next(); anIter.More(); an
	myNew.Append(anIter.Value());
	}
	</code></td>
          <td>	<code>for (TopExp_Explorer anExp(loaded_sha
	{
	shapes.push_back(anExp.Current());
	}</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_GetInPlace.hxx: line 294-303</strong></td>
        <td style="text-align:center"><strong>src/Geom/third-party/SGeom/src/GEOMAlgo/GEOMAlgo_CoupleOfShapes.hxx: line 43-52[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>void FillEdgesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillFacesOn(const TopoDS_Shape &
	
	Standard_EXPORT
	void FillSolidsOn(const TopoDS_Shape
	
	Standard_EXPORT
	void PerformZF() ;</code></td>
          <td>	<code>void SetShapes(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShape1(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void SetShape2(const TopoDS_Shape& aS
	
	Standard_EXPORT
	void Shapes(TopoDS_Shape& aS1,TopoDS_</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/test/CMakeLists.txt: line 22-24</strong></td>
        <td style="text-align:center"><strong>src/PPP/CMakeLists.txt: line 107-110[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>add_executable(app_tests ${APP_TEST_SOU
	set_target_properties(app_tests PROPERT
	target_link_libraries(app_tests ${CMAKE
	</code></td>
          <td>	<code>add_executable(parallel_tests ${PARALLE
	set_target_properties(parallel_tests PR
	
	target_link_libraries(parallel_tests ${</code></td>
        </tr>
        
        <tr class="table-dark text-dark">
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 208-215</strong></td>
        <td style="text-align:center"><strong>src/PPP/ThreadPoolExecutor.h: line 238-242[24]</strong></td>
        </tr>
        <tr>
          <td>	<code>}
	
	/**
	* build a adjacencyMatrix to identify
	* */
	void runParallelOnCoupledData(std::sh
	{
	const auto dim = pa->indexDimension()</code></td>
          <td>	<code>}
	
	void runAsynchronouslyOnCoupledData(s
	{
	const auto dim = pa->indexDimension()
	
	
	</code></td>
        </tr>
        
    </container>
    </body>
</html>
      